<!DOCTYPE html><html lang="zh-cn" dir="ltr"><head><meta charset="utf-8"><style>:where(img[jampack-sized]){max-width:100%;height:auto}</style><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"><meta name="description" content="调用 ReactDOM.render 发生了什么？ 确定应用渲染方式； 创建 fiberRoot 和 rootFiberNode，并将两者用指针指向彼此； 向 rootFiberNode 绑定自身的更新队列； 清空 container 里的内容； 向 container 绑定原生事件； 将 render 的第三个参数的 this 指向应用实例并调用； 初始化完成后，创建 update，并将 fiber 对应的组件作为 payload； 将 update 与 fiberNode 相关联，fiberNode 对应的 update 组成循环链表； 调用 scheduleUpdateOnFiber 开始渲染工作。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 // ReactDOM 的渲染模式 export type RootTag = 0 | 1 | 2; export const LegacyRoot = 0; // ReactDOM.createLegacyRoot export const BlockingRoot = 1; // ReactDOM.createBlockingRoot export const ConcurrentRoot = 2; // ReactDOM.createRoot // ReactDOM.render export function render( element: React$Element<any>, container: Container, callback: ?Function ) { // 向 DOMContainer 里渲染子树 return legacyRenderSubtreeIntoContainer( null, element, container, false, callback ); } function legacyRenderSubtreeIntoContainer( parentComponent: ?React$Component<any, any>, // null children: ReactNodeList, // ReactElement container: Container, // DOMContainer forceHydrate: boolean, // false callback: ?Function // () => {} ) { let root: RootType = container._reactRootContainer; let fiberRoot; if (!root) { /** * 初始化阶段准备工作： * 0. legacyCreateRootFromDOMContainer 最终会调用 createRootImpl * 1. container._reactRootContainer._internalRoot = createRootImpl(container, 0, undefined) * 2. createRootImpl(container, 0, undefined) 返回了 fiberRoot * 3. fiberRoot 一个应用只有一个，其 current 属性指向了 rootFiberNode * 4. fiberRoot.current 指向了 currentFiber 树 * 5. fiberRoot.finishedWork 指向了 workInProgress 树 * 6. 清空 container */ root = container._reactRootContainer = legacyCreateRootFromDOMContainer( container, forceHydrate ); fiberRoot = root._internalRoot; if (typeof callback === 'function') { const originalCallback = callback; callback = function () { /** * getPublicRootInstance 会通过 fiberRoot 访问 rootFiberNode * 如果 rootFiberNode 没有子节点，返回 null * 否则返回 rootFiberNode 子节点的 stateNode * 总之就是返回一个非 rootFiberNode 的组件实例 */ const instance = getPublicRootInstance(fiberRoot); // 调用了 callback 就说明应用初始化完成了 originalCallback.call(instance); }; } // 初始化完成之后，就准备进行应用渲染了 unbatchedUpdates(() => { updateContainer(children, fiberRoot, parentComponent, callback); }); } else { // 后续更新需要重新渲染，会走这里 fiberRoot = root._internalRoot; if (typeof callback === 'function') { const originalCallback = callback; callback = function () { const instance = getPublicRootInstance(fiberRoot); originalCallback.call(instance); }; } updateContainer(children, fiberRoot, parentComponent, callback); } return getPublicRootInstance(fiberRoot); } function createRootImpl( container: Container, tag: RootTag, // 用来表示是否开启“并发模式” options: void | RootOptions ) { const root = createFiberRoot( container, tag, (hydrate = false), (hydrationCallbacks = null) ); container.__reactContainer$ = root.current; /** * 获取应用挂载的 DOM 的 nodeType： * Node.ELEMENT_NODE 1 元素节点 * Node.TEXT_NODE 3 文字节点 * Node.CDATA_SECTION_NODE 4 <!CDATA[[ … ]]> * Node.PROCESSING_INSTRUCTION_NODE 7 <?xml-stylesheet ... ?> * Node.COMMENT_NODE 8 注释节点 * Node.DOCUMENT_NODE 9 Document * Node.DOCUMENT_TYPE_NODE 10 <!DOCTYPE html> * Node.DOCUMENT_FRAGMENT_NODE 11 DocumentFragment */ const rootContainerElement = container.nodeType === COMMENT_NODE ? container.parentNode : container; rootContainerElement._reactListening = true; /** * allNativeEvents 是包含了离散（触发）事件、阻塞（用户交互）事件、连续（不能被打断）事件、表单事件的 Set * nonDelegatedEvents 是放置的是“非委托”事件的 Set&nbsp;(类似于一个白名单) * listenToNativeEvent(事件名称，是否在捕获阶段触发，应用根容器，目标元素) * 1. 将 selectionchange 绑定到 document * 2. 将支持“冒泡”的事件委托到 rootContainerElement * 3. 其他的事件除了 scroll、load... 外，绑定到“目标元素” * 4. 从 EventTarget.__reactEvents 找到所有绑定的 listener（保存在 Set 里） * 5. listener 里如果没有 `${domEventName}__${capture ? 'capture' : 'bubble'}` 会执行 addTrappedEventListener * addTrappedEventListener(EventTarget, DOMEventName, EventSystemFlags, isCapture, isDeferred) * 1. createEventListenerWrapperWithPriority 会根据事件类型，使用不同的优先级函数包裹 listener（事件优先级），将 DOM 事件转发到 React 内部 * a. dispatchDiscreteEvent 离散事件，最高优先级 * b. dispatchUserBlockingUpdate 用户阻塞事件 * c. dispatchEvent 连续事件 * 2. 对于“touchstart”、“touchmove”、“wheel”三个事件，isPassive=true（preventDefault 失效） * 3. 根据 isCapture 和 isPassive 将事件绑定分发给了四个函数 addEvent[Bubble/Capture]Listener[WithPassiveFlag] * 4. 调用原生 API：addEventListener 和 removeEventListener 进行事件的绑定和移除 * 总的来说，React 会根据事件 isCapture、isPassive 和优先级，将事件绑定到合适的 target 上 */ allNativeEvents.forEach(domEventName => { if (!nonDelegatedEvents.has(domEventName)) { // 可以使用“事件委托” listenToNativeEvent( domEventName, false, // “事件委托”需要“事件冒泡”的支持 rootContainerElement, null ); } // 捕获阶段监听 listenToNativeEvent(domEventName, true, rootContainerElement, null); }); return root; } // 创建 fiberRoot 和 rootFiberNode，并将两者关联起来 export function createFiberRoot( containerInfo: any, tag: RootTag, hydrate: boolean ): FiberRoot { const root: FiberRoot = { tag, containerInfo, // DOMContainer pendingChildren: null, current: null, pingCache: null, finishedWork: null, timeoutHandle: noTimeout, // -1 context: null, pendingContext: null, hydrate, callbackNode: null, callbackPriority: NoLanePriority, // 0 eventTimes: createLaneMap(NoLanes), // [] expirationTimes: createLaneMap(NoTimestamp), pendingLanes: NoLanes, suspendedLanes: NoLanes, pingedLanes: NoLanes, expiredLanes: NoLanes, mutableReadLanes: NoLanes, finishedLanes: NoLanes, entangledLanes: NoLanes, entanglements: createLaneMap(NoLanes) }; // VDOM -> Fiber -> DOM const uninitializedFiber: FiberNode = { tag: 3, key: null, elementType: null, type: null, stateNode: null, return: null, child: null, sibling: null, index: 0, ref: null, // 节点状态相关 start，作用在 fiber 构造阶段，影响子节点生成 pendingProps: null, memoizedProps: null, updateQueue: null, memoizedState: null, // 节点相关状态 end dependencies: null, mode: NoMode | ConcurrentMode | BlockingMode | StrictMode, // 节点副作用相关 start nextEffect: null, // 用于 EffectList，指向下一个有副作用的 fiber firstEffect: null, // 指向 EffectList 中的第一个 fiber lastEffect: null, // 指向 EffectList 中的最后一个 fiber flags: NoFlags, // 节点副作用相关 end lanes: NoLanes, // 当前 fiber 优先级 childLanes: NoLanes, // 子 fiber 优先级 alternate: null }; // fiberRoot 的 current 指向 rootFiberNode root.current = uninitializedFiber; // rootFiberNode 的 stateNode 指向 fiberRoot uninitializedFiber.stateNode = root; // rootFiberNode 的更新队列（链表） uninitializedFiber.updateQueue = { baseState: uninitializedFiber.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null }, effects: null }; return root; } // 创建更新，安排渲染 export function updateContainer( element: ReactNodeList, container: OpaqueRoot, parentComponent: ?React$Component<any, any>, callback: ?Function ): Lane { const current = container.current; // rootFiberNode const eventTime = requestEventTime(); // 当前时间 const lane = requestUpdateLane(current); // 优先级 const context = getContextForSubtree(parentComponent); // emptyContextObject = {} if (container.context === null) { container.context = context; // 走这儿 } else { container.pendingContext = context; } // 创建了一个 update 对象 const update = { callback: null, eventTime, lane, next: null, payload: { element }, tag: UpdateState // 0 }; callback = callback === undefined ? null : callback; if (callback !== null) { update.callback = callback; } /** * enqueueUpdate 做了一下事情：将 fiber 节点和 update 关联起来 * const updateQueue = fiber.updateQueue; * const sharedQueue = fiber.updateQueue.shared; * const pending = sharedQueue.pending; * update.next = update; // 每个 fiberNode 的所有 update 组成了一个链表，只不过现在链表里只有一个元素 * sharedQueue.pending = update; */ enqueueUpdate(current, update); // 执行渲染工作 scheduleUpdateOnFiber(current, lane, eventTime); return lane; } /** * 从 17 开始，e.persist() 将不再生效，因为 SyntheticEvent 不再放入事件池中 * React 将不再向 document 附加事件处理器 * 而会将事件处理器附加到渲染 React 树的根 DOM 容器中 * 原因：如果页面上有多个 React 版本，会破坏 e.stopPropagation() */ export function listenToNativeEvent( domEventName: DOMEventName, isCapturePhaseListener: boolean, rootContainerElement: EventTarget, targetElement: Element | null, eventSystemFlags?: EventSystemFlags = 0 ): void { let target = rootContainerElement; if ( domEventName === 'selectionchange' &amp;&amp; rootContainerElement.nodeType !== DOCUMENT_NODE ) { /** * selectionchange 事件需要直接绑定在 document 上 * ownerDocument 返回节点的顶层的 document 对象 */ target = rootContainerElement.ownerDocument; } /** * 如果事件可以被委托（或者在捕获阶段触发） * 那就注册在 rootContainerElement 上 * 否则，就绑定在 targetElement 上 */ if ( targetElement !== null &amp;&amp; !isCapturePhaseListener &amp;&amp; nonDelegatedEvents.has(domEventName) ) { /** * 所有不能代理的事件（多媒体事件、cancel、close、invalid、load、scroll、toggle） * 都绑定在 targetElement 上 */ if (domEventName !== 'scroll') { // 除了 scroll 事件，因为任何元素都可以滚动 return; } eventSystemFlags |= IS_NON_DELEGATED; target = targetElement; } // target['__reactEvents$' + Math.random().toString(36).slice(2)] = new Set() const listenerSet = getEventListenerSet(target); // `${domEventName}__${isCapturePhaseListener ? 'capture' : 'bubble'}` const listenerSetKey = getListenerSetKey( domEventName, isCapturePhaseListener ); if (!listenerSet.has(listenerSetKey)) { if (isCapturePhaseListener) { eventSystemFlags |= IS_CAPTURE_PHASE; } addTrappedEventListener( target, domEventName, eventSystemFlags, isCapturePhaseListener ); listenerSet.add(listenerSetKey); } } 调用 scheduleUpdateOnFiber 发生了什么？ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 export function scheduleUpdateOnFiber( fiber: Fiber, lane: Lane, eventTime: number ) { // 检查是否有嵌套更新，如果嵌套超过 50 层，终止调度 checkForNestedUpdates(); // 标记从 fiberNode 到 fiberRoot 的更新时间 const root = markUpdateLaneFromFiberToRoot(fiber, lane); if (root === null) { return null; } // 标记 fiberRoot 有挂起的更新 markRootUpdated(root, lane, eventTime); if (root === workInProgressRoot) { /** * 接收到在渲染过程中的树的更新，标记 fiberRoot 上存在交叉更新工作 * 除非 deferRenderPhaseUpdateToNextBatch 标志关闭并且这是 render 阶段更新 * 在这种情况下，出于向后兼容的原因，我们不会将 render 阶段更新视为交错处理 */ workInProgressRootUpdatedLanes = workInProgressRootUpdatedLanes | lane; } /** * 获取 currentPriorityLevel 的值和 Scheduler_*Priority 做对比；获取当前优先级 * ImmediatePriority || * UserBlockingPriority|| * NormalPriority || * LowPriority || * IdlePriority */ const priorityLevel = getCurrentPriorityLevel(); if (lane === SyncLane) { // 初次渲染是同步的 if ( // 检查是否在 unbatchedUpdates 内部 (executionContext &amp; LegacyUnbatchedContext) !== NoContext &amp;&amp; // 检查是否还没有渲染 (executionContext &amp; (RenderContext | CommitContext)) === NoContext ) { // 在 fiberRoot 上注册挂起的交互，以避免丢失跟踪的交互数据 schedulePendingInteractions(root, lane); /** * 一种边缘情况：在 batchedUpdates 内部 * ReactDOM.render 渲染的 root 节点挂载应该是同步的 * 而布局更新应该推迟到批处理结束 */ performSyncWorkOnRoot(root); } else { ensureRootIsScheduled(root, eventTime); schedulePendingInteractions(root, lane); if (executionContext === NoContext) { /** * 现在就开始同步工作，除非我们已经开始或在批处理中 * 这有意在 scheduleUpdateOnFiber 中（而不是 scheduleCallbackForFiber 中） * 以保留 schedule 回调而不立即执行它的能力 * 我们只对用户发起的更新执行此操作，以保留遗留模式的历史行为 */ resetRenderTimer(); flushSyncCallbackQueue(); } } } else { // 计划离散更新，但仅在它不是同步的情况下 if ( (executionContext &amp; DiscreteEventContext) !== NoContext &amp;&amp; // 只有用户阻塞或更高优先级的更新才被视为离散的 (priorityLevel === UserBlockingSchedulerPriority || priorityLevel === ImmediateSchedulerPriority) ) { // 跟踪每个 root 的最低优先级的离散更新，以便在必要时及早运行他们 if (rootsWithPendingDiscreteUpdates === null) { rootsWithPendingDiscreteUpdates = new Set([root]); } else { rootsWithPendingDiscreteUpdates.add(root); } } // 如果回调是同步的，则在之后安排其他更新 ensureRootIsScheduled(root, eventTime); schedulePendingInteractions(root, lane); } /** * 我们假设它和被更新的 root 相同，因为单个 root 的应用很常见 * 如果不是同一个 root，那也不是啥难事 * 我们只是倾向于把更多的东西 batch 在一起 */ mostRecentlyUpdatedRoot = root; } scheduler（任务调度，高优先级的任务先进行 render） 对任务按照优先级进行调度（高优先级的任务打断低优先级的任务的执行），所有任务保存在最小堆中（方便取出优先级最高的任务）。
"><title>React 复习笔记（下） · I AM BEA, I DRINK TEA</title>
<link rel="canonical" href="https://ElementRef.github.io/p/react-%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%8B/"><link rel="stylesheet" href="/scss/style.min.49a542c0449d2ab7de17e0bb72f035d22a011f1361d304a0ff6dc68951166f07.css"><meta property="og:title" content="React 复习笔记（下）"><meta property="og:description" content="调用 ReactDOM.render 发生了什么？ 确定应用渲染方式； 创建 fiberRoot 和 rootFiberNode，并将两者用指针指向彼此； 向 rootFiberNode 绑定自身的更新队列； 清空 container 里的内容； 向 container 绑定原生事件； 将 render 的第三个参数的 this 指向应用实例并调用； 初始化完成后，创建 update，并将 fiber 对应的组件作为 payload； 将 update 与 fiberNode 相关联，fiberNode 对应的 update 组成循环链表； 调用 scheduleUpdateOnFiber 开始渲染工作。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 // ReactDOM 的渲染模式 export type RootTag = 0 | 1 | 2; export const LegacyRoot = 0; // ReactDOM.createLegacyRoot export const BlockingRoot = 1; // ReactDOM.createBlockingRoot export const ConcurrentRoot = 2; // ReactDOM.createRoot // ReactDOM.render export function render( element: React$Element<any>, container: Container, callback: ?Function ) { // 向 DOMContainer 里渲染子树 return legacyRenderSubtreeIntoContainer( null, element, container, false, callback ); } function legacyRenderSubtreeIntoContainer( parentComponent: ?React$Component<any, any>, // null children: ReactNodeList, // ReactElement container: Container, // DOMContainer forceHydrate: boolean, // false callback: ?Function // () => {} ) { let root: RootType = container._reactRootContainer; let fiberRoot; if (!root) { /** * 初始化阶段准备工作： * 0. legacyCreateRootFromDOMContainer 最终会调用 createRootImpl * 1. container._reactRootContainer._internalRoot = createRootImpl(container, 0, undefined) * 2. createRootImpl(container, 0, undefined) 返回了 fiberRoot * 3. fiberRoot 一个应用只有一个，其 current 属性指向了 rootFiberNode * 4. fiberRoot.current 指向了 currentFiber 树 * 5. fiberRoot.finishedWork 指向了 workInProgress 树 * 6. 清空 container */ root = container._reactRootContainer = legacyCreateRootFromDOMContainer( container, forceHydrate ); fiberRoot = root._internalRoot; if (typeof callback === 'function') { const originalCallback = callback; callback = function () { /** * getPublicRootInstance 会通过 fiberRoot 访问 rootFiberNode * 如果 rootFiberNode 没有子节点，返回 null * 否则返回 rootFiberNode 子节点的 stateNode * 总之就是返回一个非 rootFiberNode 的组件实例 */ const instance = getPublicRootInstance(fiberRoot); // 调用了 callback 就说明应用初始化完成了 originalCallback.call(instance); }; } // 初始化完成之后，就准备进行应用渲染了 unbatchedUpdates(() => { updateContainer(children, fiberRoot, parentComponent, callback); }); } else { // 后续更新需要重新渲染，会走这里 fiberRoot = root._internalRoot; if (typeof callback === 'function') { const originalCallback = callback; callback = function () { const instance = getPublicRootInstance(fiberRoot); originalCallback.call(instance); }; } updateContainer(children, fiberRoot, parentComponent, callback); } return getPublicRootInstance(fiberRoot); } function createRootImpl( container: Container, tag: RootTag, // 用来表示是否开启“并发模式” options: void | RootOptions ) { const root = createFiberRoot( container, tag, (hydrate = false), (hydrationCallbacks = null) ); container.__reactContainer$ = root.current; /** * 获取应用挂载的 DOM 的 nodeType： * Node.ELEMENT_NODE 1 元素节点 * Node.TEXT_NODE 3 文字节点 * Node.CDATA_SECTION_NODE 4 <!CDATA[[ … ]]> * Node.PROCESSING_INSTRUCTION_NODE 7 <?xml-stylesheet ... ?> * Node.COMMENT_NODE 8 注释节点 * Node.DOCUMENT_NODE 9 Document * Node.DOCUMENT_TYPE_NODE 10 <!DOCTYPE html> * Node.DOCUMENT_FRAGMENT_NODE 11 DocumentFragment */ const rootContainerElement = container.nodeType === COMMENT_NODE ? container.parentNode : container; rootContainerElement._reactListening = true; /** * allNativeEvents 是包含了离散（触发）事件、阻塞（用户交互）事件、连续（不能被打断）事件、表单事件的 Set * nonDelegatedEvents 是放置的是“非委托”事件的 Set&nbsp;(类似于一个白名单) * listenToNativeEvent(事件名称，是否在捕获阶段触发，应用根容器，目标元素) * 1. 将 selectionchange 绑定到 document * 2. 将支持“冒泡”的事件委托到 rootContainerElement * 3. 其他的事件除了 scroll、load... 外，绑定到“目标元素” * 4. 从 EventTarget.__reactEvents 找到所有绑定的 listener（保存在 Set 里） * 5. listener 里如果没有 `${domEventName}__${capture ? 'capture' : 'bubble'}` 会执行 addTrappedEventListener * addTrappedEventListener(EventTarget, DOMEventName, EventSystemFlags, isCapture, isDeferred) * 1. createEventListenerWrapperWithPriority 会根据事件类型，使用不同的优先级函数包裹 listener（事件优先级），将 DOM 事件转发到 React 内部 * a. dispatchDiscreteEvent 离散事件，最高优先级 * b. dispatchUserBlockingUpdate 用户阻塞事件 * c. dispatchEvent 连续事件 * 2. 对于“touchstart”、“touchmove”、“wheel”三个事件，isPassive=true（preventDefault 失效） * 3. 根据 isCapture 和 isPassive 将事件绑定分发给了四个函数 addEvent[Bubble/Capture]Listener[WithPassiveFlag] * 4. 调用原生 API：addEventListener 和 removeEventListener 进行事件的绑定和移除 * 总的来说，React 会根据事件 isCapture、isPassive 和优先级，将事件绑定到合适的 target 上 */ allNativeEvents.forEach(domEventName => { if (!nonDelegatedEvents.has(domEventName)) { // 可以使用“事件委托” listenToNativeEvent( domEventName, false, // “事件委托”需要“事件冒泡”的支持 rootContainerElement, null ); } // 捕获阶段监听 listenToNativeEvent(domEventName, true, rootContainerElement, null); }); return root; } // 创建 fiberRoot 和 rootFiberNode，并将两者关联起来 export function createFiberRoot( containerInfo: any, tag: RootTag, hydrate: boolean ): FiberRoot { const root: FiberRoot = { tag, containerInfo, // DOMContainer pendingChildren: null, current: null, pingCache: null, finishedWork: null, timeoutHandle: noTimeout, // -1 context: null, pendingContext: null, hydrate, callbackNode: null, callbackPriority: NoLanePriority, // 0 eventTimes: createLaneMap(NoLanes), // [] expirationTimes: createLaneMap(NoTimestamp), pendingLanes: NoLanes, suspendedLanes: NoLanes, pingedLanes: NoLanes, expiredLanes: NoLanes, mutableReadLanes: NoLanes, finishedLanes: NoLanes, entangledLanes: NoLanes, entanglements: createLaneMap(NoLanes) }; // VDOM -> Fiber -> DOM const uninitializedFiber: FiberNode = { tag: 3, key: null, elementType: null, type: null, stateNode: null, return: null, child: null, sibling: null, index: 0, ref: null, // 节点状态相关 start，作用在 fiber 构造阶段，影响子节点生成 pendingProps: null, memoizedProps: null, updateQueue: null, memoizedState: null, // 节点相关状态 end dependencies: null, mode: NoMode | ConcurrentMode | BlockingMode | StrictMode, // 节点副作用相关 start nextEffect: null, // 用于 EffectList，指向下一个有副作用的 fiber firstEffect: null, // 指向 EffectList 中的第一个 fiber lastEffect: null, // 指向 EffectList 中的最后一个 fiber flags: NoFlags, // 节点副作用相关 end lanes: NoLanes, // 当前 fiber 优先级 childLanes: NoLanes, // 子 fiber 优先级 alternate: null }; // fiberRoot 的 current 指向 rootFiberNode root.current = uninitializedFiber; // rootFiberNode 的 stateNode 指向 fiberRoot uninitializedFiber.stateNode = root; // rootFiberNode 的更新队列（链表） uninitializedFiber.updateQueue = { baseState: uninitializedFiber.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null }, effects: null }; return root; } // 创建更新，安排渲染 export function updateContainer( element: ReactNodeList, container: OpaqueRoot, parentComponent: ?React$Component<any, any>, callback: ?Function ): Lane { const current = container.current; // rootFiberNode const eventTime = requestEventTime(); // 当前时间 const lane = requestUpdateLane(current); // 优先级 const context = getContextForSubtree(parentComponent); // emptyContextObject = {} if (container.context === null) { container.context = context; // 走这儿 } else { container.pendingContext = context; } // 创建了一个 update 对象 const update = { callback: null, eventTime, lane, next: null, payload: { element }, tag: UpdateState // 0 }; callback = callback === undefined ? null : callback; if (callback !== null) { update.callback = callback; } /** * enqueueUpdate 做了一下事情：将 fiber 节点和 update 关联起来 * const updateQueue = fiber.updateQueue; * const sharedQueue = fiber.updateQueue.shared; * const pending = sharedQueue.pending; * update.next = update; // 每个 fiberNode 的所有 update 组成了一个链表，只不过现在链表里只有一个元素 * sharedQueue.pending = update; */ enqueueUpdate(current, update); // 执行渲染工作 scheduleUpdateOnFiber(current, lane, eventTime); return lane; } /** * 从 17 开始，e.persist() 将不再生效，因为 SyntheticEvent 不再放入事件池中 * React 将不再向 document 附加事件处理器 * 而会将事件处理器附加到渲染 React 树的根 DOM 容器中 * 原因：如果页面上有多个 React 版本，会破坏 e.stopPropagation() */ export function listenToNativeEvent( domEventName: DOMEventName, isCapturePhaseListener: boolean, rootContainerElement: EventTarget, targetElement: Element | null, eventSystemFlags?: EventSystemFlags = 0 ): void { let target = rootContainerElement; if ( domEventName === 'selectionchange' &amp;&amp; rootContainerElement.nodeType !== DOCUMENT_NODE ) { /** * selectionchange 事件需要直接绑定在 document 上 * ownerDocument 返回节点的顶层的 document 对象 */ target = rootContainerElement.ownerDocument; } /** * 如果事件可以被委托（或者在捕获阶段触发） * 那就注册在 rootContainerElement 上 * 否则，就绑定在 targetElement 上 */ if ( targetElement !== null &amp;&amp; !isCapturePhaseListener &amp;&amp; nonDelegatedEvents.has(domEventName) ) { /** * 所有不能代理的事件（多媒体事件、cancel、close、invalid、load、scroll、toggle） * 都绑定在 targetElement 上 */ if (domEventName !== 'scroll') { // 除了 scroll 事件，因为任何元素都可以滚动 return; } eventSystemFlags |= IS_NON_DELEGATED; target = targetElement; } // target['__reactEvents$' + Math.random().toString(36).slice(2)] = new Set() const listenerSet = getEventListenerSet(target); // `${domEventName}__${isCapturePhaseListener ? 'capture' : 'bubble'}` const listenerSetKey = getListenerSetKey( domEventName, isCapturePhaseListener ); if (!listenerSet.has(listenerSetKey)) { if (isCapturePhaseListener) { eventSystemFlags |= IS_CAPTURE_PHASE; } addTrappedEventListener( target, domEventName, eventSystemFlags, isCapturePhaseListener ); listenerSet.add(listenerSetKey); } } 调用 scheduleUpdateOnFiber 发生了什么？ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 export function scheduleUpdateOnFiber( fiber: Fiber, lane: Lane, eventTime: number ) { // 检查是否有嵌套更新，如果嵌套超过 50 层，终止调度 checkForNestedUpdates(); // 标记从 fiberNode 到 fiberRoot 的更新时间 const root = markUpdateLaneFromFiberToRoot(fiber, lane); if (root === null) { return null; } // 标记 fiberRoot 有挂起的更新 markRootUpdated(root, lane, eventTime); if (root === workInProgressRoot) { /** * 接收到在渲染过程中的树的更新，标记 fiberRoot 上存在交叉更新工作 * 除非 deferRenderPhaseUpdateToNextBatch 标志关闭并且这是 render 阶段更新 * 在这种情况下，出于向后兼容的原因，我们不会将 render 阶段更新视为交错处理 */ workInProgressRootUpdatedLanes = workInProgressRootUpdatedLanes | lane; } /** * 获取 currentPriorityLevel 的值和 Scheduler_*Priority 做对比；获取当前优先级 * ImmediatePriority || * UserBlockingPriority|| * NormalPriority || * LowPriority || * IdlePriority */ const priorityLevel = getCurrentPriorityLevel(); if (lane === SyncLane) { // 初次渲染是同步的 if ( // 检查是否在 unbatchedUpdates 内部 (executionContext &amp; LegacyUnbatchedContext) !== NoContext &amp;&amp; // 检查是否还没有渲染 (executionContext &amp; (RenderContext | CommitContext)) === NoContext ) { // 在 fiberRoot 上注册挂起的交互，以避免丢失跟踪的交互数据 schedulePendingInteractions(root, lane); /** * 一种边缘情况：在 batchedUpdates 内部 * ReactDOM.render 渲染的 root 节点挂载应该是同步的 * 而布局更新应该推迟到批处理结束 */ performSyncWorkOnRoot(root); } else { ensureRootIsScheduled(root, eventTime); schedulePendingInteractions(root, lane); if (executionContext === NoContext) { /** * 现在就开始同步工作，除非我们已经开始或在批处理中 * 这有意在 scheduleUpdateOnFiber 中（而不是 scheduleCallbackForFiber 中） * 以保留 schedule 回调而不立即执行它的能力 * 我们只对用户发起的更新执行此操作，以保留遗留模式的历史行为 */ resetRenderTimer(); flushSyncCallbackQueue(); } } } else { // 计划离散更新，但仅在它不是同步的情况下 if ( (executionContext &amp; DiscreteEventContext) !== NoContext &amp;&amp; // 只有用户阻塞或更高优先级的更新才被视为离散的 (priorityLevel === UserBlockingSchedulerPriority || priorityLevel === ImmediateSchedulerPriority) ) { // 跟踪每个 root 的最低优先级的离散更新，以便在必要时及早运行他们 if (rootsWithPendingDiscreteUpdates === null) { rootsWithPendingDiscreteUpdates = new Set([root]); } else { rootsWithPendingDiscreteUpdates.add(root); } } // 如果回调是同步的，则在之后安排其他更新 ensureRootIsScheduled(root, eventTime); schedulePendingInteractions(root, lane); } /** * 我们假设它和被更新的 root 相同，因为单个 root 的应用很常见 * 如果不是同一个 root，那也不是啥难事 * 我们只是倾向于把更多的东西 batch 在一起 */ mostRecentlyUpdatedRoot = root; } scheduler（任务调度，高优先级的任务先进行 render） 对任务按照优先级进行调度（高优先级的任务打断低优先级的任务的执行），所有任务保存在最小堆中（方便取出优先级最高的任务）。
"><meta property="og:url" content="https://ElementRef.github.io/p/react-%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%8B/"><meta property="og:site_name" content="馬腊咯稽"><meta property="og:type" content="article"><meta property="article:section" content="Post"><meta property="article:published_time" content="2021-10-10T00:00:00+00:00"><meta property="article:modified_time" content="2021-10-10T00:00:00+00:00"><meta property="og:image" content="https://ElementRef.github.io/img/cover/react.png"><meta property="og:logo" content="/og-logo.png"><meta name="twitter:title" content="React 复习笔记（下）"><meta name="twitter:description" content="调用 ReactDOM.render 发生了什么？ 确定应用渲染方式； 创建 fiberRoot 和 rootFiberNode，并将两者用指针指向彼此； 向 rootFiberNode 绑定自身的更新队列； 清空 container 里的内容； 向 container 绑定原生事件； 将 render 的第三个参数的 this 指向应用实例并调用； 初始化完成后，创建 update，并将 fiber 对应的组件作为 payload； 将 update 与 fiberNode 相关联，fiberNode 对应的 update 组成循环链表； 调用 scheduleUpdateOnFiber 开始渲染工作。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 // ReactDOM 的渲染模式 export type RootTag = 0 | 1 | 2; export const LegacyRoot = 0; // ReactDOM.createLegacyRoot export const BlockingRoot = 1; // ReactDOM.createBlockingRoot export const ConcurrentRoot = 2; // ReactDOM.createRoot // ReactDOM.render export function render( element: React$Element<any>, container: Container, callback: ?Function ) { // 向 DOMContainer 里渲染子树 return legacyRenderSubtreeIntoContainer( null, element, container, false, callback ); } function legacyRenderSubtreeIntoContainer( parentComponent: ?React$Component<any, any>, // null children: ReactNodeList, // ReactElement container: Container, // DOMContainer forceHydrate: boolean, // false callback: ?Function // () => {} ) { let root: RootType = container._reactRootContainer; let fiberRoot; if (!root) { /** * 初始化阶段准备工作： * 0. legacyCreateRootFromDOMContainer 最终会调用 createRootImpl * 1. container._reactRootContainer._internalRoot = createRootImpl(container, 0, undefined) * 2. createRootImpl(container, 0, undefined) 返回了 fiberRoot * 3. fiberRoot 一个应用只有一个，其 current 属性指向了 rootFiberNode * 4. fiberRoot.current 指向了 currentFiber 树 * 5. fiberRoot.finishedWork 指向了 workInProgress 树 * 6. 清空 container */ root = container._reactRootContainer = legacyCreateRootFromDOMContainer( container, forceHydrate ); fiberRoot = root._internalRoot; if (typeof callback === 'function') { const originalCallback = callback; callback = function () { /** * getPublicRootInstance 会通过 fiberRoot 访问 rootFiberNode * 如果 rootFiberNode 没有子节点，返回 null * 否则返回 rootFiberNode 子节点的 stateNode * 总之就是返回一个非 rootFiberNode 的组件实例 */ const instance = getPublicRootInstance(fiberRoot); // 调用了 callback 就说明应用初始化完成了 originalCallback.call(instance); }; } // 初始化完成之后，就准备进行应用渲染了 unbatchedUpdates(() => { updateContainer(children, fiberRoot, parentComponent, callback); }); } else { // 后续更新需要重新渲染，会走这里 fiberRoot = root._internalRoot; if (typeof callback === 'function') { const originalCallback = callback; callback = function () { const instance = getPublicRootInstance(fiberRoot); originalCallback.call(instance); }; } updateContainer(children, fiberRoot, parentComponent, callback); } return getPublicRootInstance(fiberRoot); } function createRootImpl( container: Container, tag: RootTag, // 用来表示是否开启“并发模式” options: void | RootOptions ) { const root = createFiberRoot( container, tag, (hydrate = false), (hydrationCallbacks = null) ); container.__reactContainer$ = root.current; /** * 获取应用挂载的 DOM 的 nodeType： * Node.ELEMENT_NODE 1 元素节点 * Node.TEXT_NODE 3 文字节点 * Node.CDATA_SECTION_NODE 4 <!CDATA[[ … ]]> * Node.PROCESSING_INSTRUCTION_NODE 7 <?xml-stylesheet ... ?> * Node.COMMENT_NODE 8 注释节点 * Node.DOCUMENT_NODE 9 Document * Node.DOCUMENT_TYPE_NODE 10 <!DOCTYPE html> * Node.DOCUMENT_FRAGMENT_NODE 11 DocumentFragment */ const rootContainerElement = container.nodeType === COMMENT_NODE ? container.parentNode : container; rootContainerElement._reactListening = true; /** * allNativeEvents 是包含了离散（触发）事件、阻塞（用户交互）事件、连续（不能被打断）事件、表单事件的 Set * nonDelegatedEvents 是放置的是“非委托”事件的 Set&nbsp;(类似于一个白名单) * listenToNativeEvent(事件名称，是否在捕获阶段触发，应用根容器，目标元素) * 1. 将 selectionchange 绑定到 document * 2. 将支持“冒泡”的事件委托到 rootContainerElement * 3. 其他的事件除了 scroll、load... 外，绑定到“目标元素” * 4. 从 EventTarget.__reactEvents 找到所有绑定的 listener（保存在 Set 里） * 5. listener 里如果没有 `${domEventName}__${capture ? 'capture' : 'bubble'}` 会执行 addTrappedEventListener * addTrappedEventListener(EventTarget, DOMEventName, EventSystemFlags, isCapture, isDeferred) * 1. createEventListenerWrapperWithPriority 会根据事件类型，使用不同的优先级函数包裹 listener（事件优先级），将 DOM 事件转发到 React 内部 * a. dispatchDiscreteEvent 离散事件，最高优先级 * b. dispatchUserBlockingUpdate 用户阻塞事件 * c. dispatchEvent 连续事件 * 2. 对于“touchstart”、“touchmove”、“wheel”三个事件，isPassive=true（preventDefault 失效） * 3. 根据 isCapture 和 isPassive 将事件绑定分发给了四个函数 addEvent[Bubble/Capture]Listener[WithPassiveFlag] * 4. 调用原生 API：addEventListener 和 removeEventListener 进行事件的绑定和移除 * 总的来说，React 会根据事件 isCapture、isPassive 和优先级，将事件绑定到合适的 target 上 */ allNativeEvents.forEach(domEventName => { if (!nonDelegatedEvents.has(domEventName)) { // 可以使用“事件委托” listenToNativeEvent( domEventName, false, // “事件委托”需要“事件冒泡”的支持 rootContainerElement, null ); } // 捕获阶段监听 listenToNativeEvent(domEventName, true, rootContainerElement, null); }); return root; } // 创建 fiberRoot 和 rootFiberNode，并将两者关联起来 export function createFiberRoot( containerInfo: any, tag: RootTag, hydrate: boolean ): FiberRoot { const root: FiberRoot = { tag, containerInfo, // DOMContainer pendingChildren: null, current: null, pingCache: null, finishedWork: null, timeoutHandle: noTimeout, // -1 context: null, pendingContext: null, hydrate, callbackNode: null, callbackPriority: NoLanePriority, // 0 eventTimes: createLaneMap(NoLanes), // [] expirationTimes: createLaneMap(NoTimestamp), pendingLanes: NoLanes, suspendedLanes: NoLanes, pingedLanes: NoLanes, expiredLanes: NoLanes, mutableReadLanes: NoLanes, finishedLanes: NoLanes, entangledLanes: NoLanes, entanglements: createLaneMap(NoLanes) }; // VDOM -> Fiber -> DOM const uninitializedFiber: FiberNode = { tag: 3, key: null, elementType: null, type: null, stateNode: null, return: null, child: null, sibling: null, index: 0, ref: null, // 节点状态相关 start，作用在 fiber 构造阶段，影响子节点生成 pendingProps: null, memoizedProps: null, updateQueue: null, memoizedState: null, // 节点相关状态 end dependencies: null, mode: NoMode | ConcurrentMode | BlockingMode | StrictMode, // 节点副作用相关 start nextEffect: null, // 用于 EffectList，指向下一个有副作用的 fiber firstEffect: null, // 指向 EffectList 中的第一个 fiber lastEffect: null, // 指向 EffectList 中的最后一个 fiber flags: NoFlags, // 节点副作用相关 end lanes: NoLanes, // 当前 fiber 优先级 childLanes: NoLanes, // 子 fiber 优先级 alternate: null }; // fiberRoot 的 current 指向 rootFiberNode root.current = uninitializedFiber; // rootFiberNode 的 stateNode 指向 fiberRoot uninitializedFiber.stateNode = root; // rootFiberNode 的更新队列（链表） uninitializedFiber.updateQueue = { baseState: uninitializedFiber.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null }, effects: null }; return root; } // 创建更新，安排渲染 export function updateContainer( element: ReactNodeList, container: OpaqueRoot, parentComponent: ?React$Component<any, any>, callback: ?Function ): Lane { const current = container.current; // rootFiberNode const eventTime = requestEventTime(); // 当前时间 const lane = requestUpdateLane(current); // 优先级 const context = getContextForSubtree(parentComponent); // emptyContextObject = {} if (container.context === null) { container.context = context; // 走这儿 } else { container.pendingContext = context; } // 创建了一个 update 对象 const update = { callback: null, eventTime, lane, next: null, payload: { element }, tag: UpdateState // 0 }; callback = callback === undefined ? null : callback; if (callback !== null) { update.callback = callback; } /** * enqueueUpdate 做了一下事情：将 fiber 节点和 update 关联起来 * const updateQueue = fiber.updateQueue; * const sharedQueue = fiber.updateQueue.shared; * const pending = sharedQueue.pending; * update.next = update; // 每个 fiberNode 的所有 update 组成了一个链表，只不过现在链表里只有一个元素 * sharedQueue.pending = update; */ enqueueUpdate(current, update); // 执行渲染工作 scheduleUpdateOnFiber(current, lane, eventTime); return lane; } /** * 从 17 开始，e.persist() 将不再生效，因为 SyntheticEvent 不再放入事件池中 * React 将不再向 document 附加事件处理器 * 而会将事件处理器附加到渲染 React 树的根 DOM 容器中 * 原因：如果页面上有多个 React 版本，会破坏 e.stopPropagation() */ export function listenToNativeEvent( domEventName: DOMEventName, isCapturePhaseListener: boolean, rootContainerElement: EventTarget, targetElement: Element | null, eventSystemFlags?: EventSystemFlags = 0 ): void { let target = rootContainerElement; if ( domEventName === 'selectionchange' &amp;&amp; rootContainerElement.nodeType !== DOCUMENT_NODE ) { /** * selectionchange 事件需要直接绑定在 document 上 * ownerDocument 返回节点的顶层的 document 对象 */ target = rootContainerElement.ownerDocument; } /** * 如果事件可以被委托（或者在捕获阶段触发） * 那就注册在 rootContainerElement 上 * 否则，就绑定在 targetElement 上 */ if ( targetElement !== null &amp;&amp; !isCapturePhaseListener &amp;&amp; nonDelegatedEvents.has(domEventName) ) { /** * 所有不能代理的事件（多媒体事件、cancel、close、invalid、load、scroll、toggle） * 都绑定在 targetElement 上 */ if (domEventName !== 'scroll') { // 除了 scroll 事件，因为任何元素都可以滚动 return; } eventSystemFlags |= IS_NON_DELEGATED; target = targetElement; } // target['__reactEvents$' + Math.random().toString(36).slice(2)] = new Set() const listenerSet = getEventListenerSet(target); // `${domEventName}__${isCapturePhaseListener ? 'capture' : 'bubble'}` const listenerSetKey = getListenerSetKey( domEventName, isCapturePhaseListener ); if (!listenerSet.has(listenerSetKey)) { if (isCapturePhaseListener) { eventSystemFlags |= IS_CAPTURE_PHASE; } addTrappedEventListener( target, domEventName, eventSystemFlags, isCapturePhaseListener ); listenerSet.add(listenerSetKey); } } 调用 scheduleUpdateOnFiber 发生了什么？ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 export function scheduleUpdateOnFiber( fiber: Fiber, lane: Lane, eventTime: number ) { // 检查是否有嵌套更新，如果嵌套超过 50 层，终止调度 checkForNestedUpdates(); // 标记从 fiberNode 到 fiberRoot 的更新时间 const root = markUpdateLaneFromFiberToRoot(fiber, lane); if (root === null) { return null; } // 标记 fiberRoot 有挂起的更新 markRootUpdated(root, lane, eventTime); if (root === workInProgressRoot) { /** * 接收到在渲染过程中的树的更新，标记 fiberRoot 上存在交叉更新工作 * 除非 deferRenderPhaseUpdateToNextBatch 标志关闭并且这是 render 阶段更新 * 在这种情况下，出于向后兼容的原因，我们不会将 render 阶段更新视为交错处理 */ workInProgressRootUpdatedLanes = workInProgressRootUpdatedLanes | lane; } /** * 获取 currentPriorityLevel 的值和 Scheduler_*Priority 做对比；获取当前优先级 * ImmediatePriority || * UserBlockingPriority|| * NormalPriority || * LowPriority || * IdlePriority */ const priorityLevel = getCurrentPriorityLevel(); if (lane === SyncLane) { // 初次渲染是同步的 if ( // 检查是否在 unbatchedUpdates 内部 (executionContext &amp; LegacyUnbatchedContext) !== NoContext &amp;&amp; // 检查是否还没有渲染 (executionContext &amp; (RenderContext | CommitContext)) === NoContext ) { // 在 fiberRoot 上注册挂起的交互，以避免丢失跟踪的交互数据 schedulePendingInteractions(root, lane); /** * 一种边缘情况：在 batchedUpdates 内部 * ReactDOM.render 渲染的 root 节点挂载应该是同步的 * 而布局更新应该推迟到批处理结束 */ performSyncWorkOnRoot(root); } else { ensureRootIsScheduled(root, eventTime); schedulePendingInteractions(root, lane); if (executionContext === NoContext) { /** * 现在就开始同步工作，除非我们已经开始或在批处理中 * 这有意在 scheduleUpdateOnFiber 中（而不是 scheduleCallbackForFiber 中） * 以保留 schedule 回调而不立即执行它的能力 * 我们只对用户发起的更新执行此操作，以保留遗留模式的历史行为 */ resetRenderTimer(); flushSyncCallbackQueue(); } } } else { // 计划离散更新，但仅在它不是同步的情况下 if ( (executionContext &amp; DiscreteEventContext) !== NoContext &amp;&amp; // 只有用户阻塞或更高优先级的更新才被视为离散的 (priorityLevel === UserBlockingSchedulerPriority || priorityLevel === ImmediateSchedulerPriority) ) { // 跟踪每个 root 的最低优先级的离散更新，以便在必要时及早运行他们 if (rootsWithPendingDiscreteUpdates === null) { rootsWithPendingDiscreteUpdates = new Set([root]); } else { rootsWithPendingDiscreteUpdates.add(root); } } // 如果回调是同步的，则在之后安排其他更新 ensureRootIsScheduled(root, eventTime); schedulePendingInteractions(root, lane); } /** * 我们假设它和被更新的 root 相同，因为单个 root 的应用很常见 * 如果不是同一个 root，那也不是啥难事 * 我们只是倾向于把更多的东西 batch 在一起 */ mostRecentlyUpdatedRoot = root; } scheduler（任务调度，高优先级的任务先进行 render） 对任务按照优先级进行调度（高优先级的任务打断低优先级的任务的执行），所有任务保存在最小堆中（方便取出优先级最高的任务）。
"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://ElementRef.github.io/img/cover/react.png"><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="manifest" href="/site.webmanifest"><meta name="robots" content="noarchive, noindex, nofollow"><meta name="theme-color" content="#ffffff"><script defer="" src="https://umami.pavilion0321907.workers.dev/elementref.js" data-website-id="87868be0-a9cf-4f8c-8fee-e3cbb99e6cf2"></script></head><body class="article-page"><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="flex container extended main-container on-phone--column"><aside class="sidebar sticky left-sidebar"><button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="切换菜单">
<span class="hamburger-box"><span class="hamburger-inner"></span></span></button><header><figure class="site-avatar"><a href="/"><img src="/img/avatar_hu15751654176150258532.webp" width="300" height="404" class="site-logo" alt="Avatar" fetchpriority="high" decoding="async"></a></figure><div class="site-meta"><h1 class="site-name"><a href="/">馬腊咯稽</a></h1><h2 class="site-description">I AM BEA, I DRINK TEA</h2></div></header><ol class="social-menu"><li><a href="https://douban.com/people/nicknoonan" target="_blank" title="DouBan"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-brand-douban"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M4 20h16"></path><path d="M5 4h14"></path><path d="M8 8h8a2 2 0 012 2v2a2 2 0 01-2 2H8a2 2 0 01-2-2v-2a2 2 0 012-2z"></path><path d="M16 14l-2 6"></path><path d="M8 17l1 3"></path></svg></a></li><li><a href="https://x.com/SpiciComic" target="_blank" title="Twitter"><svg class="icon icon-tabler icon-tabler-brand-twitter" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M22 4.01c-1 .49-1.98.689-3 .99-1.121-1.265-2.783-1.335-4.38-.737S11.977 6.323 12 8v1c-3.245.083-6.135-1.395-8-4 0 0-4.182 7.433 4 11-1.872 1.247-3.739 2.088-6 2 3.308 1.803 6.913 2.423 10.034 1.517 3.58-1.04 6.522-3.723 7.651-7.742a13.84 13.84.0 00.497-3.753C20.18 7.773 21.692 5.25 22 4.009z"></path></svg></a></li><li><a href="https://github.com/ElementRef" target="_blank" title="GitHub"><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"></path></svg></a></li><li><a href="https://m.weibo.cn/u/6447635754" target="_blank" title="Weibo"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-brand-weibo"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M19 14.127C19 17.2 15.498 20 11 20c-4.126.0-8-2.224-8-5.565.0-1.78.984-3.737 2.7-5.567 2.362-2.51 5.193-3.687 6.551-2.238.415.44.752 1.39.749 2.062 2-1.615 4.308.387 3.5 2.693 1.26.557 2.5.538 2.5 2.742z"></path><path d="M15 4h1a5 5 0 015 5v1"></path></svg></a></li><li><a href="https://last.fm/zh/user/SpiciComic/listening-report" target="_blank" title="Last.fm"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-brand-lastfm"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M20 8c-.83-1-1.388-1-2-1-.612.0-2 .271-2 2s1.384 2.233 3 3 2.125 1.812 2 3-1 2-3 2-3-1-3.5-2-1.585-4.78-2.497-6a5 5 0 10-1 7"></path></svg></a></li></ol><ol class="menu" id="main-menu"><li><a href="/"><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"></path><polyline points="5 12 3 12 12 3 21 12 19 12"></polyline><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"></path><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"></path></svg>
<span>首页</span></a></li><li><a href="/archives/"><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"></path><rect x="3" y="4" width="18" height="4" rx="2"></rect><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"></path><line x1="10" y1="12" x2="14" y2="12"></line></svg>
<span>归档</span></a></li><li><a href="/search/"><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"></path><circle cx="10" cy="10" r="7"></circle><line x1="21" y1="21" x2="15" y2="15"></line></svg>
<span>搜索</span></a></li><li><a href="/%E5%90%AF%E5%8F%91/"><svg class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"></path><path d="M10 14a3.5 3.5.0 005 0l4-4a3.5 3.5.0 00-5-5l-.5.5"></path><path d="M14 10a3.5 3.5.0 00-5 0l-4 4a3.5 3.5.0 005 5l.5-.5"></path></svg>
<span>启发</span></a></li><li><a href="/%E5%91%BD%E4%BB%A4/"><svg class="icon icon-tabler icon-tabler-terminal" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 7l5 5-5 5"></path><line x1="12" y1="19" x2="19" y2="19"></line></svg>
<span>命令</span></a></li><li><a href="/%E5%85%B3%E4%BA%8E/"><svg class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"></path><circle cx="12" cy="7" r="4"></circle><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"></path></svg>
<span>关于</span></a></li><div class="menu-bottom-section"><li id="dark-mode-toggle"><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"></path><circle cx="8" cy="12" r="2"></circle><rect x="2" y="6" width="20" height="12" rx="6"></rect></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"></path><circle cx="16" cy="12" r="2"></circle><rect x="2" y="6" width="20" height="12" rx="6"></rect></svg>
<span>深色</span></li></div></ol></aside><main class="full-width main"><article class="has-image main-article"><header class="article-header"><div class="article-image"><a href="/p/react-%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%8B/"><img src="/img/cover/react.webp" alt="React 复习笔记（下）" fetchpriority="high" decoding="async" width="1200" height="720" jampack-sized="true"></a></div><div class="article-details"><header class="article-category"><a href="/categories/react/">React</a></header><div class="article-title-wrapper"><h2 class="article-title"><a href="/p/react-%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%8B/">React 复习笔记（下）</a></h2></div><footer class="article-time"><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"></path><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"></path><circle cx="18" cy="18" r="4"></circle><path d="M15 3v4"></path><path d="M7 3v4"></path><path d="M3 11h16"></path><path d="M18 16.496V18l1 1"></path></svg>
<time class="article-time--published">Oct 10, 2021</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"></path><circle cx="12" cy="12" r="9"></circle><polyline points="12 7 12 12 15 15"></polyline></svg>
<time class="article-time--reading">阅读时长：46 分钟</time></div></footer></div></header><section class="article-content"><h2 id="调用-reactdomrender-发生了什么">调用 ReactDOM.render 发生了什么？</h2><ol><li>确定应用渲染方式；</li><li>创建 fiberRoot 和 rootFiberNode，并将两者用指针指向彼此；</li><li>向 rootFiberNode 绑定自身的更新队列；</li><li>清空 container 里的内容；</li><li>向 container 绑定原生事件；</li><li>将 render 的第三个参数的 this 指向应用实例并调用；</li><li>初始化完成后，创建 update，并将 fiber 对应的组件作为 payload；</li><li>将 update 与 fiberNode 相关联，fiberNode 对应的 update 组成循环链表；</li><li>调用 scheduleUpdateOnFiber 开始渲染工作。</li></ol><div class="highlight"><div class="chroma"><table class="lntable"><tbody><tr><td class="lntd"><pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span><span class="lnt">182
</span><span class="lnt">183
</span><span class="lnt">184
</span><span class="lnt">185
</span><span class="lnt">186
</span><span class="lnt">187
</span><span class="lnt">188
</span><span class="lnt">189
</span><span class="lnt">190
</span><span class="lnt">191
</span><span class="lnt">192
</span><span class="lnt">193
</span><span class="lnt">194
</span><span class="lnt">195
</span><span class="lnt">196
</span><span class="lnt">197
</span><span class="lnt">198
</span><span class="lnt">199
</span><span class="lnt">200
</span><span class="lnt">201
</span><span class="lnt">202
</span><span class="lnt">203
</span><span class="lnt">204
</span><span class="lnt">205
</span><span class="lnt">206
</span><span class="lnt">207
</span><span class="lnt">208
</span><span class="lnt">209
</span><span class="lnt">210
</span><span class="lnt">211
</span><span class="lnt">212
</span><span class="lnt">213
</span><span class="lnt">214
</span><span class="lnt">215
</span><span class="lnt">216
</span><span class="lnt">217
</span><span class="lnt">218
</span><span class="lnt">219
</span><span class="lnt">220
</span><span class="lnt">221
</span><span class="lnt">222
</span><span class="lnt">223
</span><span class="lnt">224
</span><span class="lnt">225
</span><span class="lnt">226
</span><span class="lnt">227
</span><span class="lnt">228
</span><span class="lnt">229
</span><span class="lnt">230
</span><span class="lnt">231
</span><span class="lnt">232
</span><span class="lnt">233
</span><span class="lnt">234
</span><span class="lnt">235
</span><span class="lnt">236
</span><span class="lnt">237
</span><span class="lnt">238
</span><span class="lnt">239
</span><span class="lnt">240
</span><span class="lnt">241
</span><span class="lnt">242
</span><span class="lnt">243
</span><span class="lnt">244
</span><span class="lnt">245
</span><span class="lnt">246
</span><span class="lnt">247
</span><span class="lnt">248
</span><span class="lnt">249
</span><span class="lnt">250
</span><span class="lnt">251
</span><span class="lnt">252
</span><span class="lnt">253
</span><span class="lnt">254
</span><span class="lnt">255
</span><span class="lnt">256
</span><span class="lnt">257
</span><span class="lnt">258
</span><span class="lnt">259
</span><span class="lnt">260
</span><span class="lnt">261
</span><span class="lnt">262
</span><span class="lnt">263
</span><span class="lnt">264
</span><span class="lnt">265
</span><span class="lnt">266
</span><span class="lnt">267
</span><span class="lnt">268
</span><span class="lnt">269
</span><span class="lnt">270
</span><span class="lnt">271
</span><span class="lnt">272
</span><span class="lnt">273
</span><span class="lnt">274
</span><span class="lnt">275
</span><span class="lnt">276
</span><span class="lnt">277
</span><span class="lnt">278
</span><span class="lnt">279
</span><span class="lnt">280
</span><span class="lnt">281
</span><span class="lnt">282
</span><span class="lnt">283
</span><span class="lnt">284
</span><span class="lnt">285
</span><span class="lnt">286
</span><span class="lnt">287
</span><span class="lnt">288
</span><span class="lnt">289
</span><span class="lnt">290
</span><span class="lnt">291
</span><span class="lnt">292
</span><span class="lnt">293
</span><span class="lnt">294
</span><span class="lnt">295
</span><span class="lnt">296
</span><span class="lnt">297
</span><span class="lnt">298
</span><span class="lnt">299
</span><span class="lnt">300
</span><span class="lnt">301
</span><span class="lnt">302
</span><span class="lnt">303
</span><span class="lnt">304
</span><span class="lnt">305
</span><span class="lnt">306
</span><span class="lnt">307
</span><span class="lnt">308
</span><span class="lnt">309
</span><span class="lnt">310
</span><span class="lnt">311
</span><span class="lnt">312
</span><span class="lnt">313
</span><span class="lnt">314
</span><span class="lnt">315
</span><span class="lnt">316
</span><span class="lnt">317
</span><span class="lnt">318
</span><span class="lnt">319
</span><span class="lnt">320
</span></code></pre></td><td class="lntd"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="c1">// ReactDOM 的渲染模式
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">export</span> <span class="kr">type</span> <span class="nx">RootTag</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">|</span> <span class="mi">1</span> <span class="o">|</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">export</span> <span class="kr">const</span> <span class="nx">LegacyRoot</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// ReactDOM.createLegacyRoot
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">export</span> <span class="kr">const</span> <span class="nx">BlockingRoot</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// ReactDOM.createBlockingRoot
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">export</span> <span class="kr">const</span> <span class="nx">ConcurrentRoot</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// ReactDOM.createRoot
</span></span></span><span class="line"><span class="cl"><span class="c1">// ReactDOM.render
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">export</span> <span class="kd">function</span> <span class="nx">render</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="nx">element</span>: <span class="kt">React$Element</span><span class="p">&lt;</span><span class="nt">any</span><span class="p">&gt;,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">container</span>: <span class="kt">Container</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">callback</span>: <span class="kt">?Function</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 向 DOMContainer 里渲染子树
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">return</span> <span class="nx">legacyRenderSubtreeIntoContainer</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="kc">null</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">element</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">container</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="kc">false</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">callback</span>
</span></span><span class="line"><span class="cl">  <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">legacyRenderSubtreeIntoContainer</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="nx">parentComponent</span>: <span class="kt">?React$Component</span><span class="p">&lt;</span><span class="nt">any</span><span class="err">,</span> <span class="na">any</span><span class="p">&gt;,</span> <span class="c1">// null
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">children</span>: <span class="kt">ReactNodeList</span><span class="p">,</span> <span class="c1">// ReactElement
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">container</span>: <span class="kt">Container</span><span class="p">,</span> <span class="c1">// DOMContainer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">forceHydrate</span>: <span class="kt">boolean</span><span class="p">,</span> <span class="c1">// false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">callback</span>: <span class="kt">?Function</span> <span class="c1">// () =&gt; {}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">root</span>: <span class="kt">RootType</span> <span class="o">=</span> <span class="nx">container</span><span class="p">.</span><span class="nx">_reactRootContainer</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">fiberRoot</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">root</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 初始化阶段准备工作：
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 0. legacyCreateRootFromDOMContainer 最终会调用 createRootImpl
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 1. container._reactRootContainer._internalRoot = createRootImpl(container, 0, undefined)
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 2. createRootImpl(container, 0, undefined) 返回了 fiberRoot
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 3. fiberRoot 一个应用只有一个，其 current 属性指向了 rootFiberNode
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 4. fiberRoot.current 指向了 currentFiber 树
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 5. fiberRoot.finishedWork 指向了 workInProgress 树
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 6. 清空 container
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="nx">root</span> <span class="o">=</span> <span class="nx">container</span><span class="p">.</span><span class="nx">_reactRootContainer</span> <span class="o">=</span> <span class="nx">legacyCreateRootFromDOMContainer</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="nx">container</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nx">forceHydrate</span>
</span></span><span class="line"><span class="cl">    <span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nx">fiberRoot</span> <span class="o">=</span> <span class="nx">root</span><span class="p">.</span><span class="nx">_internalRoot</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">callback</span> <span class="o">===</span> <span class="s1">'function'</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="kr">const</span> <span class="nx">originalCallback</span> <span class="o">=</span> <span class="nx">callback</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="nx">callback</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">         * getPublicRootInstance 会通过 fiberRoot 访问 rootFiberNode
</span></span></span><span class="line"><span class="cl"><span class="cm">         * 如果 rootFiberNode 没有子节点，返回 null
</span></span></span><span class="line"><span class="cl"><span class="cm">         * 否则返回 rootFiberNode 子节点的 stateNode
</span></span></span><span class="line"><span class="cl"><span class="cm">         * 总之就是返回一个非 rootFiberNode 的组件实例
</span></span></span><span class="line"><span class="cl"><span class="cm">         */</span>
</span></span><span class="line"><span class="cl">        <span class="kr">const</span> <span class="nx">instance</span> <span class="o">=</span> <span class="nx">getPublicRootInstance</span><span class="p">(</span><span class="nx">fiberRoot</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 调用了 callback 就说明应用初始化完成了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">originalCallback</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">instance</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 初始化完成之后，就准备进行应用渲染了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">unbatchedUpdates</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">updateContainer</span><span class="p">(</span><span class="nx">children</span><span class="p">,</span> <span class="nx">fiberRoot</span><span class="p">,</span> <span class="nx">parentComponent</span><span class="p">,</span> <span class="nx">callback</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">});</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 后续更新需要重新渲染，会走这里
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">fiberRoot</span> <span class="o">=</span> <span class="nx">root</span><span class="p">.</span><span class="nx">_internalRoot</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">callback</span> <span class="o">===</span> <span class="s1">'function'</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="kr">const</span> <span class="nx">originalCallback</span> <span class="o">=</span> <span class="nx">callback</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="nx">callback</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kr">const</span> <span class="nx">instance</span> <span class="o">=</span> <span class="nx">getPublicRootInstance</span><span class="p">(</span><span class="nx">fiberRoot</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nx">originalCallback</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">instance</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">updateContainer</span><span class="p">(</span><span class="nx">children</span><span class="p">,</span> <span class="nx">fiberRoot</span><span class="p">,</span> <span class="nx">parentComponent</span><span class="p">,</span> <span class="nx">callback</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">getPublicRootInstance</span><span class="p">(</span><span class="nx">fiberRoot</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">createRootImpl</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="nx">container</span>: <span class="kt">Container</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">tag</span>: <span class="kt">RootTag</span><span class="p">,</span> <span class="c1">// 用来表示是否开启“并发模式”
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">options</span>: <span class="kt">void</span> <span class="o">|</span> <span class="nx">RootOptions</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">root</span> <span class="o">=</span> <span class="nx">createFiberRoot</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="nx">container</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">tag</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="nx">hydrate</span> <span class="o">=</span> <span class="kc">false</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="nx">hydrationCallbacks</span> <span class="o">=</span> <span class="kc">null</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nx">container</span><span class="p">.</span><span class="nx">__reactContainer$</span> <span class="o">=</span> <span class="nx">root</span><span class="p">.</span><span class="nx">current</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">   * 获取应用挂载的 DOM 的 nodeType：
</span></span></span><span class="line"><span class="cl"><span class="cm">   * Node.ELEMENT_NODE                      1     元素节点
</span></span></span><span class="line"><span class="cl"><span class="cm">   * Node.TEXT_NODE                         3     文字节点
</span></span></span><span class="line"><span class="cl"><span class="cm">   * Node.CDATA_SECTION_NODE                4     &lt;!CDATA[[ … ]]&gt;
</span></span></span><span class="line"><span class="cl"><span class="cm">   * Node.PROCESSING_INSTRUCTION_NODE       7     &lt;?xml-stylesheet ... ?&gt;
</span></span></span><span class="line"><span class="cl"><span class="cm">   * Node.COMMENT_NODE                      8     注释节点
</span></span></span><span class="line"><span class="cl"><span class="cm">   * Node.DOCUMENT_NODE                     9     Document
</span></span></span><span class="line"><span class="cl"><span class="cm">   * Node.DOCUMENT_TYPE_NODE                10    &lt;!DOCTYPE html&gt;
</span></span></span><span class="line"><span class="cl"><span class="cm">   * Node.DOCUMENT_FRAGMENT_NODE            11    DocumentFragment
</span></span></span><span class="line"><span class="cl"><span class="cm">   */</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">rootContainerElement</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">    <span class="nx">container</span><span class="p">.</span><span class="nx">nodeType</span> <span class="o">===</span> <span class="nx">COMMENT_NODE</span> <span class="o">?</span> <span class="nx">container.parentNode</span> : <span class="kt">container</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">rootContainerElement</span><span class="p">.</span><span class="nx">_reactListening</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">   * allNativeEvents 是包含了离散（触发）事件、阻塞（用户交互）事件、连续（不能被打断）事件、表单事件的 Set
</span></span></span><span class="line"><span class="cl"><span class="cm">   * nonDelegatedEvents 是放置的是“非委托”事件的 Set&nbsp;(类似于一个白名单)
</span></span></span><span class="line"><span class="cl"><span class="cm">   * listenToNativeEvent(事件名称，是否在捕获阶段触发，应用根容器，目标元素)
</span></span></span><span class="line"><span class="cl"><span class="cm">   * 1. 将 selectionchange 绑定到 document
</span></span></span><span class="line"><span class="cl"><span class="cm">   * 2. 将支持“冒泡”的事件委托到 rootContainerElement
</span></span></span><span class="line"><span class="cl"><span class="cm">   * 3. 其他的事件除了 scroll、load... 外，绑定到“目标元素”
</span></span></span><span class="line"><span class="cl"><span class="cm">   * 4. 从 EventTarget.__reactEvents 找到所有绑定的 listener（保存在 Set 里）
</span></span></span><span class="line"><span class="cl"><span class="cm">   * 5. listener 里如果没有 `${domEventName}__${capture ? 'capture' : 'bubble'}` 会执行 addTrappedEventListener
</span></span></span><span class="line"><span class="cl"><span class="cm">   * addTrappedEventListener(EventTarget, DOMEventName, EventSystemFlags, isCapture, isDeferred)
</span></span></span><span class="line"><span class="cl"><span class="cm">   * 1. createEventListenerWrapperWithPriority 会根据事件类型，使用不同的优先级函数包裹 listener（事件优先级），将 DOM 事件转发到 React 内部
</span></span></span><span class="line"><span class="cl"><span class="cm">   *    a. dispatchDiscreteEvent 离散事件，最高优先级
</span></span></span><span class="line"><span class="cl"><span class="cm">   *    b. dispatchUserBlockingUpdate 用户阻塞事件
</span></span></span><span class="line"><span class="cl"><span class="cm">   *    c. dispatchEvent 连续事件
</span></span></span><span class="line"><span class="cl"><span class="cm">   * 2. 对于“touchstart”、“touchmove”、“wheel”三个事件，isPassive=true（preventDefault 失效）
</span></span></span><span class="line"><span class="cl"><span class="cm">   * 3. 根据 isCapture 和 isPassive 将事件绑定分发给了四个函数 addEvent[Bubble/Capture]Listener[WithPassiveFlag]
</span></span></span><span class="line"><span class="cl"><span class="cm">   * 4. 调用原生 API：addEventListener 和 removeEventListener 进行事件的绑定和移除
</span></span></span><span class="line"><span class="cl"><span class="cm">   * 总的来说，React 会根据事件 isCapture、isPassive 和优先级，将事件绑定到合适的 target 上
</span></span></span><span class="line"><span class="cl"><span class="cm">   */</span>
</span></span><span class="line"><span class="cl">  <span class="nx">allNativeEvents</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">domEventName</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">nonDelegatedEvents</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">domEventName</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 可以使用“事件委托”
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="nx">listenToNativeEvent</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="nx">domEventName</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="kc">false</span><span class="p">,</span> <span class="c1">// “事件委托”需要“事件冒泡”的支持
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">rootContainerElement</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="kc">null</span>
</span></span><span class="line"><span class="cl">      <span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 捕获阶段监听
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">listenToNativeEvent</span><span class="p">(</span><span class="nx">domEventName</span><span class="p">,</span> <span class="kc">true</span><span class="p">,</span> <span class="nx">rootContainerElement</span><span class="p">,</span> <span class="kc">null</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">});</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">root</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 创建 fiberRoot 和 rootFiberNode，并将两者关联起来
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">export</span> <span class="kd">function</span> <span class="nx">createFiberRoot</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="nx">containerInfo</span>: <span class="kt">any</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">tag</span>: <span class="kt">RootTag</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">hydrate</span>: <span class="kt">boolean</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="o">:</span> <span class="nx">FiberRoot</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">root</span>: <span class="kt">FiberRoot</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">tag</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">containerInfo</span><span class="p">,</span> <span class="c1">// DOMContainer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">pendingChildren</span>: <span class="kt">null</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">current</span>: <span class="kt">null</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">pingCache</span>: <span class="kt">null</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">finishedWork</span>: <span class="kt">null</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">timeoutHandle</span>: <span class="kt">noTimeout</span><span class="p">,</span> <span class="c1">// -1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">context</span>: <span class="kt">null</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">pendingContext</span>: <span class="kt">null</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">hydrate</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">callbackNode</span>: <span class="kt">null</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">callbackPriority</span>: <span class="kt">NoLanePriority</span><span class="p">,</span> <span class="c1">// 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">eventTimes</span>: <span class="kt">createLaneMap</span><span class="p">(</span><span class="nx">NoLanes</span><span class="p">),</span> <span class="c1">// []
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">expirationTimes</span>: <span class="kt">createLaneMap</span><span class="p">(</span><span class="nx">NoTimestamp</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="nx">pendingLanes</span>: <span class="kt">NoLanes</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">suspendedLanes</span>: <span class="kt">NoLanes</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">pingedLanes</span>: <span class="kt">NoLanes</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">expiredLanes</span>: <span class="kt">NoLanes</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">mutableReadLanes</span>: <span class="kt">NoLanes</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">finishedLanes</span>: <span class="kt">NoLanes</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">entangledLanes</span>: <span class="kt">NoLanes</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">entanglements</span>: <span class="kt">createLaneMap</span><span class="p">(</span><span class="nx">NoLanes</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// VDOM -&gt; Fiber -&gt; DOM
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kr">const</span> <span class="nx">uninitializedFiber</span>: <span class="kt">FiberNode</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">tag</span>: <span class="kt">3</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">key</span>: <span class="kt">null</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">elementType</span>: <span class="kt">null</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="kr">type</span><span class="o">:</span> <span class="kc">null</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">stateNode</span>: <span class="kt">null</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span><span class="o">:</span> <span class="kc">null</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">child</span>: <span class="kt">null</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">sibling</span>: <span class="kt">null</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">index</span>: <span class="kt">0</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">ref</span>: <span class="kt">null</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 节点状态相关 start，作用在 fiber 构造阶段，影响子节点生成
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">pendingProps</span>: <span class="kt">null</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">memoizedProps</span>: <span class="kt">null</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">updateQueue</span>: <span class="kt">null</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">memoizedState</span>: <span class="kt">null</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 节点相关状态 end
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">dependencies</span>: <span class="kt">null</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">mode</span>: <span class="kt">NoMode</span> <span class="o">|</span> <span class="nx">ConcurrentMode</span> <span class="o">|</span> <span class="nx">BlockingMode</span> <span class="o">|</span> <span class="nx">StrictMode</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 节点副作用相关 start
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">nextEffect</span>: <span class="kt">null</span><span class="p">,</span> <span class="c1">// 用于 EffectList，指向下一个有副作用的 fiber
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">firstEffect</span>: <span class="kt">null</span><span class="p">,</span> <span class="c1">// 指向 EffectList 中的第一个 fiber
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">lastEffect</span>: <span class="kt">null</span><span class="p">,</span> <span class="c1">// 指向 EffectList 中的最后一个 fiber
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">flags</span>: <span class="kt">NoFlags</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 节点副作用相关 end
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">lanes</span>: <span class="kt">NoLanes</span><span class="p">,</span> <span class="c1">// 当前 fiber 优先级
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">childLanes</span>: <span class="kt">NoLanes</span><span class="p">,</span> <span class="c1">// 子 fiber 优先级
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">alternate</span>: <span class="kt">null</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// fiberRoot 的 current 指向 rootFiberNode
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">root</span><span class="p">.</span><span class="nx">current</span> <span class="o">=</span> <span class="nx">uninitializedFiber</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// rootFiberNode 的 stateNode 指向 fiberRoot
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">uninitializedFiber</span><span class="p">.</span><span class="nx">stateNode</span> <span class="o">=</span> <span class="nx">root</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// rootFiberNode 的更新队列（链表）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">uninitializedFiber</span><span class="p">.</span><span class="nx">updateQueue</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">baseState</span>: <span class="kt">uninitializedFiber.memoizedState</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">firstBaseUpdate</span>: <span class="kt">null</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">lastBaseUpdate</span>: <span class="kt">null</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">shared</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">pending</span>: <span class="kt">null</span>
</span></span><span class="line"><span class="cl">    <span class="p">},</span>
</span></span><span class="line"><span class="cl">    <span class="nx">effects</span>: <span class="kt">null</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">root</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 创建更新，安排渲染
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">export</span> <span class="kd">function</span> <span class="nx">updateContainer</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="nx">element</span>: <span class="kt">ReactNodeList</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">container</span>: <span class="kt">OpaqueRoot</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">parentComponent</span>: <span class="kt">?React$Component</span><span class="p">&lt;</span><span class="nt">any</span><span class="err">,</span> <span class="na">any</span><span class="p">&gt;,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">callback</span>: <span class="kt">?Function</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="o">:</span> <span class="nx">Lane</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">current</span> <span class="o">=</span> <span class="nx">container</span><span class="p">.</span><span class="nx">current</span><span class="p">;</span> <span class="c1">// rootFiberNode
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kr">const</span> <span class="nx">eventTime</span> <span class="o">=</span> <span class="nx">requestEventTime</span><span class="p">();</span> <span class="c1">// 当前时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kr">const</span> <span class="nx">lane</span> <span class="o">=</span> <span class="nx">requestUpdateLane</span><span class="p">(</span><span class="nx">current</span><span class="p">);</span> <span class="c1">// 优先级
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kr">const</span> <span class="nx">context</span> <span class="o">=</span> <span class="nx">getContextForSubtree</span><span class="p">(</span><span class="nx">parentComponent</span><span class="p">);</span> <span class="c1">// emptyContextObject = {}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="nx">container</span><span class="p">.</span><span class="nx">context</span> <span class="o">===</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">container</span><span class="p">.</span><span class="nx">context</span> <span class="o">=</span> <span class="nx">context</span><span class="p">;</span> <span class="c1">// 走这儿
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">container</span><span class="p">.</span><span class="nx">pendingContext</span> <span class="o">=</span> <span class="nx">context</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 创建了一个 update 对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kr">const</span> <span class="nx">update</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">callback</span>: <span class="kt">null</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">eventTime</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">lane</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">next</span>: <span class="kt">null</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">payload</span><span class="o">:</span> <span class="p">{</span> <span class="nx">element</span> <span class="p">},</span>
</span></span><span class="line"><span class="cl">    <span class="nx">tag</span>: <span class="kt">UpdateState</span> <span class="c1">// 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">};</span>
</span></span><span class="line"><span class="cl">  <span class="nx">callback</span> <span class="o">=</span> <span class="nx">callback</span> <span class="o">===</span> <span class="kc">undefined</span> <span class="o">?</span> <span class="kc">null</span> <span class="o">:</span> <span class="nx">callback</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nx">callback</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">update</span><span class="p">.</span><span class="nx">callback</span> <span class="o">=</span> <span class="nx">callback</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">   * enqueueUpdate 做了一下事情：将 fiber 节点和 update 关联起来
</span></span></span><span class="line"><span class="cl"><span class="cm">   * const updateQueue = fiber.updateQueue;
</span></span></span><span class="line"><span class="cl"><span class="cm">   * const sharedQueue = fiber.updateQueue.shared;
</span></span></span><span class="line"><span class="cl"><span class="cm">   * const pending = sharedQueue.pending;
</span></span></span><span class="line"><span class="cl"><span class="cm">   * update.next = update; // 每个 fiberNode 的所有 update 组成了一个链表，只不过现在链表里只有一个元素
</span></span></span><span class="line"><span class="cl"><span class="cm">   * sharedQueue.pending = update;
</span></span></span><span class="line"><span class="cl"><span class="cm">   */</span>
</span></span><span class="line"><span class="cl">  <span class="nx">enqueueUpdate</span><span class="p">(</span><span class="nx">current</span><span class="p">,</span> <span class="nx">update</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 执行渲染工作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">scheduleUpdateOnFiber</span><span class="p">(</span><span class="nx">current</span><span class="p">,</span> <span class="nx">lane</span><span class="p">,</span> <span class="nx">eventTime</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">lane</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 从 17 开始，e.persist() 将不再生效，因为 SyntheticEvent 不再放入事件池中
</span></span></span><span class="line"><span class="cl"><span class="cm"> * React 将不再向 document 附加事件处理器
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 而会将事件处理器附加到渲染 React 树的根 DOM 容器中
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 原因：如果页面上有多个 React 版本，会破坏 e.stopPropagation()
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kr">export</span> <span class="kd">function</span> <span class="nx">listenToNativeEvent</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="nx">domEventName</span>: <span class="kt">DOMEventName</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">isCapturePhaseListener</span>: <span class="kt">boolean</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">rootContainerElement</span>: <span class="kt">EventTarget</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">targetElement</span>: <span class="kt">Element</span> <span class="o">|</span> <span class="kc">null</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">eventSystemFlags?</span>: <span class="kt">EventSystemFlags</span> <span class="o">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="o">:</span> <span class="k">void</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">target</span> <span class="o">=</span> <span class="nx">rootContainerElement</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="nx">domEventName</span> <span class="o">===</span> <span class="s1">'selectionchange'</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">    <span class="nx">rootContainerElement</span><span class="p">.</span><span class="nx">nodeType</span> <span class="o">!==</span> <span class="nx">DOCUMENT_NODE</span>
</span></span><span class="line"><span class="cl">  <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * selectionchange 事件需要直接绑定在 document 上
</span></span></span><span class="line"><span class="cl"><span class="cm">     * ownerDocument 返回节点的顶层的 document 对象
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="nx">target</span> <span class="o">=</span> <span class="nx">rootContainerElement</span><span class="p">.</span><span class="nx">ownerDocument</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">   * 如果事件可以被委托（或者在捕获阶段触发）
</span></span></span><span class="line"><span class="cl"><span class="cm">   * 那就注册在 rootContainerElement 上
</span></span></span><span class="line"><span class="cl"><span class="cm">   * 否则，就绑定在 targetElement 上
</span></span></span><span class="line"><span class="cl"><span class="cm">   */</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="nx">targetElement</span> <span class="o">!==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">    <span class="o">!</span><span class="nx">isCapturePhaseListener</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">    <span class="nx">nonDelegatedEvents</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">domEventName</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 所有不能代理的事件（多媒体事件、cancel、close、invalid、load、scroll、toggle）
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 都绑定在 targetElement 上
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nx">domEventName</span> <span class="o">!==</span> <span class="s1">'scroll'</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 除了 scroll 事件，因为任何元素都可以滚动
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">eventSystemFlags</span> <span class="o">|=</span> <span class="nx">IS_NON_DELEGATED</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nx">target</span> <span class="o">=</span> <span class="nx">targetElement</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// target['__reactEvents$' + Math.random().toString(36).slice(2)] = new Set()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kr">const</span> <span class="nx">listenerSet</span> <span class="o">=</span> <span class="nx">getEventListenerSet</span><span class="p">(</span><span class="nx">target</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// `${domEventName}__${isCapturePhaseListener ? 'capture' : 'bubble'}`
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kr">const</span> <span class="nx">listenerSetKey</span> <span class="o">=</span> <span class="nx">getListenerSetKey</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="nx">domEventName</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">isCapturePhaseListener</span>
</span></span><span class="line"><span class="cl">  <span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">listenerSet</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">listenerSetKey</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nx">isCapturePhaseListener</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">eventSystemFlags</span> <span class="o">|=</span> <span class="nx">IS_CAPTURE_PHASE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">addTrappedEventListener</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="nx">target</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nx">domEventName</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nx">eventSystemFlags</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nx">isCapturePhaseListener</span>
</span></span><span class="line"><span class="cl">    <span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nx">listenerSet</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">listenerSetKey</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></tbody></table></div></div><h2 id="调用-scheduleupdateonfiber-发生了什么">调用 scheduleUpdateOnFiber 发生了什么？</h2><div class="highlight"><div class="chroma"><table class="lntable"><tbody><tr><td class="lntd"><pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span></code></pre></td><td class="lntd"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kr">export</span> <span class="kd">function</span> <span class="nx">scheduleUpdateOnFiber</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="nx">fiber</span>: <span class="kt">Fiber</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">lane</span>: <span class="kt">Lane</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">eventTime</span>: <span class="kt">number</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 检查是否有嵌套更新，如果嵌套超过 50 层，终止调度
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">checkForNestedUpdates</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 标记从 fiberNode 到 fiberRoot 的更新时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kr">const</span> <span class="nx">root</span> <span class="o">=</span> <span class="nx">markUpdateLaneFromFiberToRoot</span><span class="p">(</span><span class="nx">fiber</span><span class="p">,</span> <span class="nx">lane</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nx">root</span> <span class="o">===</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 标记 fiberRoot 有挂起的更新
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">markRootUpdated</span><span class="p">(</span><span class="nx">root</span><span class="p">,</span> <span class="nx">lane</span><span class="p">,</span> <span class="nx">eventTime</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nx">root</span> <span class="o">===</span> <span class="nx">workInProgressRoot</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 接收到在渲染过程中的树的更新，标记 fiberRoot 上存在交叉更新工作
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 除非 deferRenderPhaseUpdateToNextBatch 标志关闭并且这是 render 阶段更新
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 在这种情况下，出于向后兼容的原因，我们不会将 render 阶段更新视为交错处理
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="nx">workInProgressRootUpdatedLanes</span> <span class="o">=</span> <span class="nx">workInProgressRootUpdatedLanes</span> <span class="o">|</span> <span class="nx">lane</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">   * 获取 currentPriorityLevel 的值和 Scheduler_*Priority 做对比；获取当前优先级
</span></span></span><span class="line"><span class="cl"><span class="cm">   * ImmediatePriority ||
</span></span></span><span class="line"><span class="cl"><span class="cm">   * UserBlockingPriority||
</span></span></span><span class="line"><span class="cl"><span class="cm">   * NormalPriority ||
</span></span></span><span class="line"><span class="cl"><span class="cm">   * LowPriority ||
</span></span></span><span class="line"><span class="cl"><span class="cm">   * IdlePriority
</span></span></span><span class="line"><span class="cl"><span class="cm">   */</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">priorityLevel</span> <span class="o">=</span> <span class="nx">getCurrentPriorityLevel</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nx">lane</span> <span class="o">===</span> <span class="nx">SyncLane</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 初次渲染是同步的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 检查是否在 unbatchedUpdates 内部
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="p">(</span><span class="nx">executionContext</span> <span class="o">&amp;</span> <span class="nx">LegacyUnbatchedContext</span><span class="p">)</span> <span class="o">!==</span> <span class="nx">NoContext</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 检查是否还没有渲染
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="p">(</span><span class="nx">executionContext</span> <span class="o">&amp;</span> <span class="p">(</span><span class="nx">RenderContext</span> <span class="o">|</span> <span class="nx">CommitContext</span><span class="p">))</span> <span class="o">===</span> <span class="nx">NoContext</span>
</span></span><span class="line"><span class="cl">    <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 在 fiberRoot 上注册挂起的交互，以避免丢失跟踪的交互数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="nx">schedulePendingInteractions</span><span class="p">(</span><span class="nx">root</span><span class="p">,</span> <span class="nx">lane</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">       * 一种边缘情况：在 batchedUpdates 内部
</span></span></span><span class="line"><span class="cl"><span class="cm">       * ReactDOM.render 渲染的 root 节点挂载应该是同步的
</span></span></span><span class="line"><span class="cl"><span class="cm">       * 而布局更新应该推迟到批处理结束
</span></span></span><span class="line"><span class="cl"><span class="cm">       */</span>
</span></span><span class="line"><span class="cl">      <span class="nx">performSyncWorkOnRoot</span><span class="p">(</span><span class="nx">root</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">ensureRootIsScheduled</span><span class="p">(</span><span class="nx">root</span><span class="p">,</span> <span class="nx">eventTime</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="nx">schedulePendingInteractions</span><span class="p">(</span><span class="nx">root</span><span class="p">,</span> <span class="nx">lane</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="nx">executionContext</span> <span class="o">===</span> <span class="nx">NoContext</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">         * 现在就开始同步工作，除非我们已经开始或在批处理中
</span></span></span><span class="line"><span class="cl"><span class="cm">         * 这有意在 scheduleUpdateOnFiber 中（而不是 scheduleCallbackForFiber 中）
</span></span></span><span class="line"><span class="cl"><span class="cm">         * 以保留 schedule 回调而不立即执行它的能力
</span></span></span><span class="line"><span class="cl"><span class="cm">         * 我们只对用户发起的更新执行此操作，以保留遗留模式的历史行为
</span></span></span><span class="line"><span class="cl"><span class="cm">         */</span>
</span></span><span class="line"><span class="cl">        <span class="nx">resetRenderTimer</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="nx">flushSyncCallbackQueue</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 计划离散更新，但仅在它不是同步的情况下
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="p">(</span><span class="nx">executionContext</span> <span class="o">&amp;</span> <span class="nx">DiscreteEventContext</span><span class="p">)</span> <span class="o">!==</span> <span class="nx">NoContext</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 只有用户阻塞或更高优先级的更新才被视为离散的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="p">(</span><span class="nx">priorityLevel</span> <span class="o">===</span> <span class="nx">UserBlockingSchedulerPriority</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">        <span class="nx">priorityLevel</span> <span class="o">===</span> <span class="nx">ImmediateSchedulerPriority</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 跟踪每个 root 的最低优先级的离散更新，以便在必要时及早运行他们
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">if</span> <span class="p">(</span><span class="nx">rootsWithPendingDiscreteUpdates</span> <span class="o">===</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">rootsWithPendingDiscreteUpdates</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Set</span><span class="p">([</span><span class="nx">root</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">rootsWithPendingDiscreteUpdates</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">root</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果回调是同步的，则在之后安排其他更新
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">ensureRootIsScheduled</span><span class="p">(</span><span class="nx">root</span><span class="p">,</span> <span class="nx">eventTime</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nx">schedulePendingInteractions</span><span class="p">(</span><span class="nx">root</span><span class="p">,</span> <span class="nx">lane</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">   * 我们假设它和被更新的 root 相同，因为单个 root 的应用很常见
</span></span></span><span class="line"><span class="cl"><span class="cm">   * 如果不是同一个 root，那也不是啥难事
</span></span></span><span class="line"><span class="cl"><span class="cm">   * 我们只是倾向于把更多的东西 batch 在一起
</span></span></span><span class="line"><span class="cl"><span class="cm">   */</span>
</span></span><span class="line"><span class="cl">  <span class="nx">mostRecentlyUpdatedRoot</span> <span class="o">=</span> <span class="nx">root</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></tbody></table></div></div><h2 id="scheduler任务调度高优先级的任务先进行-render">scheduler（任务调度，高优先级的任务先进行 render）</h2><p>对任务按照优先级进行调度（高优先级的任务打断低优先级的任务的执行），所有任务保存在最小堆中（方便取出优先级最高的任务）。</p><div class="highlight"><div class="chroma"><table class="lntable"><tbody><tr><td class="lntd"><pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span></code></pre></td><td class="lntd"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 根据 priorityLevel 新建 task，task 的内容为 callback
</span></span></span><span class="line"><span class="cl"><span class="cm"> * task 根据优先级的不同保存在不同的队列里（taskQueue、timerQueue）
</span></span></span><span class="line"><span class="cl"><span class="cm"> * taskQueue 里存放着需要执行的任务
</span></span></span><span class="line"><span class="cl"><span class="cm"> * timerQueue 里存放着等待执行的任务
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">unstable_scheduleCallback</span><span class="p">(</span><span class="nx">priorityLevel</span><span class="p">,</span> <span class="nx">callback</span><span class="p">,</span> <span class="nx">options</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">var</span> <span class="nx">currentTime</span> <span class="o">=</span> <span class="nx">getCurrentTime</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="kd">var</span> <span class="nx">startTime</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 根据 option 计算任务最早开始时间（任务不能早于这个时间运行）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">options</span> <span class="o">===</span> <span class="s1">'object'</span> <span class="o">&amp;&amp;</span> <span class="nx">options</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nx">delay</span> <span class="o">=</span> <span class="nx">options</span><span class="p">.</span><span class="nx">delay</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">delay</span> <span class="o">===</span> <span class="s1">'number'</span> <span class="o">&amp;&amp;</span> <span class="nx">delay</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">startTime</span> <span class="o">=</span> <span class="nx">currentTime</span> <span class="o">+</span> <span class="nx">delay</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">startTime</span> <span class="o">=</span> <span class="nx">currentTime</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">startTime</span> <span class="o">=</span> <span class="nx">currentTime</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 根据优先级计算任务最多可以延后多久
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kd">var</span> <span class="nx">timeout</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">switch</span> <span class="p">(</span><span class="nx">priorityLevel</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nx">ImmediatePriority</span>:
</span></span><span class="line"><span class="cl">      <span class="kt">timeout</span> <span class="o">=</span> <span class="nx">IMMEDIATE_PRIORITY_TIMEOUT</span><span class="p">;</span> <span class="c1">// -1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nx">UserBlockingPriority</span>:
</span></span><span class="line"><span class="cl">      <span class="kt">timeout</span> <span class="o">=</span> <span class="nx">USER_BLOCKING_PRIORITY_TIMEOUT</span><span class="p">;</span> <span class="c1">// 250
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nx">IdlePriority</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// V8 在 32 位系统上能展示的最大整数 Math.pow(2, 30) - 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="nx">timeout</span> <span class="o">=</span> <span class="nx">IDLE_PRIORITY_TIMEOUT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nx">LowPriority</span>:
</span></span><span class="line"><span class="cl">      <span class="kt">timeout</span> <span class="o">=</span> <span class="nx">LOW_PRIORITY_TIMEOUT</span><span class="p">;</span> <span class="c1">// 10000
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nx">NormalPriority</span>:
</span></span><span class="line"><span class="cl">    <span class="kt">default</span><span class="o">:</span> <span class="c1">// 5000
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="nx">timeout</span> <span class="o">=</span> <span class="nx">NORMAL_PRIORITY_TIMEOUT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 任务过期时间（晚于这个时间必须立即执行）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kd">var</span> <span class="nx">expirationTime</span> <span class="o">=</span> <span class="nx">startTime</span> <span class="o">+</span> <span class="nx">timeout</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 新建任务
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kd">var</span> <span class="nx">newTask</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">id</span>: <span class="kt">taskIdCounter</span><span class="o">++</span><span class="p">,</span> <span class="c1">// 任务 ID
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">callback</span><span class="p">,</span> <span class="c1">// 任务内容
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">priorityLevel</span><span class="p">,</span> <span class="c1">// 优先级
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">startTime</span><span class="p">,</span> <span class="c1">// 最早执行时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">expirationTime</span><span class="p">,</span> <span class="c1">// 最晚执行时间（过期时间）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">sortIndex</span><span class="o">:</span> <span class="o">-</span><span class="mi">1</span> <span class="c1">// 值越小，优先级越高
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">};</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nx">startTime</span> <span class="o">&gt;</span> <span class="nx">currentTime</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 任务不需要现在就执行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">newTask</span><span class="p">.</span><span class="nx">sortIndex</span> <span class="o">=</span> <span class="nx">startTime</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 不需要立即执行的任务保存在 timerQueue
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">push</span><span class="p">(</span><span class="nx">timerQueue</span><span class="p">,</span> <span class="nx">newTask</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nx">peek</span><span class="p">(</span><span class="nx">taskQueue</span><span class="p">)</span> <span class="o">===</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="nx">newTask</span> <span class="o">===</span> <span class="nx">peek</span><span class="p">(</span><span class="nx">timerQueue</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// taskQueue 队列里的任务执行完了，并且新建的任务排在 timerQueue 的第一个，说明此时此刻没有任务需要执行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">if</span> <span class="p">(</span><span class="nx">isHostTimeoutScheduled</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">cancelHostTimeout</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">isHostTimeoutScheduled</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 安排一个 timeout
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="nx">requestHostTimeout</span><span class="p">(</span><span class="nx">handleTimeout</span><span class="p">,</span> <span class="nx">startTime</span> <span class="o">-</span> <span class="nx">currentTime</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">newTask</span><span class="p">.</span><span class="nx">sortIndex</span> <span class="o">=</span> <span class="nx">expirationTime</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 将要处理的任务放在 taskQueue
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">push</span><span class="p">(</span><span class="nx">taskQueue</span><span class="p">,</span> <span class="nx">newTask</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 接着干活，如果没时间了，等到一次 yield
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">isHostCallbackScheduled</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">isPerformingWork</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">isHostCallbackScheduled</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="nx">requestHostCallback</span><span class="p">(</span><span class="nx">flushWork</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">newTask</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></tbody></table></div></div><h2 id="reconcilerrender-阶段构建-workinprogress收集要更新的节点">reconciler（render 阶段，构建 workInProgress，收集要更新的节点）</h2><p>通过组件返回的 React 元素和 current 树构建 workInProgress 树，找出前后变化并打上<strong>标记</strong>，将所有变化收集到 effectList 链表里（链表对异步友好的；链表在循环时不用每次都进入递归函数，重新生成执行上下文，变量对象，激活对象，性能比递归好）。</p><ul><li><p>current 与 workInProgress：</p><ul><li>在 React 应用中最多会同时存在两棵 fiber 树，current 树对应当前渲染完成的视图；当状态更新后会在内存中构建 workInProgress 树；</li><li>当 fiberRoot 的 current 指向 workInProgress 时，workInProgress 树也就成为了 current 树；</li><li>每次状态更新都会在内存中构建 workInProgress 树，应用通过 current 与 workInProgress 的替换完成更新；</li><li>current 树的节点与 workInProgress 树的节点通过自身 alternate 指向对方。</li></ul></li><li><p>应用 mount（首次渲染）时：</p><ul><li>首次执行 ReactDOM.render 会创建 fiberRoot（应用根节点）和 rootFiberNode（组件树根节点）；</li><li>fiberRoot 有两个指针，current 指向 current 树，finishedWork 指向 workInProgress 树；</li><li>多次调用 ReactDOM.render 渲染不同的组件树，他们会拥有不同的 rootFiber；但是 fiberRoot 只有一个；</li><li>首次渲染时页面没有内容，current 树为空；接下来会在内存中创建 fiberNode，构成 workInProgress；</li><li>workInProgress 会在 commit 阶段同步更新到视图中。</li></ul></li><li><p>应用 update（状态变化）时：</p><ul><li>应用重新进入 render 阶段，调用组件 render 方法，重新构建 workInProgress；</li><li>构建 workInProgress 的过程中，组件产物会和 current 对应节点进行比较，并在需要改变的节点打上<strong>标记</strong>；</li><li>根据收集到的标记，更新视图。</li></ul></li></ul><h2 id="renderercommit-阶段更新页面">renderer（commit 阶段，更新页面）</h2><p>遍历 effectList（更新前、更新、更新后；需要遍历三次），更新视图（ReactArt、ReactDOM、ReactNative）；这个阶段是同步的，不能被打断：</p><div class="highlight"><div class="chroma"><table class="lntable"><tbody><tr><td class="lntd"><pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span><span class="lnt">182
</span><span class="lnt">183
</span><span class="lnt">184
</span><span class="lnt">185
</span><span class="lnt">186
</span><span class="lnt">187
</span><span class="lnt">188
</span><span class="lnt">189
</span><span class="lnt">190
</span><span class="lnt">191
</span><span class="lnt">192
</span><span class="lnt">193
</span><span class="lnt">194
</span><span class="lnt">195
</span><span class="lnt">196
</span><span class="lnt">197
</span><span class="lnt">198
</span><span class="lnt">199
</span><span class="lnt">200
</span><span class="lnt">201
</span><span class="lnt">202
</span><span class="lnt">203
</span><span class="lnt">204
</span><span class="lnt">205
</span><span class="lnt">206
</span><span class="lnt">207
</span><span class="lnt">208
</span><span class="lnt">209
</span><span class="lnt">210
</span><span class="lnt">211
</span><span class="lnt">212
</span><span class="lnt">213
</span><span class="lnt">214
</span><span class="lnt">215
</span><span class="lnt">216
</span><span class="lnt">217
</span><span class="lnt">218
</span><span class="lnt">219
</span><span class="lnt">220
</span><span class="lnt">221
</span><span class="lnt">222
</span><span class="lnt">223
</span><span class="lnt">224
</span><span class="lnt">225
</span><span class="lnt">226
</span><span class="lnt">227
</span><span class="lnt">228
</span><span class="lnt">229
</span><span class="lnt">230
</span><span class="lnt">231
</span><span class="lnt">232
</span><span class="lnt">233
</span><span class="lnt">234
</span><span class="lnt">235
</span><span class="lnt">236
</span><span class="lnt">237
</span><span class="lnt">238
</span><span class="lnt">239
</span><span class="lnt">240
</span></code></pre></td><td class="lntd"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 此时，有两棵树和一个链表：
</span></span></span><span class="line"><span class="cl"><span class="cm"> * current 表示当前屏幕显示内容
</span></span></span><span class="line"><span class="cl"><span class="cm"> * workInProgress 表示即将更新到屏幕上的内容
</span></span></span><span class="line"><span class="cl"><span class="cm"> * effectList 表示本次更新要执行的副作用（DOM 更新、生命周期调用、setState 回调、hooks 调用...）
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">commitRoot</span><span class="p">(</span><span class="nx">root</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">renderPriorityLevel</span> <span class="o">=</span> <span class="nx">getCurrentPriorityLevel</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="nx">runWithPriority</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="nx">ImmediateSchedulerPriority</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">commitRootImpl</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="nx">root</span><span class="p">,</span> <span class="nx">renderPriorityLevel</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">commitRootImpl</span><span class="p">(</span><span class="nx">root</span><span class="p">,</span> <span class="nx">renderPriorityLevel</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">do</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 触发 useEffect 回调与其他同步任务
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 由于这些任务可能触发新的渲染
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 所以，这里要一直遍历执行直到没有任务
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="nx">flushPassiveEffects</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="nx">rootWithPendingPassiveEffects</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">   * root 指 fiberRoot
</span></span></span><span class="line"><span class="cl"><span class="cm">   * root.finishedWork 指当前应用的 rootFiber
</span></span></span><span class="line"><span class="cl"><span class="cm">   */</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">finishedWork</span> <span class="o">=</span> <span class="nx">root</span><span class="p">.</span><span class="nx">finishedWork</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">lanes</span> <span class="o">=</span> <span class="nx">root</span><span class="p">.</span><span class="nx">finishedLanes</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nx">finishedWork</span> <span class="o">===</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 重置 fiberRoot 上的属性
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">root</span><span class="p">.</span><span class="nx">finishedWork</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">root</span><span class="p">.</span><span class="nx">finishedLanes</span> <span class="o">=</span> <span class="nx">NoLanes</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">root</span><span class="p">.</span><span class="nx">callbackNode</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span> <span class="c1">// 重置 scheduler 绑定的回调函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kd">let</span> <span class="nx">remainingLanes</span> <span class="o">=</span> <span class="nx">mergeLanes</span><span class="p">(</span><span class="nx">finishedWork</span><span class="p">.</span><span class="nx">lanes</span><span class="p">,</span> <span class="nx">finishedWork</span><span class="p">.</span><span class="nx">childLanes</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 清除已完成的离散型 updates，例如：用户鼠标点击触发的更新
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="nx">rootsWithPendingDiscreteUpdates</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="o">!</span><span class="nx">hasDiscreteLanes</span><span class="p">(</span><span class="nx">remainingLanes</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">      <span class="nx">rootsWithPendingDiscreteUpdates</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">root</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">rootsWithPendingDiscreteUpdates</span><span class="p">.</span><span class="k">delete</span><span class="p">(</span><span class="nx">root</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 重置全局变量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="nx">root</span> <span class="o">===</span> <span class="nx">workInProgressRoot</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">workInProgressRoot</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nx">workInProgress</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nx">workInProgressRootRenderLanes</span> <span class="o">=</span> <span class="nx">NoLanes</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">   * 将 effectList 赋值给 firstEffect
</span></span></span><span class="line"><span class="cl"><span class="cm">   * 由于每个 fiber 的 effectList 只包含他的子孙节点
</span></span></span><span class="line"><span class="cl"><span class="cm">   * 所以根节点如果有 effectTag 则不会被包含进来
</span></span></span><span class="line"><span class="cl"><span class="cm">   * 所以这里将有 effectTag 的根节点插入到 effectList 尾部
</span></span></span><span class="line"><span class="cl"><span class="cm">   * 这样才能保证有 effect 的 fiber 都在 effectList 中
</span></span></span><span class="line"><span class="cl"><span class="cm">   */</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">firstEffect</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nx">finishedWork</span><span class="p">.</span><span class="nx">flags</span> <span class="o">&gt;</span> <span class="nx">PerformedWork</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 一个 fiber 的 effectList 只包括它的子节点，而不是其本身
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 因此，如果 root 有一个 effect，我们需要把它加到列表的最后
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nx">finishedWork</span><span class="p">.</span><span class="nx">lastEffect</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">finishedWork</span><span class="p">.</span><span class="nx">lastEffect</span><span class="p">.</span><span class="nx">nextEffect</span> <span class="o">=</span> <span class="nx">finishedWork</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="nx">firstEffect</span> <span class="o">=</span> <span class="nx">finishedWork</span><span class="p">.</span><span class="nx">firstEffect</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">firstEffect</span> <span class="o">=</span> <span class="nx">finishedWork</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 根节点没有 effectTag
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">firstEffect</span> <span class="o">=</span> <span class="nx">finishedWork</span><span class="p">.</span><span class="nx">firstEffect</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nx">firstEffect</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">let</span> <span class="nx">previousLanePriority</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nx">decoupleUpdatePriorityFromScheduler</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">previousLanePriority</span> <span class="o">=</span> <span class="nx">getCurrentUpdateLanePriority</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="nx">setCurrentUpdateLanePriority</span><span class="p">(</span><span class="nx">SyncLanePriority</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kr">const</span> <span class="nx">prevExecutionContext</span> <span class="o">=</span> <span class="nx">executionContext</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nx">executionContext</span> <span class="o">|=</span> <span class="nx">CommitContext</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kr">const</span> <span class="nx">prevInteractions</span> <span class="o">=</span> <span class="nx">pushInteractions</span><span class="p">(</span><span class="nx">root</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 在调用生命周期之前置为 null
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">ReactCurrentOwner</span><span class="p">.</span><span class="nx">current</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * commit 阶段被分成了几个阶段，每个阶段都会遍历一遍 effectList
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 所有的 MutationEffects 都会在所有的 LayoutEffects 前执行
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 第一个阶段「before mutation」：
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 在修改之前，读取主树的 state
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 调用 getSnapshotBeforeUpdate
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 调度 useEffect
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="nx">focusedInstanceHandle</span> <span class="o">=</span> <span class="nx">prepareForCommit</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">containerInfo</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nx">shouldFireAfterActiveInstanceBlur</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nx">nextEffect</span> <span class="o">=</span> <span class="nx">firstEffect</span><span class="p">;</span> <span class="c1">// 从 firstEffect 开始遍历 effectList（第一遍）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">do</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">commitBeforeMutationEffects</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">captureCommitPhaseError</span><span class="p">(</span><span class="nx">nextEffect</span><span class="p">,</span> <span class="nx">error</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nx">nextEffect</span> <span class="o">=</span> <span class="nx">nextEffect</span><span class="p">.</span><span class="nx">nextEffect</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="nx">nextEffect</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 不再需要追踪激活的 fiber 实例
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">focusedInstanceHandle</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 第二个阶段「mutation」：
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 更新 DOM
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 调用 componentWillUnmount
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 调用 useLayoutEffect 销毁回调
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="nx">nextEffect</span> <span class="o">=</span> <span class="nx">firstEffect</span><span class="p">;</span> <span class="c1">// 从 firstEffect 开始遍历 effectList（第二遍）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">do</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">commitMutationEffects</span><span class="p">(</span><span class="nx">root</span><span class="p">,</span> <span class="nx">renderPriorityLevel</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">captureCommitPhaseError</span><span class="p">(</span><span class="nx">nextEffect</span><span class="p">,</span> <span class="nx">error</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nx">nextEffect</span> <span class="o">=</span> <span class="nx">nextEffect</span><span class="p">.</span><span class="nx">nextEffect</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="nx">nextEffect</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nx">shouldFireAfterActiveInstanceBlur</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">afterActiveInstanceBlur</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">resetAfterCommit</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">containerInfo</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * commit 之后，WIP 树就成为了 current 树
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 这是为了在调用 componentWillUnmount 期间，还可以获取卸载前组件的信息
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 也是为了在下一个阶段之前，在 componentDidMount/Update 调用期间，WIP 是 current 树
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="nx">root</span><span class="p">.</span><span class="nx">current</span> <span class="o">=</span> <span class="nx">finishedWork</span><span class="p">;</span> <span class="c1">// fiberRoot 的 current 指针指向了 finishedWork 所指向的 WIP
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 第三个阶段「layout」：
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 调用主树修改之后需要执行的副作用 setState 第二个参数
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 类组件的生命周期也会在这里调用 componentDidMount/Update
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="nx">nextEffect</span> <span class="o">=</span> <span class="nx">firstEffect</span><span class="p">;</span> <span class="c1">// 从 firstEffect 开始遍历 effectList（第三遍）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">do</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">commitLayoutEffects</span><span class="p">(</span><span class="nx">root</span><span class="p">,</span> <span class="nx">lanes</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">captureCommitPhaseError</span><span class="p">(</span><span class="nx">nextEffect</span><span class="p">,</span> <span class="nx">error</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nx">nextEffect</span> <span class="o">=</span> <span class="nx">nextEffect</span><span class="p">.</span><span class="nx">nextEffect</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="nx">nextEffect</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nx">nextEffect</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 告诉 Scheduler 在当前帧停一下，让浏览器渲染一下页面
</span></span></span><span class="line"><span class="cl"><span class="cm">     * yieldInterval = 5，每帧只给 5ms 让 React 执行 render 阶段的工作
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="nx">requestPaint</span><span class="p">();</span> <span class="c1">// needsPaint=true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="nx">enableSchedulerTracing</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">popInteractions</span><span class="p">(</span><span class="nx">prevInteractions</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">executionContext</span> <span class="o">=</span> <span class="nx">prevExecutionContext</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nx">decoupleUpdatePriorityFromScheduler</span> <span class="o">&amp;&amp;</span> <span class="nx">previousLanePriority</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">setCurrentUpdateLanePriority</span><span class="p">(</span><span class="nx">previousLanePriority</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// effectList 中没有 effect，直接将 WIP 树切换为 current 树
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">root</span><span class="p">.</span><span class="nx">current</span> <span class="o">=</span> <span class="nx">finishedWork</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">rootDidHavePassiveEffects</span> <span class="o">=</span> <span class="nx">rootDoesHavePassiveEffects</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// useEffect 相关
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="nx">rootDoesHavePassiveEffects</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 当前 commit 有副作用，在完成 layout 之前，不要调用副作用回调函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">rootDoesHavePassiveEffects</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nx">rootWithPendingPassiveEffects</span> <span class="o">=</span> <span class="nx">root</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nx">pendingPassiveEffectsLanes</span> <span class="o">=</span> <span class="nx">lanes</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nx">pendingPassiveEffectsRenderPriority</span> <span class="o">=</span> <span class="nx">renderPriorityLevel</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 处理完 effect 了，清除 nextEffect
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 如果有副作用，会在 flushPassiveEffects 里消耗掉
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="nx">nextEffect</span> <span class="o">=</span> <span class="nx">firstEffect</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="nx">nextEffect</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 把 effectList 拆了，进行内存释放
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="kr">const</span> <span class="nx">nextNextEffect</span> <span class="o">=</span> <span class="nx">nextEffect</span><span class="p">.</span><span class="nx">nextEffect</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="nx">nextEffect</span><span class="p">.</span><span class="nx">nextEffect</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="nx">nextEffect</span><span class="p">.</span><span class="nx">flags</span> <span class="o">&amp;</span> <span class="nx">Deletion</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">detachFiberAfterEffects</span><span class="p">(</span><span class="nx">nextEffect</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="nx">nextEffect</span> <span class="o">=</span> <span class="nx">nextNextEffect</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="nx">remainingLanes</span> <span class="o">=</span> <span class="nx">root</span><span class="p">.</span><span class="nx">pendingLanes</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 检查 root 上有没有漏掉的 work
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="nx">remainingLanes</span> <span class="o">!==</span> <span class="nx">NoLanes</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nx">enableSchedulerTracing</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="nx">spawnedWorkDuringRender</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kr">const</span> <span class="nx">expirationTimes</span> <span class="o">=</span> <span class="nx">spawnedWorkDuringRender</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nx">spawnedWorkDuringRender</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">expirationTimes</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="nx">scheduleInteractions</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="nx">root</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="nx">expirationTimes</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">            <span class="nx">root</span><span class="p">.</span><span class="nx">memoizedInteractions</span>
</span></span><span class="line"><span class="cl">          <span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="nx">schedulePendingInteractions</span><span class="p">(</span><span class="nx">root</span><span class="p">,</span> <span class="nx">remainingLanes</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 没任务的话，清除失败的错误边界？？？
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">legacyErrorBoundariesThatAlreadyFailed</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 检测无限循环的同步任务，判断是否进入了死循环
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="nx">remainingLanes</span> <span class="o">===</span> <span class="nx">SyncLane</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nx">root</span> <span class="o">===</span> <span class="nx">rootWithNestedUpdates</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">nestedUpdateCount</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">nestedUpdateCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="nx">rootWithNestedUpdates</span> <span class="o">=</span> <span class="nx">root</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">nestedUpdateCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 在离开 commitRoot 函数前调用，触发一次新的调度，确保任何附加的任务被调度
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">ensureRootIsScheduled</span><span class="p">(</span><span class="nx">root</span><span class="p">,</span> <span class="nx">now</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 处理未捕获的错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="nx">hasUncaughtError</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">hasUncaughtError</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kr">const</span> <span class="nx">error</span> <span class="o">=</span> <span class="nx">firstUncaughtError</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nx">firstUncaughtError</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">throw</span> <span class="nx">error</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">((</span><span class="nx">executionContext</span> <span class="o">&amp;</span> <span class="nx">LegacyUnbatchedContext</span><span class="p">)</span> <span class="o">!==</span> <span class="nx">NoContext</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">   * 执行同步任务，这样同步任务不需要等到下次事件循环再执行
</span></span></span><span class="line"><span class="cl"><span class="cm">   * 比如，在 componentDidMount 中执行 setState 创建的更新会在这里被同步执行
</span></span></span><span class="line"><span class="cl"><span class="cm">   */</span>
</span></span><span class="line"><span class="cl">  <span class="nx">flushSyncCallbackQueue</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></tbody></table></div></div><ul><li>beforeMutation（渲染前）：遍历 effectList 并调用 commitBeforeMutationEffects；调用 getSnapshotBeforeUpdate；调度 useEffect：</li></ul><div class="highlight"><div class="chroma"><table class="lntable"><tbody><tr><td class="lntd"><pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span></code></pre></td><td class="lntd"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 1. 调用 getSnapshotBeforeUpdate
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 2. 调用 useEffect 的销毁函数
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 3. 异步调度 useEffect
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">commitBeforeMutationEffects() {</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="nx">nextEffect</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kr">const</span> <span class="nx">current</span> <span class="o">=</span> <span class="nx">nextEffect</span><span class="p">.</span><span class="nx">alternate</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">shouldFireAfterActiveInstanceBlur</span> <span class="o">&amp;&amp;</span> <span class="nx">focusedInstanceHandle</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 处理 DOM 节点渲染/删除后的 autoFocus、blur 逻辑
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kr">const</span> <span class="nx">flags</span> <span class="o">=</span> <span class="nx">nextEffect</span><span class="p">.</span><span class="nx">flags</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">((</span><span class="nx">flags</span> <span class="o">&amp;</span> <span class="nx">Snapshot</span><span class="p">)</span> <span class="o">!==</span> <span class="nx">NoFlags</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// commitBeforeMutationEffectOnFiber 会调用 getSnapshotBeforeUpdate
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// snapshot = instance.getSnapshotBeforeUpdate(
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">//   finishedWork.elementType === finishedWork.type
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">//     ? prevProps
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">//     : resolveDefaultProps(finishedWork.type, prevProps),
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">//   prevState
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// );
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// 将返回值存储在内部属性上，方便 componentDidUpdate 获取
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// instance.__reactInternalSnapshotBeforeUpdate = snapshot;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="nx">commitBeforeMutationEffectOnFiber</span><span class="p">(</span><span class="nx">current</span><span class="p">,</span> <span class="nx">nextEffect</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 异步调度 useEffect
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">((</span><span class="nx">flags</span> <span class="o">&amp;</span> <span class="nx">Passive</span><span class="p">)</span> <span class="o">!==</span> <span class="nx">NoFlags</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">rootDoesHavePassiveEffects</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">rootDoesHavePassiveEffects</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nx">scheduleCallback</span><span class="p">(</span><span class="nx">NormalSchedulerPriority</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="c1">// 从全局变量 rootWithPendingPassiveEffects 获取 effectList，触发 effect 回调函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="nx">flushPassiveEffects</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">          <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">});</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">nextEffect</span> <span class="o">=</span> <span class="nx">nextEffect</span><span class="p">.</span><span class="nx">nextEffect</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">flushPassiveEffectsImpl() {</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nx">rootWithPendingPassiveEffects</span> <span class="o">===</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">root</span> <span class="o">=</span> <span class="nx">rootWithPendingPassiveEffects</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">lanes</span> <span class="o">=</span> <span class="nx">pendingPassiveEffectsLanes</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">rootWithPendingPassiveEffects</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">pendingPassiveEffectsLanes</span> <span class="o">=</span> <span class="nx">NoLanes</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">prevExecutionContext</span> <span class="o">=</span> <span class="nx">executionContext</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">executionContext</span> <span class="o">|=</span> <span class="nx">CommitContext</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">prevInteractions</span> <span class="o">=</span> <span class="nx">pushInteractions</span><span class="p">(</span><span class="nx">root</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">   * 任何副作用函数被运行之前，应该先运行清理函数
</span></span></span><span class="line"><span class="cl"><span class="cm">   * 否则兄弟组件的副作用可能会相互影响
</span></span></span><span class="line"><span class="cl"><span class="cm">   * 例如，一个组件的销毁函数可能无意间覆盖（另一个组件的副作用设置的）ref 的值
</span></span></span><span class="line"><span class="cl"><span class="cm">   */</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">unmountEffects</span> <span class="o">=</span> <span class="nx">pendingPassiveHookEffectsUnmount</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">pendingPassiveHookEffectsUnmount</span> <span class="o">=</span> <span class="p">[];</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">unmountEffects</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kr">const</span> <span class="nx">effect</span> <span class="o">=</span> <span class="nx">unmountEffects</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="kr">const</span> <span class="nx">fiber</span> <span class="o">=</span> <span class="nx">unmountEffects</span><span class="p">[</span><span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="kr">const</span> <span class="nx">destroy</span> <span class="o">=</span> <span class="nx">effect</span><span class="p">.</span><span class="nx">destroy</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nx">effect</span><span class="p">.</span><span class="nx">destroy</span> <span class="o">=</span> <span class="kc">undefined</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">destroy</span> <span class="o">===</span> <span class="s1">'function'</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">destroy</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">captureCommitPhaseError</span><span class="p">(</span><span class="nx">fiber</span><span class="p">,</span> <span class="nx">error</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">mountEffects</span> <span class="o">=</span> <span class="nx">pendingPassiveHookEffectsMount</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">pendingPassiveHookEffectsMount</span> <span class="o">=</span> <span class="p">[];</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">mountEffects</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kr">const</span> <span class="nx">effect</span> <span class="o">=</span> <span class="nx">mountEffects</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="kr">const</span> <span class="nx">fiber</span> <span class="o">=</span> <span class="nx">mountEffects</span><span class="p">[</span><span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="kr">const</span> <span class="nx">create</span> <span class="o">=</span> <span class="nx">effect</span><span class="p">.</span><span class="nx">create</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="nx">effect</span><span class="p">.</span><span class="nx">destroy</span> <span class="o">=</span> <span class="nx">create</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">captureCommitPhaseError</span><span class="p">(</span><span class="nx">fiber</span><span class="p">,</span> <span class="nx">error</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">effect</span> <span class="o">=</span> <span class="nx">root</span><span class="p">.</span><span class="nx">current</span><span class="p">.</span><span class="nx">firstEffect</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="nx">effect</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kr">const</span> <span class="nx">nextNextEffect</span> <span class="o">=</span> <span class="nx">effect</span><span class="p">.</span><span class="nx">nextEffect</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 移出指针，方便垃圾回收
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">effect</span><span class="p">.</span><span class="nx">nextEffect</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nx">effect</span><span class="p">.</span><span class="nx">flags</span> <span class="o">&amp;</span> <span class="nx">Deletion</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">detachFiberAfterEffects</span><span class="p">(</span><span class="nx">effect</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">effect</span> <span class="o">=</span> <span class="nx">nextNextEffect</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nx">enableSchedulerTracing</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">popInteractions</span><span class="p">(</span><span class="nx">prevInteractions</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nx">finishPendingInteractions</span><span class="p">(</span><span class="nx">root</span><span class="p">,</span> <span class="nx">lanes</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="nx">executionContext</span> <span class="o">=</span> <span class="nx">prevExecutionContext</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">flushSyncCallbackQueue</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="nx">nestedPassiveUpdateCount</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">    <span class="nx">rootWithPendingPassiveEffects</span> <span class="o">===</span> <span class="kc">null</span> <span class="o">?</span> <span class="nx">0</span> : <span class="kt">nestedPassiveUpdateCount</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></tbody></table></div></div><ul><li>mutation（渲染中）：使用 Host API 对视图进行更新；</li></ul><div class="highlight"><div class="chroma"><table class="lntable"><tbody><tr><td class="lntd"><pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span></code></pre></td><td class="lntd"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 1. 调用 commitDetachRef 解绑 ref
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 2. 根据 effectTag 处理 DOM
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 3. 执行 useLayoutEffect 的销毁函数（commitWork 会调用 commitHookEffectListUnmount）
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">commitMutationEffects</span><span class="p">(</span><span class="nx">root</span><span class="p">,</span> <span class="nx">renderPriorityLevel</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 遍历 effectList
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">while</span> <span class="p">(</span><span class="nx">nextEffect</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kr">const</span> <span class="nx">flags</span> <span class="o">=</span> <span class="nx">nextEffect</span><span class="p">.</span><span class="nx">flags</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nx">flags</span> <span class="o">&amp;</span> <span class="nx">ContentReset</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">commitResetTextContent</span><span class="p">(</span><span class="nx">nextEffect</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 更新 ref
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="nx">flags</span> <span class="o">&amp;</span> <span class="nx">Ref</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="kr">const</span> <span class="nx">current</span> <span class="o">=</span> <span class="nx">nextEffect</span><span class="p">.</span><span class="nx">alternate</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="nx">current</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">commitDetachRef</span><span class="p">(</span><span class="nx">current</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 根据 effectTag 处理 DOM
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kr">const</span> <span class="nx">primaryFlags</span> <span class="o">=</span> <span class="nx">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="nx">Placement</span> <span class="o">|</span> <span class="nx">Update</span> <span class="o">|</span> <span class="nx">Deletion</span> <span class="o">|</span> <span class="nx">Hydrating</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">switch</span> <span class="p">(</span><span class="nx">primaryFlags</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 插入 DOM
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">case</span> <span class="nx">Placement</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">         * 获取父级 DOM 节点
</span></span></span><span class="line"><span class="cl"><span class="cm">         * 获取 fiber 的 DOM 兄弟节点（fiber 树和 DOM 树并不是一一对应的）
</span></span></span><span class="line"><span class="cl"><span class="cm">         * 调用 parentNode.insertBefore 或 parentNode.appendChild 执行 DOM 插入操作
</span></span></span><span class="line"><span class="cl"><span class="cm">         */</span>
</span></span><span class="line"><span class="cl">        <span class="nx">commitPlacement</span><span class="p">(</span><span class="nx">nextEffect</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nx">nextEffect</span><span class="p">.</span><span class="nx">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="nx">Placement</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 插入并更新 DOM
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">case</span> <span class="nx">PlacementAndUpdate</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">commitPlacement</span><span class="p">(</span><span class="nx">nextEffect</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nx">nextEffect</span><span class="p">.</span><span class="nx">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="nx">Placement</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kr">const</span> <span class="nx">current</span> <span class="o">=</span> <span class="nx">nextEffect</span><span class="p">.</span><span class="nx">alternate</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nx">commitWork</span><span class="p">(</span><span class="nx">current</span><span class="p">,</span> <span class="nx">nextEffect</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 更新 DOM
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">case</span> <span class="nx">Update</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">         * fiber.tag === FunctionComponent，调用 commitHookEffectListUnmount
</span></span></span><span class="line"><span class="cl"><span class="cm">         * 遍历 effectList，执行所有 useLayoutEffect 的销毁函数
</span></span></span><span class="line"><span class="cl"><span class="cm">         * fiber.tag === HostComponent，调用 commitUpdate
</span></span></span><span class="line"><span class="cl"><span class="cm">         * 在 updateDOMProperties 中将 render 阶段 completeWork 中为 fiber 赋值的 updateQueue 对应的内容渲染在页面上
</span></span></span><span class="line"><span class="cl"><span class="cm">         */</span>
</span></span><span class="line"><span class="cl">        <span class="kr">const</span> <span class="nx">current</span> <span class="o">=</span> <span class="nx">nextEffect</span><span class="p">.</span><span class="nx">alternate</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nx">commitWork</span><span class="p">(</span><span class="nx">current</span><span class="p">,</span> <span class="nx">nextEffect</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 删除 DOM
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">case</span> <span class="nx">Deletion</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">         * 递归调用 fiber 及其子孙 fiber 中 tag === ClassComponent 的 componentWillUnmount 生命周期钩子，从页面移除 fiber 对应的 DOM
</span></span></span><span class="line"><span class="cl"><span class="cm">         * 调度 useLayoutEffect 的销毁函数
</span></span></span><span class="line"><span class="cl"><span class="cm">         * 解绑 ref
</span></span></span><span class="line"><span class="cl"><span class="cm">         */</span>
</span></span><span class="line"><span class="cl">        <span class="nx">commitDeletion</span><span class="p">(</span><span class="nx">root</span><span class="p">,</span> <span class="nx">nextEffect</span><span class="p">,</span> <span class="nx">renderPriorityLevel</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">nextEffect</span> <span class="o">=</span> <span class="nx">nextEffect</span><span class="p">.</span><span class="nx">nextEffect</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></tbody></table></div></div><ul><li>layout（渲染后）：同步调用 componentDidMount/Update。</li></ul><div class="highlight"><div class="chroma"><table class="lntable"><tbody><tr><td class="lntd"><pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span></code></pre></td><td class="lntd"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 1. 调用 commitLayoutEffectOnFiber(commitLifeCycles) 执行相应的生命周期函数
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 2. 调用 commitAttachRef 更新 ref
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 3. 调用 setState 第二个参数
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">commitLayoutEffects</span><span class="p">(</span><span class="nx">root</span><span class="p">,</span> <span class="nx">committedLanes</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="nx">nextEffect</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kr">const</span> <span class="nx">flags</span> <span class="o">=</span> <span class="nx">nextEffect</span><span class="p">.</span><span class="nx">flags</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 调用生命周期钩子和 hook
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="nx">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="nx">Update</span> <span class="o">|</span> <span class="nx">Callback</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="kr">const</span> <span class="nx">current</span> <span class="o">=</span> <span class="nx">nextEffect</span><span class="p">.</span><span class="nx">alternate</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">       * commitLifeCycles 的同名函数
</span></span></span><span class="line"><span class="cl"><span class="cm">       * current === null ? componentDidMount : componentDidUpdate
</span></span></span><span class="line"><span class="cl"><span class="cm">       * 调用 setState 的第二个参数（回调函数）
</span></span></span><span class="line"><span class="cl"><span class="cm">       * 调用 useLayoutEffect 的回调函数（上一次的销毁函数是在 mutation 阶段调用）
</span></span></span><span class="line"><span class="cl"><span class="cm">       * 调度 useEffect 的回调和销毁函数
</span></span></span><span class="line"><span class="cl"><span class="cm">       * ReactDOM.render 的第三个参数（回调函数）
</span></span></span><span class="line"><span class="cl"><span class="cm">       */</span>
</span></span><span class="line"><span class="cl">      <span class="nx">commitLayoutEffectOnFiber</span><span class="p">(</span><span class="nx">root</span><span class="p">,</span> <span class="nx">current</span><span class="p">,</span> <span class="nx">nextEffect</span><span class="p">,</span> <span class="nx">committedLanes</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 赋值 ref
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="nx">flags</span> <span class="o">&amp;</span> <span class="nx">Ref</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">       * 如果 ref 是函数形式，调用回调函数
</span></span></span><span class="line"><span class="cl"><span class="cm">       * 如果 ref 是实例形式，赋值 ref.current
</span></span></span><span class="line"><span class="cl"><span class="cm">       */</span>
</span></span><span class="line"><span class="cl">      <span class="nx">commitAttachRef</span><span class="p">(</span><span class="nx">nextEffect</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">nextEffect</span> <span class="o">=</span> <span class="nx">nextEffect</span><span class="p">.</span><span class="nx">nextEffect</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">commitLifeCycles</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="nx">finishedRoot</span>: <span class="kt">FiberRoot</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">current</span>: <span class="kt">Fiber</span> <span class="o">|</span> <span class="kc">null</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">finishedWork</span>: <span class="kt">Fiber</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">committedLanes</span>: <span class="kt">Lanes</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="o">:</span> <span class="k">void</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">switch</span> <span class="p">(</span><span class="nx">finishedWork</span><span class="p">.</span><span class="nx">tag</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nx">FunctionComponent</span>:
</span></span><span class="line"><span class="cl">    <span class="kt">case</span> <span class="nx">ForwardRef</span>:
</span></span><span class="line"><span class="cl">    <span class="kt">case</span> <span class="nx">SimpleMemoComponent</span>:
</span></span><span class="line"><span class="cl">    <span class="kt">case</span> <span class="nx">Block</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">       * 在 mutation 阶段，LayoutEffects 已经销毁
</span></span></span><span class="line"><span class="cl"><span class="cm">       * 酱紫是为了防止兄弟组件的 Effects 相互干扰
</span></span></span><span class="line"><span class="cl"><span class="cm">       * 调用 useLayoutEffect
</span></span></span><span class="line"><span class="cl"><span class="cm">       */</span>
</span></span><span class="line"><span class="cl">      <span class="nx">commitHookEffectListMount</span><span class="p">(</span><span class="nx">HookLayout</span> <span class="o">|</span> <span class="nx">HookHasEffect</span><span class="p">,</span> <span class="nx">finishedWork</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 调度 useEffect
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="nx">schedulePassiveEffects</span><span class="p">(</span><span class="nx">finishedWork</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nx">ClassComponent</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="kr">const</span> <span class="nx">instance</span> <span class="o">=</span> <span class="nx">finishedWork</span><span class="p">.</span><span class="nx">stateNode</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="nx">finishedWork</span><span class="p">.</span><span class="nx">flags</span> <span class="o">&amp;</span> <span class="nx">Update</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="nx">current</span> <span class="o">===</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="c1">// 执行 componentDidMount
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="nx">instance</span><span class="p">.</span><span class="nx">componentDidMount</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="kr">const</span> <span class="nx">prevProps</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">            <span class="nx">finishedWork</span><span class="p">.</span><span class="nx">elementType</span> <span class="o">===</span> <span class="nx">finishedWork</span><span class="p">.</span><span class="kr">type</span>
</span></span><span class="line"><span class="cl">              <span class="o">?</span> <span class="nx">current.memoizedProps</span>
</span></span><span class="line"><span class="cl">              : <span class="kt">resolveDefaultProps</span><span class="p">(</span><span class="nx">finishedWork</span><span class="p">.</span><span class="kr">type</span><span class="p">,</span> <span class="nx">current</span><span class="p">.</span><span class="nx">memoizedProps</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">          <span class="kr">const</span> <span class="nx">prevState</span> <span class="o">=</span> <span class="nx">current</span><span class="p">.</span><span class="nx">memoizedState</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">          <span class="c1">// 执行 componentDidUpdate
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="nx">instance</span><span class="p">.</span><span class="nx">componentDidUpdate</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="nx">prevProps</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="nx">prevState</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="nx">instance</span><span class="p">.</span><span class="nx">__reactInternalSnapshotBeforeUpdate</span>
</span></span><span class="line"><span class="cl">          <span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 执行 setState 第二个参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="kr">const</span> <span class="nx">updateQueue</span>: <span class="kt">UpdateQueue</span> <span class="o">|</span> <span class="kc">null</span> <span class="o">=</span> <span class="nx">finishedWork</span><span class="p">.</span><span class="nx">updateQueue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="nx">updateQueue</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">commitUpdateQueue</span><span class="p">(</span><span class="nx">finishedWork</span><span class="p">,</span> <span class="nx">updateQueue</span><span class="p">,</span> <span class="nx">instance</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nx">HostRoot</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="kr">const</span> <span class="nx">updateQueue</span>: <span class="kt">UpdateQueue</span> <span class="o">|</span> <span class="kc">null</span> <span class="o">=</span> <span class="nx">finishedWork</span><span class="p">.</span><span class="nx">updateQueue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="nx">updateQueue</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kd">let</span> <span class="nx">instance</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="nx">finishedWork</span><span class="p">.</span><span class="nx">child</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="k">switch</span> <span class="p">(</span><span class="nx">finishedWork</span><span class="p">.</span><span class="nx">child</span><span class="p">.</span><span class="nx">tag</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">case</span> <span class="nx">HostComponent</span>:
</span></span><span class="line"><span class="cl">              <span class="kt">instance</span> <span class="o">=</span> <span class="nx">getPublicInstance</span><span class="p">(</span><span class="nx">finishedWork</span><span class="p">.</span><span class="nx">child</span><span class="p">.</span><span class="nx">stateNode</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">              <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">case</span> <span class="nx">ClassComponent</span>:
</span></span><span class="line"><span class="cl">              <span class="kt">instance</span> <span class="o">=</span> <span class="nx">finishedWork</span><span class="p">.</span><span class="nx">child</span><span class="p">.</span><span class="nx">stateNode</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">              <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">          <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nx">commitUpdateQueue</span><span class="p">(</span><span class="nx">finishedWork</span><span class="p">,</span> <span class="nx">updateQueue</span><span class="p">,</span> <span class="nx">instance</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nx">HostComponent</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="kr">const</span> <span class="nx">instance</span>: <span class="kt">Instance</span> <span class="o">=</span> <span class="nx">finishedWork</span><span class="p">.</span><span class="nx">stateNode</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="nx">current</span> <span class="o">===</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="nx">finishedWork</span><span class="p">.</span><span class="nx">flags</span> <span class="o">&amp;</span> <span class="nx">Update</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kr">const</span> <span class="kr">type</span> <span class="o">=</span> <span class="nx">finishedWork</span><span class="p">.</span><span class="kr">type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kr">const</span> <span class="nx">props</span> <span class="o">=</span> <span class="nx">finishedWork</span><span class="p">.</span><span class="nx">memoizedProps</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nx">commitMount</span><span class="p">(</span><span class="nx">instance</span><span class="p">,</span> <span class="kr">type</span><span class="p">,</span> <span class="nx">props</span><span class="p">,</span> <span class="nx">finishedWork</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nx">SuspenseComponent</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">commitSuspenseHydrationCallbacks</span><span class="p">(</span><span class="nx">finishedRoot</span><span class="p">,</span> <span class="nx">finishedWork</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nx">HostText</span>:
</span></span><span class="line"><span class="cl">    <span class="kt">case</span> <span class="nx">HostPortal</span>:
</span></span><span class="line"><span class="cl">    <span class="kt">case</span> <span class="nx">SuspenseListComponent</span>:
</span></span><span class="line"><span class="cl">    <span class="kt">case</span> <span class="nx">IncompleteClassComponent</span>:
</span></span><span class="line"><span class="cl">    <span class="kt">case</span> <span class="nx">FundamentalComponent</span>:
</span></span><span class="line"><span class="cl">    <span class="kt">case</span> <span class="nx">ScopeComponent</span>:
</span></span><span class="line"><span class="cl">    <span class="kt">case</span> <span class="nx">OffscreenComponent</span>:
</span></span><span class="line"><span class="cl">    <span class="kt">case</span> <span class="nx">LegacyHiddenComponent</span>:
</span></span><span class="line"><span class="cl">      <span class="kt">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></tbody></table></div></div><h2 id="diff">diff</h2><p>diff 发生在 update 阶段（beginWork）；通过 current 树和组件返回的 JSX 对象（VDOM），生成 workInProgress 树；并收集需要更新的 fiber 节点，以寻求更新视图的最优方案；它有以下准则：</p><ul><li>只对同级元素进行 diff；如果一个节点在前后两次更新中跨越了层级，那么不会复用节点；</li><li>两个不同类型的元素会产生出不同的树；卸载旧的（及其子树），创建新的（及其子树）；</li><li>通过设置 key 属性，来告知渲染哪些子元素在不同的渲染下可以保持不变；</li><li>同类型的组件元素，组件实例保持不变；</li><li>同类型的元素，保留节点，更新属性。</li></ul><div class="highlight"><div class="chroma"><table class="lntable"><tbody><tr><td class="lntd"><pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span></code></pre></td><td class="lntd"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="c1">// 给子节点打上 effectTag 并添加到 sideEffectList
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">function</span> <span class="nx">reconcileChildFibers</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="nx">returnFiber</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">currentFirstChild</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">newChild</span><span class="p">,</span> <span class="c1">// JSX 对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">lanes</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">isUnkeyedTopLevelFragment</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">    <span class="k">typeof</span> <span class="nx">newChild</span> <span class="o">===</span> <span class="s1">'object'</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">    <span class="nx">newChild</span> <span class="o">!==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">    <span class="nx">newChild</span><span class="p">.</span><span class="kr">type</span> <span class="o">===</span> <span class="nx">REACT_FRAGMENT_TYPE</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">    <span class="nx">newChild</span><span class="p">.</span><span class="nx">key</span> <span class="o">===</span> <span class="kc">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nx">isUnkeyedTopLevelFragment</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 跳过 React.Fragment
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">newChild</span> <span class="o">=</span> <span class="nx">newChild</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">children</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">isObject</span> <span class="o">=</span> <span class="k">typeof</span> <span class="nx">newChild</span> <span class="o">===</span> <span class="s1">'object'</span> <span class="o">&amp;&amp;</span> <span class="nx">newChild</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// newChild 类型为 object，同级仅有一个节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="nx">isObject</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">switch</span> <span class="p">(</span><span class="nx">newChild</span><span class="p">.</span><span class="nx">$$typeof</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">case</span> <span class="nx">REACT_ELEMENT_TYPE</span><span class="o">:</span> <span class="c1">//...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">case</span> <span class="nx">REACT_PORTAL_TYPE</span><span class="o">:</span> <span class="c1">//...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">case</span> <span class="nx">REACT_LAZY_TYPE</span><span class="o">:</span> <span class="c1">//...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// newChild 类型为 string、number，同级仅有一个节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">newChild</span> <span class="o">===</span> <span class="s1">'string'</span> <span class="o">||</span> <span class="k">typeof</span> <span class="nx">newChild</span> <span class="o">===</span> <span class="s1">'number'</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">placeSingleChild</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="nx">reconcileSingleTextNode</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="nx">returnFiber</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nx">currentFirstChild</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="s1">''</span> <span class="o">+</span> <span class="nx">newChild</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nx">lanes</span>
</span></span><span class="line"><span class="cl">      <span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// newChild 类型为 array，同级有多个节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="nx">isArray</span><span class="p">(</span><span class="nx">newChild</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">reconcileChildrenArray</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="nx">returnFiber</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nx">currentFirstChild</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nx">newChild</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nx">lanes</span>
</span></span><span class="line"><span class="cl">    <span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// newChild 类型为 iterator
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="nx">getIteratorFn</span><span class="p">(</span><span class="nx">newChild</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">reconcileChildrenIterator</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="nx">returnFiber</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nx">currentFirstChild</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nx">newChild</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nx">lanes</span>
</span></span><span class="line"><span class="cl">    <span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nx">isObject</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">throwOnInvalidObjectType</span><span class="p">(</span><span class="nx">returnFiber</span><span class="p">,</span> <span class="nx">newChild</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">newChild</span> <span class="o">===</span> <span class="s1">'undefined'</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">isUnkeyedTopLevelFragment</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 删除节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">return</span> <span class="nx">deleteRemainingChildren</span><span class="p">(</span><span class="nx">returnFiber</span><span class="p">,</span> <span class="nx">currentFirstChild</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></tbody></table></div></div><ul><li>单节点 diff</li></ul><p><img src="/p/react-%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%8B/single-diff.webp" width="1582" height="1218" srcset="/p/react-%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%8B/single-diff_hu8685700834913845887.png 480w, /p/react-%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%8B/single-diff_hu14330508190469908502.png 1024w" class="gallery-image" data-flex-grow="129" data-flex-basis="311px" loading="lazy" alt="" decoding="async"></p><div class="highlight"><div class="chroma"><table class="lntable"><tbody><tr><td class="lntd"><pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span></code></pre></td><td class="lntd"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">reconcileSingleElement</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="nx">returnFiber</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">currentFirstChild</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">element</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">lanes</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">key</span> <span class="o">=</span> <span class="nx">element</span><span class="p">.</span><span class="nx">key</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">child</span> <span class="o">=</span> <span class="nx">currentFirstChild</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 判断是否存在对应的 DOM
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">while</span> <span class="p">(</span><span class="nx">child</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 判断 key 是否相同
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="nx">child</span><span class="p">.</span><span class="nx">key</span> <span class="o">===</span> <span class="nx">key</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">switch</span> <span class="p">(</span><span class="nx">child</span><span class="p">.</span><span class="nx">tag</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="nx">Fragment</span><span class="o">:</span> <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">case</span> <span class="nx">Block</span><span class="o">:</span> <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">default</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="c1">// type 相同表示可以复用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="k">if</span> <span class="p">(</span><span class="nx">child</span><span class="p">.</span><span class="nx">elementType</span> <span class="o">===</span> <span class="nx">element</span><span class="p">.</span><span class="kr">type</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">deleteRemainingChildren</span><span class="p">(</span><span class="nx">returnFiber</span><span class="p">,</span> <span class="nx">child</span><span class="p">.</span><span class="nx">sibling</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="kr">const</span> <span class="nx">existing</span> <span class="o">=</span> <span class="nx">useFiber</span><span class="p">(</span><span class="nx">child</span><span class="p">,</span> <span class="nx">element</span><span class="p">.</span><span class="nx">props</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="nx">existing</span><span class="p">.</span><span class="nx">ref</span> <span class="o">=</span> <span class="nx">coerceRef</span><span class="p">(</span><span class="nx">returnFiber</span><span class="p">,</span> <span class="nx">child</span><span class="p">,</span> <span class="nx">element</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="nx">existing</span><span class="p">.</span><span class="k">return</span> <span class="o">=</span> <span class="nx">returnFiber</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="nx">existing</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">          <span class="p">}</span>
</span></span><span class="line"><span class="cl">          <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// key 相同，但是 type 不相同，删除 fiber 以及兄弟节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="nx">deleteRemainingChildren</span><span class="p">(</span><span class="nx">returnFiber</span><span class="p">,</span> <span class="nx">child</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// key 不相同，不能复用，删除
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="nx">deleteChild</span><span class="p">(</span><span class="nx">returnFiber</span><span class="p">,</span> <span class="nx">child</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 同级兄弟节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">child</span> <span class="o">=</span> <span class="nx">child</span><span class="p">.</span><span class="nx">sibling</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 新建 fiber 并返回
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="nx">element</span><span class="p">.</span><span class="kr">type</span> <span class="o">===</span> <span class="nx">REACT_FRAGMENT_TYPE</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kr">const</span> <span class="nx">created</span> <span class="o">=</span> <span class="nx">createFiberFromFragment</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="nx">element</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">children</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nx">returnFiber</span><span class="p">.</span><span class="nx">mode</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nx">lanes</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nx">element</span><span class="p">.</span><span class="nx">key</span>
</span></span><span class="line"><span class="cl">    <span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nx">created</span><span class="p">.</span><span class="k">return</span> <span class="o">=</span> <span class="nx">returnFiber</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">created</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kr">const</span> <span class="nx">created</span> <span class="o">=</span> <span class="nx">createFiberFromElement</span><span class="p">(</span><span class="nx">element</span><span class="p">,</span> <span class="nx">returnFiber</span><span class="p">.</span><span class="nx">mode</span><span class="p">,</span> <span class="nx">lanes</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nx">created</span><span class="p">.</span><span class="nx">ref</span> <span class="o">=</span> <span class="nx">coerceRef</span><span class="p">(</span><span class="nx">returnFiber</span><span class="p">,</span> <span class="nx">currentFirstChild</span><span class="p">,</span> <span class="nx">element</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nx">created</span><span class="p">.</span><span class="k">return</span> <span class="o">=</span> <span class="nx">returnFiber</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">created</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></tbody></table></div></div><ul><li>多节点 diff：需要处理<strong>节点更新</strong>、<strong>节点新增/减少</strong>、<strong>节点位置变化</strong></li></ul><div class="highlight"><div class="chroma"><table class="lntable"><tbody><tr><td class="lntd"><pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span></code></pre></td><td class="lntd"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">reconcileChildrenArray</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="nx">returnFiber</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">currentFirstChild</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">newChildren</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">lanes</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">   * 这个算法不能通过从两端搜索来优化，和 newChildren 中每个组件相比较的是 currentFiber
</span></span></span><span class="line"><span class="cl"><span class="cm">   * newChildren[0] 与 fiber 比较，newChildren[1] 与 fiber.sibling 比较
</span></span></span><span class="line"><span class="cl"><span class="cm">   */</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">resultingFirstChild</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">previousNewFiber</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">oldFiber</span> <span class="o">=</span> <span class="nx">currentFirstChild</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">lastPlacedIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">newIdx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">nextOldFiber</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 首先遍历 newChildren
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">for</span> <span class="p">(;</span> <span class="nx">oldFiber</span> <span class="o">!==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="nx">newIdx</span> <span class="o">&lt;</span> <span class="nx">newChildren</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">newIdx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nx">oldFiber</span><span class="p">.</span><span class="nx">index</span> <span class="o">&gt;</span> <span class="nx">newIdx</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">nextOldFiber</span> <span class="o">=</span> <span class="nx">oldFiber</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="nx">oldFiber</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">nextOldFiber</span> <span class="o">=</span> <span class="nx">oldFiber</span><span class="p">.</span><span class="nx">sibling</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kr">const</span> <span class="nx">newFiber</span> <span class="o">=</span> <span class="nx">updateSlot</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="nx">returnFiber</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nx">oldFiber</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nx">newChildren</span><span class="p">[</span><span class="nx">newIdx</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">      <span class="nx">lanes</span>
</span></span><span class="line"><span class="cl">    <span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// newChildren 与 oldFiber 同时遍历完了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="nx">newFiber</span> <span class="o">===</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="nx">oldFiber</span> <span class="o">===</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">oldFiber</span> <span class="o">=</span> <span class="nx">nextOldFiber</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nx">shouldTrackSideEffects</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="nx">oldFiber</span> <span class="o">&amp;&amp;</span> <span class="nx">newFiber</span><span class="p">.</span><span class="nx">alternate</span> <span class="o">===</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">deleteChild</span><span class="p">(</span><span class="nx">returnFiber</span><span class="p">,</span> <span class="nx">oldFiber</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">lastPlacedIndex</span> <span class="o">=</span> <span class="nx">placeChild</span><span class="p">(</span><span class="nx">newFiber</span><span class="p">,</span> <span class="nx">lastPlacedIndex</span><span class="p">,</span> <span class="nx">newIdx</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nx">previousNewFiber</span> <span class="o">===</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">resultingFirstChild</span> <span class="o">=</span> <span class="nx">newFiber</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">previousNewFiber</span><span class="p">.</span><span class="nx">sibling</span> <span class="o">=</span> <span class="nx">newFiber</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">previousNewFiber</span> <span class="o">=</span> <span class="nx">newFiber</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nx">oldFiber</span> <span class="o">=</span> <span class="nx">nextOldFiber</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// newChildren 遍历完了，删除剩余的 oldFiber
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="nx">newIdx</span> <span class="o">===</span> <span class="nx">newChildren</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">deleteRemainingChildren</span><span class="p">(</span><span class="nx">returnFiber</span><span class="p">,</span> <span class="nx">oldFiber</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">resultingFirstChild</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// oldFiber 遍历完了，插入剩余的 newChildren
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="nx">oldFiber</span> <span class="o">===</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(;</span> <span class="nx">newIdx</span> <span class="o">&lt;</span> <span class="nx">newChildren</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">newIdx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="kr">const</span> <span class="nx">newFiber</span> <span class="o">=</span> <span class="nx">createChild</span><span class="p">(</span><span class="nx">returnFiber</span><span class="p">,</span> <span class="nx">newChildren</span><span class="p">[</span><span class="nx">newIdx</span><span class="p">],</span> <span class="nx">lanes</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="nx">newFiber</span> <span class="o">===</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="nx">lastPlacedIndex</span> <span class="o">=</span> <span class="nx">placeChild</span><span class="p">(</span><span class="nx">newFiber</span><span class="p">,</span> <span class="nx">lastPlacedIndex</span><span class="p">,</span> <span class="nx">newIdx</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="nx">previousNewFiber</span> <span class="o">===</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">resultingFirstChild</span> <span class="o">=</span> <span class="nx">newFiber</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">previousNewFiber</span><span class="p">.</span><span class="nx">sibling</span> <span class="o">=</span> <span class="nx">newFiber</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="nx">previousNewFiber</span> <span class="o">=</span> <span class="nx">newFiber</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">resultingFirstChild</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// newChildren 与 oldFiber 都没遍历完，将没有处理的 oldFiber 存入 map
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kr">const</span> <span class="nx">existingChildren</span> <span class="o">=</span> <span class="nx">mapRemainingChildren</span><span class="p">(</span><span class="nx">returnFiber</span><span class="p">,</span> <span class="nx">oldFiber</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 遍历剩余的 newChildren，移动节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">for</span> <span class="p">(;</span> <span class="nx">newIdx</span> <span class="o">&lt;</span> <span class="nx">newChildren</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">newIdx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kr">const</span> <span class="nx">newFiber</span> <span class="o">=</span> <span class="nx">updateFromMap</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="nx">existingChildren</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nx">returnFiber</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nx">newIdx</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nx">newChildren</span><span class="p">[</span><span class="nx">newIdx</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">      <span class="nx">lanes</span>
</span></span><span class="line"><span class="cl">    <span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nx">newFiber</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="nx">shouldTrackSideEffects</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="nx">newFiber</span><span class="p">.</span><span class="nx">alternate</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="nx">existingChildren</span><span class="p">.</span><span class="k">delete</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="nx">newFiber</span><span class="p">.</span><span class="nx">key</span> <span class="o">===</span> <span class="kc">null</span> <span class="o">?</span> <span class="nx">newIdx</span> : <span class="kt">newFiber.key</span>
</span></span><span class="line"><span class="cl">          <span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 最后一个可复用的节点在 oldFiber 中的位置索引
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="nx">lastPlacedIndex</span> <span class="o">=</span> <span class="nx">placeChild</span><span class="p">(</span><span class="nx">newFiber</span><span class="p">,</span> <span class="nx">lastPlacedIndex</span><span class="p">,</span> <span class="nx">newIdx</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="nx">previousNewFiber</span> <span class="o">===</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">resultingFirstChild</span> <span class="o">=</span> <span class="nx">newFiber</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">previousNewFiber</span><span class="p">.</span><span class="nx">sibling</span> <span class="o">=</span> <span class="nx">newFiber</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="nx">previousNewFiber</span> <span class="o">=</span> <span class="nx">newFiber</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nx">shouldTrackSideEffects</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 没有消耗的已经存在的 children 都删掉
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">existingChildren</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">child</span> <span class="o">=&gt;</span> <span class="nx">deleteChild</span><span class="p">(</span><span class="nx">returnFiber</span><span class="p">,</span> <span class="nx">child</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">resultingFirstChild</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></tbody></table></div></div><h2 id="fiber">fiber</h2><p>没有 fiber 以前，reconciler 采用<strong>递归</strong>的方式创建虚拟 DOM，这个过程是不能中断的；如果组件树的层级很深，递归会占用线程很多时间，阻塞渲染造成卡顿。为了解决这个问题，React 引入 fiber，重构为了异步的可中断更新：</p><ul><li>fiber 的含义：<ul><li>递归的数据保存在调用栈中，所以被称为 StackReconciler；基于 fiber 的 Reconciler，被称为 FiberReconciler；</li><li>作为静态的数据结构来说，每个 fiber 节点对应一个 React 元素，保存了该组件的类型（函数组件/类组件/原生组件…）、对应的 DOM 节点等信息；</li><li>作为动态的工作单元来说，每个 fiber 节点保存了本次更新中该组件改变的状态、要执行的工作（需要被删除/被插入页面中/被更新…）。</li></ul></li><li>fiber 的目标：<ul><li>能够把可中断的任务切片处理；</li><li>能够调整优先级，重置并复用任务；</li><li>能够在父元素与子元素之间交错处理；</li><li>能够在 render 中返回多个元素；</li><li>更好地支持错误边界。</li></ul></li><li>fiberNode 的生成：通过 createFiber 工厂函数生成 fiberNode 实例；</li></ul><div class="highlight"><div class="chroma"><table class="lntable"><tbody><tr><td class="lntd"><pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span></code></pre></td><td class="lntd"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">createFiber</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="nx">tag</span>: <span class="kt">WorkTag</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">pendingProps</span>: <span class="kt">mixed</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">key</span>: <span class="kt">null</span> <span class="o">|</span> <span class="kt">string</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">mode</span>: <span class="kt">TypeOfMode</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="o">:</span> <span class="nx">Fiber</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="k">new</span> <span class="nx">FiberNode</span><span class="p">(</span><span class="nx">tag</span><span class="p">,</span> <span class="nx">pendingProps</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">mode</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">FiberNode</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="nx">tag</span>: <span class="kt">WorkTag</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">pendingProps</span>: <span class="kt">any</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">key</span>: <span class="kt">null</span> <span class="o">|</span> <span class="kt">string</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">mode</span>: <span class="kt">TypeOfMode</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="o">*</span><span class="err">/</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 作为静态数据结构的属性
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">this</span><span class="p">.</span><span class="nx">elementType</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span> <span class="c1">// 元素类型，大部分情况同 type，某些情况不同，比如 React.memo(FunctionComponent)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">this</span><span class="p">.</span><span class="nx">key</span> <span class="o">=</span> <span class="nx">key</span><span class="p">;</span> <span class="c1">// key 属性，JSX 的 key
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">this</span><span class="p">.</span><span class="nx">stateNode</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span> <span class="c1">// 对应的 DOM、FiberRoot、ComponentInstance；保存了 fiber 相关的局部状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">this</span><span class="p">.</span><span class="nx">tag</span> <span class="o">=</span> <span class="nx">tag</span><span class="p">;</span> <span class="c1">// 对应的组件类型：字符串、函数、class、portal、context、fragment...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">this</span><span class="p">.</span><span class="kr">type</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span> <span class="c1">// 对于函数组件，指函数本身；对于类组件，指 class；对于原生组件，指 DOM 节点的 tagName；用来描述与 FiberNode 相关的 React 元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 用于连接其他 FiberNode 生成「树」形结构
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">this</span><span class="p">.</span><span class="nx">child</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span> <span class="c1">// 指向第一个子级 FiberNode
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">this</span><span class="p">.</span><span class="nx">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 当前 FiberNode 在同级 FiberNode 中的索引
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">this</span><span class="p">.</span><span class="k">return</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span> <span class="c1">// 指向父级 FiberNode
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">this</span><span class="p">.</span><span class="nx">sibling</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span> <span class="c1">// 指向下一个兄弟 FiberNode
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">this</span><span class="p">.</span><span class="nx">dependencies</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span> <span class="c1">// 节点依赖，context 等
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">this</span><span class="p">.</span><span class="nx">memoizedProps</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span> <span class="c1">// 上次渲染期间对应的 props
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">   * 如果是 class 组件，这里保存着多个 state 更新合并之后的最终结果，用于渲染
</span></span></span><span class="line"><span class="cl"><span class="cm">   * 如果是函数组件，这里保存着 Hook 队列：
</span></span></span><span class="line"><span class="cl"><span class="cm">   *    memoizedState 局部状态
</span></span></span><span class="line"><span class="cl"><span class="cm">   *    baseState 基础状态，baseQueue 中的 update 合并之后的结果
</span></span></span><span class="line"><span class="cl"><span class="cm">   *    baseQueue 基础队列，update 形成的环状链表（只包括高于本次渲染优先级的 update）
</span></span></span><span class="line"><span class="cl"><span class="cm">   *    queue 更新队列，包含了所有优先级的 update 构成的环状链表
</span></span></span><span class="line"><span class="cl"><span class="cm">   *    next 指向下一个 Hook（多个 Hook 连成链表）
</span></span></span><span class="line"><span class="cl"><span class="cm">   */</span>
</span></span><span class="line"><span class="cl">  <span class="k">this</span><span class="p">.</span><span class="nx">memoizedState</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">this</span><span class="p">.</span><span class="nx">pendingProps</span> <span class="o">=</span> <span class="nx">pendingProps</span><span class="p">;</span> <span class="c1">// JSX 传入的 props，和 memoizedProps 做比较可以得出 props 的变化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">   * update 队列，链表结构，保存了 stateUpdates、回调、DOMUpdates，都会创建一个 update 对象保存在这里：
</span></span></span><span class="line"><span class="cl"><span class="cm">   *    baseState
</span></span></span><span class="line"><span class="cl"><span class="cm">   *    firstBaseUpdate
</span></span></span><span class="line"><span class="cl"><span class="cm">   *    lastBaseUpdate
</span></span></span><span class="line"><span class="cl"><span class="cm">   *    shared
</span></span></span><span class="line"><span class="cl"><span class="cm">   *    effects，需要执行的副作用，在 commit 阶段会调用
</span></span></span><span class="line"><span class="cl"><span class="cm">   */</span>
</span></span><span class="line"><span class="cl">  <span class="k">this</span><span class="p">.</span><span class="nx">updateQueue</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 保存本次更新会造成的 DOM 操作，需要在 commit 阶段应用到视图上
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">this</span><span class="p">.</span><span class="nx">deletions</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">this</span><span class="p">.</span><span class="nx">flags</span> <span class="o">=</span> <span class="nx">NoFlags</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">this</span><span class="p">.</span><span class="nx">subtreeFlags</span> <span class="o">=</span> <span class="nx">NoFlags</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">   * 调度优先级相关
</span></span></span><span class="line"><span class="cl"><span class="cm">   * 会和 renderLanes 做对比
</span></span></span><span class="line"><span class="cl"><span class="cm">   * 确认本次渲染要不要更新当前节点
</span></span></span><span class="line"><span class="cl"><span class="cm">   */</span>
</span></span><span class="line"><span class="cl">  <span class="k">this</span><span class="p">.</span><span class="nx">childLanes</span> <span class="o">=</span> <span class="nx">NoLanes</span><span class="p">;</span> <span class="c1">// 子节点的优先级
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">this</span><span class="p">.</span><span class="nx">lanes</span> <span class="o">=</span> <span class="nx">NoLanes</span><span class="p">;</span> <span class="c1">// 本节点的优先级
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">   * 指向 current/workInProgress 中对应的 fiber 节点
</span></span></span><span class="line"><span class="cl"><span class="cm">   * currentFiber.alternate === workInProgressFiber
</span></span></span><span class="line"><span class="cl"><span class="cm">   * workInProgressFiber.alternate === currentFiber
</span></span></span><span class="line"><span class="cl"><span class="cm">   * 得益于双缓冲，以 fiber 为基础的 Hook 实现了渲染前后，状态的存续
</span></span></span><span class="line"><span class="cl"><span class="cm">   */</span>
</span></span><span class="line"><span class="cl">  <span class="k">this</span><span class="p">.</span><span class="nx">alternate</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span> <span class="c1">// 双缓冲相关
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">   * mode 有六种模式（React 运行模式，继承与父节点）：
</span></span></span><span class="line"><span class="cl"><span class="cm">   * 0b00000 NoMode             普通模式
</span></span></span><span class="line"><span class="cl"><span class="cm">   * 0b00001 StrictMode         严格模式
</span></span></span><span class="line"><span class="cl"><span class="cm">   * 0b00010 BlockingMode       块模式
</span></span></span><span class="line"><span class="cl"><span class="cm">   * 0b00100 ConcurrentMode     并发模式
</span></span></span><span class="line"><span class="cl"><span class="cm">   * 0b01000 ProfileMode        性能测试模式
</span></span></span><span class="line"><span class="cl"><span class="cm">   * 0b10000 DebugTracingMode   Debug 模式
</span></span></span><span class="line"><span class="cl"><span class="cm">   */</span>
</span></span><span class="line"><span class="cl">  <span class="k">this</span><span class="p">.</span><span class="nx">mode</span> <span class="o">=</span> <span class="nx">mode</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">this</span><span class="p">.</span><span class="nx">ref</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span> <span class="c1">// 就是那个 ref
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></tbody></table></div></div><ul><li>fiberTree 的生成：通过 performUnitOfWork（分为两部分：“递”和“归”）向 workInProgress 添加 fiber 节点；</li></ul><div class="highlight"><div class="chroma"><table class="lntable"><tbody><tr><td class="lntd"><pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span></code></pre></td><td class="lntd"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">ensureRootIsScheduled</span><span class="p">(</span><span class="nx">root</span>: <span class="kt">FiberRoot</span><span class="p">,</span> <span class="nx">currentTime</span>: <span class="kt">number</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">   * 这个方法用来为 fiberRoot 调度任务；每个 fiberRoot 每次只有一个任务
</span></span></span><span class="line"><span class="cl"><span class="cm">   * 如果一个任务已经被调度，将检查以确保现有任务的优先级与下一个级别的优先级相同
</span></span></span><span class="line"><span class="cl"><span class="cm">   * 此函数在每次更新时调用，并且调用恰好发生在退出任务之前
</span></span></span><span class="line"><span class="cl"><span class="cm">   */</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">existingCallbackNode</span> <span class="o">=</span> <span class="nx">root</span><span class="p">.</span><span class="nx">callbackNode</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 检查是否有 lane 处于饥饿状态，如果有就把它标记为过期任务，需要下次更新时执行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">markStarvedLanesAsExpired</span><span class="p">(</span><span class="nx">root</span><span class="p">,</span> <span class="nx">currentTime</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 检测下一个要处理的 lane 和对应的优先级
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kr">const</span> <span class="nx">nextLanes</span> <span class="o">=</span> <span class="nx">getNextLanes</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="nx">root</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">root</span> <span class="o">===</span> <span class="nx">workInProgressRoot</span> <span class="o">?</span> <span class="nx">workInProgressRootRenderLanes</span> : <span class="kt">NoLanes</span>
</span></span><span class="line"><span class="cl">  <span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 返回在“getNextLanes”调用期间计算的优先级
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kr">const</span> <span class="nx">newCallbackPriority</span> <span class="o">=</span> <span class="nx">returnNextLanesPriority</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nx">nextLanes</span> <span class="o">===</span> <span class="nx">NoLanes</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nx">existingCallbackNode</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">cancelCallback</span><span class="p">(</span><span class="nx">existingCallbackNode</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="nx">root</span><span class="p">.</span><span class="nx">callbackNode</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="nx">root</span><span class="p">.</span><span class="nx">callbackPriority</span> <span class="o">=</span> <span class="nx">NoLanePriority</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 对现存任务检查，看是否能被复用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="nx">existingCallbackNode</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kr">const</span> <span class="nx">existingCallbackPriority</span> <span class="o">=</span> <span class="nx">root</span><span class="p">.</span><span class="nx">callbackPriority</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nx">existingCallbackPriority</span> <span class="o">===</span> <span class="nx">newCallbackPriority</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 优先级没改变，可以重复使用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 不能复用任务
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">cancelCallback</span><span class="p">(</span><span class="nx">existingCallbackNode</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 调度回调
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kd">let</span> <span class="nx">newCallbackNode</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nx">newCallbackPriority</span> <span class="o">===</span> <span class="nx">SyncLanePriority</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 特殊情况：同步任务在内部队列里被调度
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">newCallbackNode</span> <span class="o">=</span> <span class="nx">scheduleSyncCallback</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="nx">performSyncWorkOnRoot</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="nx">root</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">newCallbackPriority</span> <span class="o">===</span> <span class="nx">SyncBatchedLanePriority</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 批量同步任务
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">newCallbackNode</span> <span class="o">=</span> <span class="nx">scheduleCallback</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="nx">ImmediateSchedulerPriority</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nx">performSyncWorkOnRoot</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="nx">root</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 并发调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kr">const</span> <span class="nx">schedulerPriorityLevel</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">      <span class="nx">lanePriorityToSchedulerPriority</span><span class="p">(</span><span class="nx">newCallbackPriority</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nx">newCallbackNode</span> <span class="o">=</span> <span class="nx">scheduleCallback</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="nx">schedulerPriorityLevel</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nx">performConcurrentWorkOnRoot</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="nx">root</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="nx">root</span><span class="p">.</span><span class="nx">callbackPriority</span> <span class="o">=</span> <span class="nx">newCallbackPriority</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">root</span><span class="p">.</span><span class="nx">callbackNode</span> <span class="o">=</span> <span class="nx">newCallbackNode</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// ensureRootIsScheduled 调用 performSyncWorkOnRoot 调用 renderRootSync 调用 workLoopSync
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">function</span> <span class="nx">workLoopSync() {</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 已经超时了，不检查当前帧是否还有时间，执行任务
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">while</span> <span class="p">(</span><span class="nx">workInProgress</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">performUnitOfWork</span><span class="p">(</span><span class="nx">workInProgress</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// ensureRootIsScheduled 调用 performConcurrentWorkOnRoot（递归调用自己）调用 renderRootConcurrent 调用 workLoopConcurrent
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">function</span> <span class="nx">workLoopConcurrent() {</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 如果当前帧还有时间，就执行任务，时间切片
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">while</span> <span class="p">(</span><span class="nx">workInProgress</span> <span class="o">!==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">shouldYield</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">performUnitOfWork</span><span class="p">(</span><span class="nx">workInProgress</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 深度优先
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">function</span> <span class="nx">performUnitOfWork</span><span class="p">(</span><span class="nx">unitOfWork</span>: <span class="kt">Fiber</span><span class="p">)</span><span class="o">:</span> <span class="k">void</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">current</span> <span class="o">=</span> <span class="nx">unitOfWork</span><span class="p">.</span><span class="nx">alternate</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// beginWork 总是返回传入节点的子节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kd">let</span> <span class="nx">next</span> <span class="o">=</span> <span class="nx">beginWork</span><span class="p">(</span><span class="nx">current</span><span class="p">,</span> <span class="nx">unitOfWork</span><span class="p">,</span> <span class="nx">subtreeRenderLanes</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nx">unitOfWork</span><span class="p">.</span><span class="nx">memoizedProps</span> <span class="o">=</span> <span class="nx">unitOfWork</span><span class="p">.</span><span class="nx">pendingProps</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nx">next</span> <span class="o">===</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 子节点遍历完了，开始遍历当前子树的兄弟节点并回溯到父节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">completeUnitOfWork</span><span class="p">(</span><span class="nx">unitOfWork</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">workInProgress</span> <span class="o">=</span> <span class="nx">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="nx">ReactCurrentOwner</span><span class="p">.</span><span class="nx">current</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">completeUnitOfWork</span><span class="p">(</span><span class="nx">unitOfWork</span>: <span class="kt">Fiber</span><span class="p">)</span><span class="o">:</span> <span class="k">void</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 完成当前任务，并移至兄弟节点；如果没有兄弟节点，回到父级节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kd">let</span> <span class="nx">completedWork</span> <span class="o">=</span> <span class="nx">unitOfWork</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">do</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kr">const</span> <span class="nx">current</span> <span class="o">=</span> <span class="nx">completedWork</span><span class="p">.</span><span class="nx">alternate</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kr">const</span> <span class="nx">returnFiber</span> <span class="o">=</span> <span class="nx">completedWork</span><span class="p">.</span><span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 检测任务是否完成
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">((</span><span class="nx">completedWork</span><span class="p">.</span><span class="nx">flags</span> <span class="o">&amp;</span> <span class="nx">Incomplete</span><span class="p">)</span> <span class="o">===</span> <span class="nx">NoFlags</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="kd">let</span> <span class="nx">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">((</span><span class="nx">completedWork</span><span class="p">.</span><span class="nx">mode</span> <span class="o">&amp;</span> <span class="nx">ProfileMode</span><span class="p">)</span> <span class="o">===</span> <span class="nx">NoMode</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 关联 fiber 与 DOM，处理事件...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">next</span> <span class="o">=</span> <span class="nx">completeWork</span><span class="p">(</span><span class="nx">current</span><span class="p">,</span> <span class="nx">completedWork</span><span class="p">,</span> <span class="nx">subtreeRenderLanes</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="nx">next</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">workInProgress</span> <span class="o">=</span> <span class="nx">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="kr">const</span> <span class="nx">next</span> <span class="o">=</span> <span class="nx">unwindWork</span><span class="p">(</span><span class="nx">completedWork</span><span class="p">,</span> <span class="nx">subtreeRenderLanes</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="nx">next</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">next</span><span class="p">.</span><span class="nx">flags</span> <span class="o">&amp;=</span> <span class="nx">HostEffectMask</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nx">workInProgress</span> <span class="o">=</span> <span class="nx">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="nx">returnFiber</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">returnFiber</span><span class="p">.</span><span class="nx">flags</span> <span class="o">|=</span> <span class="nx">Incomplete</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nx">returnFiber</span><span class="p">.</span><span class="nx">subtreeFlags</span> <span class="o">=</span> <span class="nx">NoFlags</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nx">returnFiber</span><span class="p">.</span><span class="nx">deletions</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kr">const</span> <span class="nx">siblingFiber</span> <span class="o">=</span> <span class="nx">completedWork</span><span class="p">.</span><span class="nx">sibling</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nx">siblingFiber</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 指向兄弟节点，开始兄弟节点的「递和归」
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="nx">workInProgress</span> <span class="o">=</span> <span class="nx">siblingFiber</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 指向父节点，完成父节点的「归」
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">completedWork</span> <span class="o">=</span> <span class="nx">returnFiber</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nx">workInProgress</span> <span class="o">=</span> <span class="nx">completedWork</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="nx">completedWork</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nx">workInProgressRootExitStatus</span> <span class="o">===</span> <span class="nx">RootIncomplete</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">workInProgressRootExitStatus</span> <span class="o">=</span> <span class="nx">RootCompleted</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></tbody></table></div></div><ul><li>“递”阶段（beginWork）：传入<strong>当前 fiberNode</strong>，创建<strong>子 fiberNode</strong>，根据 VDOM 创建 fiber 树；</li></ul><div class="highlight"><div class="chroma"><table class="lntable"><tbody><tr><td class="lntd"><pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span></code></pre></td><td class="lntd"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 从 rootFiber 开始向下深度优先遍历；为遍历到的每个 fiberNode 调用 beginWork 方法
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 该方法会根据传入的 fiberNode 创建子 fiberNode，并将这两个 fiberNode 连接起来
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 当遍历到“没有子组件的组件”时就会进入“归”阶段
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">beginWork</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="nx">current</span><span class="p">,</span> <span class="c1">// 上一次更新的 fiberNode（workInProgress.alternate）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">workInProgress</span><span class="p">,</span> <span class="c1">// 当前组件对应的 fiberNode
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">renderLanes</span> <span class="c1">// 渲染优先级
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">updateLanes</span> <span class="o">=</span> <span class="nx">workInProgress</span><span class="p">.</span><span class="nx">lanes</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nx">current</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// update 阶段，可以复用节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kr">const</span> <span class="nx">oldProps</span> <span class="o">=</span> <span class="nx">current</span><span class="p">.</span><span class="nx">memoizedProps</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kr">const</span> <span class="nx">newProps</span> <span class="o">=</span> <span class="nx">workInProgress</span><span class="p">.</span><span class="nx">pendingProps</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 节点不能复用的条件（满足任一就不能复用）:
</span></span></span><span class="line"><span class="cl"><span class="cm">     * workInProgress.type !== current.type
</span></span></span><span class="line"><span class="cl"><span class="cm">     * oldProps !== newProps
</span></span></span><span class="line"><span class="cl"><span class="cm">     * hasContextChanged()
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="nx">oldProps</span> <span class="o">!==</span> <span class="nx">newProps</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">      <span class="nx">hasLegacyContextChanged</span><span class="p">()</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">      <span class="nx">workInProgress</span><span class="p">.</span><span class="kr">type</span> <span class="o">!==</span> <span class="nx">current</span><span class="p">.</span><span class="kr">type</span>
</span></span><span class="line"><span class="cl">    <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">didReceiveUpdate</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span> <span class="c1">// type&nbsp;都不一样，复用个鸡
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">includesSomeLane</span><span class="p">(</span><span class="nx">renderLanes</span><span class="p">,</span> <span class="nx">updateLanes</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">didReceiveUpdate</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span> <span class="c1">// 可以复用子节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">switch</span> <span class="p">(</span><span class="nx">workInProgress</span><span class="p">.</span><span class="nx">tag</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="nx">HostRoot</span><span class="o">:</span> <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">case</span> <span class="nx">HostComponent</span><span class="o">:</span> <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">case</span> <span class="nx">ClassComponent</span><span class="o">:</span> <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">case</span> <span class="nx">HostPortal</span><span class="o">:</span> <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">case</span> <span class="nx">ContextProvider</span><span class="o">:</span> <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">case</span> <span class="nx">Profiler</span><span class="o">:</span> <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">case</span> <span class="nx">SuspenseComponent</span><span class="o">:</span> <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">case</span> <span class="nx">SuspenseListComponent</span><span class="o">:</span> <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">case</span> <span class="nx">OffscreenComponent</span><span class="o">:</span> <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">case</span> <span class="nx">LegacyHiddenComponent</span><span class="o">:</span> <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 如果可以复用，略过创建 fiber
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">return</span> <span class="nx">bailoutOnAlreadyFinishedWork</span><span class="p">(</span><span class="nx">current</span><span class="p">,</span> <span class="nx">workInProgress</span><span class="p">,</span> <span class="nx">renderLanes</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">((</span><span class="nx">current</span><span class="p">.</span><span class="nx">flags</span> <span class="o">&amp;</span> <span class="nx">ForceUpdateForLegacySuspense</span><span class="p">)</span> <span class="o">!==</span> <span class="nx">NoFlags</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">didReceiveUpdate</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">didReceiveUpdate</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span> <span class="c1">// 可以复用子节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// mount 阶段，根据 tag 创建节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">didReceiveUpdate</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 设置最高优先级
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">workInProgress</span><span class="p">.</span><span class="nx">lanes</span> <span class="o">=</span> <span class="nx">NoLanes</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">   * 根据 tag 创建不同的 fiber，最终会调用 reconcileChildren
</span></span></span><span class="line"><span class="cl"><span class="cm">   * type + pendingProps + updateQueue +... =&gt; memoizedState
</span></span></span><span class="line"><span class="cl"><span class="cm">   */</span>
</span></span><span class="line"><span class="cl">  <span class="k">switch</span> <span class="p">(</span><span class="nx">workInProgress</span><span class="p">.</span><span class="nx">tag</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nx">IndeterminateComponent</span><span class="o">:</span> <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">case</span> <span class="nx">LazyComponent</span><span class="o">:</span> <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">case</span> <span class="nx">FunctionComponent</span><span class="o">:</span> <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">case</span> <span class="nx">ClassComponent</span><span class="o">:</span> <span class="c1">// 创建实例并指向 fiber.stateNode、执行 render、设置 fiber.flags
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">case</span> <span class="nx">HostRoot</span><span class="o">:</span> <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">case</span> <span class="nx">HostComponent</span><span class="o">:</span> <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">case</span> <span class="nx">HostText</span><span class="o">:</span> <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">case</span> <span class="nx">SuspenseComponent</span><span class="o">:</span> <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">case</span> <span class="nx">HostPortal</span><span class="o">:</span> <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">case</span> <span class="nx">ForwardRef</span><span class="o">:</span> <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">case</span> <span class="nx">Fragment</span><span class="o">:</span> <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">case</span> <span class="nx">Mode</span><span class="o">:</span> <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">case</span> <span class="nx">Profiler</span><span class="o">:</span> <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">case</span> <span class="nx">ContextProvider</span><span class="o">:</span> <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">case</span> <span class="nx">ContextConsumer</span><span class="o">:</span> <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">case</span> <span class="nx">MemoComponent</span><span class="o">:</span> <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">case</span> <span class="nx">SimpleMemoComponent</span><span class="o">:</span> <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">case</span> <span class="nx">IncompleteClassComponent</span><span class="o">:</span> <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">case</span> <span class="nx">SuspenseListComponent</span><span class="o">:</span> <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">case</span> <span class="nx">FundamentalComponent</span><span class="o">:</span> <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">case</span> <span class="nx">ScopeComponent</span><span class="o">:</span> <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">case</span> <span class="nx">Block</span><span class="o">:</span> <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">case</span> <span class="nx">OffscreenComponent</span><span class="o">:</span> <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">case</span> <span class="nx">LegacyHiddenComponent</span><span class="o">:</span> <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></tbody></table></div></div><ul><li>reconcileChildren：reconcileChildFibers 与 mountChildFibers 的区别是会为 fiber 节点打上 effectTag；</li></ul><div class="highlight"><div class="chroma"><table class="lntable"><tbody><tr><td class="lntd"><pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span></code></pre></td><td class="lntd"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kr">export</span> <span class="kd">function</span> <span class="nx">reconcileChildren</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="nx">current</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">workInProgress</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">nextChildren</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">renderLanes</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nx">current</span> <span class="o">===</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * mount 阶段，创建子 fiberNode
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 如果这是一个还没有被渲染的新组件
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 我们不会通过应用最小的副作用来更新它的子集
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 相反，我们会在子集被渲染之前将其全部加入
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 这意味着我们可以通过不跟踪副作用来优化这个调和通道
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="nx">workInProgress</span><span class="p">.</span><span class="nx">child</span> <span class="o">=</span> <span class="nx">mountChildFibers</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="nx">workInProgress</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="kc">null</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nx">nextChildren</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nx">renderLanes</span>
</span></span><span class="line"><span class="cl">    <span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * update 阶段，diff 两棵树上的 fiberNode，进行复用
</span></span></span><span class="line"><span class="cl"><span class="cm">     * reconcileChildFibers 会生成带有 effectTag 属性的 fiberNode
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 如果当前的 current 子节点和 workInProgress 中的相同
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 这说明我们还没有开始对这些子节点进行任何操作
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 所以，我们使用克隆算法来创建所有 children
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="nx">workInProgress</span><span class="p">.</span><span class="nx">child</span> <span class="o">=</span> <span class="nx">reconcileChildFibers</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="nx">workInProgress</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nx">current</span><span class="p">.</span><span class="nx">child</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nx">nextChildren</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nx">renderLanes</span>
</span></span><span class="line"><span class="cl">    <span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 通过 shouldTrackSideEffects 来决定是否打上 effectTag
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">export</span> <span class="kr">const</span> <span class="nx">mountChildFibers</span> <span class="o">=</span> <span class="nx">ChildReconciler</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kr">export</span> <span class="kr">const</span> <span class="nx">reconcileChildFibers</span> <span class="o">=</span> <span class="nx">ChildReconciler</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span>
</span></span></code></pre></td></tr></tbody></table></div></div><ul><li>effectTag：在 commit 阶段告知 renderer 对视图进行何种操作；在首次渲染时，只有 rootFiber 会被打上 Placement，在 commit 阶段进行一次插入操作；</li></ul><div class="highlight"><div class="chroma"><table class="lntable"><tbody><tr><td class="lntd"><pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td><td class="lntd"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kr">export</span> <span class="kr">const</span> <span class="nx">Placement</span> <span class="o">=</span> <span class="cm">/*                    */</span> <span class="mi">0</span><span class="nx">b000000000000000010</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">export</span> <span class="kr">const</span> <span class="nx">Update</span> <span class="o">=</span> <span class="cm">/*                       */</span> <span class="mi">0</span><span class="nx">b000000000000000100</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">export</span> <span class="kr">const</span> <span class="nx">PlacementAndUpdate</span> <span class="o">=</span> <span class="cm">/*           */</span> <span class="mi">0</span><span class="nx">b000000000000000110</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">export</span> <span class="kr">const</span> <span class="nx">Deletion</span> <span class="o">=</span> <span class="cm">/*                     */</span> <span class="mi">0</span><span class="nx">b000000000000001000</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// ...
</span></span></span></code></pre></td></tr></tbody></table></div></div><ul><li>“归”阶段（completeWork）：构建 effectList；</li></ul><div class="highlight"><div class="chroma"><table class="lntable"><tbody><tr><td class="lntd"><pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span></code></pre></td><td class="lntd"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 当某个 fiberNode 执行完 completeWork，如果其存在兄弟 fiberNode（fiber.sibling !== null），会进入其兄弟 fiberNode 的“递”阶段
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 如果不存在兄弟 fiberNode，会进入父级 fiber 的“归”阶段
</span></span></span><span class="line"><span class="cl"><span class="cm"> * “递”和“归”阶段会交错执行，直到“归”到 rootFiber
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">completeWork</span><span class="p">(</span><span class="nx">current</span><span class="p">,</span> <span class="nx">workInProgress</span><span class="p">,</span> <span class="nx">renderLanes</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">newProps</span> <span class="o">=</span> <span class="nx">workInProgress</span><span class="p">.</span><span class="nx">pendingProps</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">switch</span> <span class="p">(</span><span class="nx">workInProgress</span><span class="p">.</span><span class="nx">tag</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nx">IndeterminateComponent</span>:
</span></span><span class="line"><span class="cl">    <span class="kt">case</span> <span class="nx">LazyComponent</span>:
</span></span><span class="line"><span class="cl">    <span class="kt">case</span> <span class="nx">SimpleMemoComponent</span>:
</span></span><span class="line"><span class="cl">    <span class="kt">case</span> <span class="nx">FunctionComponent</span>:
</span></span><span class="line"><span class="cl">    <span class="kt">case</span> <span class="nx">ForwardRef</span>:
</span></span><span class="line"><span class="cl">    <span class="kt">case</span> <span class="nx">Fragment</span>:
</span></span><span class="line"><span class="cl">    <span class="kt">case</span> <span class="nx">Mode</span>:
</span></span><span class="line"><span class="cl">    <span class="kt">case</span> <span class="nx">Profiler</span>:
</span></span><span class="line"><span class="cl">    <span class="kt">case</span> <span class="nx">ContextConsumer</span>:
</span></span><span class="line"><span class="cl">    <span class="kt">case</span> <span class="nx">MemoComponent</span>:
</span></span><span class="line"><span class="cl">      <span class="kt">return</span> <span class="kc">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nx">ClassComponent</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nx">HostRoot</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="nx">updateHostContainer</span><span class="p">(</span><span class="nx">workInProgress</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nx">HostComponent</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">popHostContext</span><span class="p">(</span><span class="nx">workInProgress</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="kr">const</span> <span class="nx">rootContainerInstance</span> <span class="o">=</span> <span class="nx">getRootHostContainer</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="kr">const</span> <span class="kr">type</span> <span class="o">=</span> <span class="nx">workInProgress</span><span class="p">.</span><span class="kr">type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 需要考虑 fiberNode 是否有对应的 DOM 节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">if</span> <span class="p">(</span><span class="nx">current</span> <span class="o">!==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="nx">workInProgress</span><span class="p">.</span><span class="nx">stateNode</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// update 阶段，处理 props
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">updateHostComponent</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">          <span class="nx">current</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">          <span class="nx">workInProgress</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">          <span class="kr">type</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">          <span class="nx">newProps</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">          <span class="nx">rootContainerInstance</span>
</span></span><span class="line"><span class="cl">        <span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// mount 阶段，页面还是空的，会构建离屏 DOM 树
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kr">const</span> <span class="nx">currentHostContext</span> <span class="o">=</span> <span class="nx">getHostContext</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 为 fiberNode 生成对应的 DOM 节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kr">const</span> <span class="nx">instance</span> <span class="o">=</span> <span class="nx">createInstance</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">          <span class="kr">type</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">          <span class="nx">newProps</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">          <span class="nx">rootContainerInstance</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">          <span class="nx">currentHostContext</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">          <span class="nx">workInProgress</span>
</span></span><span class="line"><span class="cl">        <span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">         * 将子孙 DOM 节点插入刚生成的 DOM 节点中
</span></span></span><span class="line"><span class="cl"><span class="cm">         * 每次调用 appendAllChildren 时都会将已生成的子孙 DOM 节点插入当前生成的 DOM 节点下
</span></span></span><span class="line"><span class="cl"><span class="cm">         * 那么当“归”到 rootFiber 时，我们已经有一个构建好的离屏 DOM 树
</span></span></span><span class="line"><span class="cl"><span class="cm">         */</span>
</span></span><span class="line"><span class="cl">        <span class="nx">appendAllChildren</span><span class="p">(</span><span class="nx">instance</span><span class="p">,</span> <span class="nx">workInProgress</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// DOM 节点赋值给 fiber.stateNode
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">workInProgress</span><span class="p">.</span><span class="nx">stateNode</span> <span class="o">=</span> <span class="nx">instance</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 处理 props
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">          <span class="c1">// 设置 DOM 属性，事件处理函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="nx">finalizeInitialChildren</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="nx">instance</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="kr">type</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="nx">newProps</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="nx">rootContainerInstance</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="nx">currentHostContext</span>
</span></span><span class="line"><span class="cl">          <span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="c1">// 打上 flags
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="nx">markUpdate</span><span class="p">(</span><span class="nx">workInProgress</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></tbody></table></div></div><ul><li>effectList：除了构建 workInProgress，completeUnitOfWork 还会将所有存在 effectTag 中的 fiberNode 保存在 effectList 单向链表中（nextEffect 指针指向下一个 fiber，第一个节点为 firstEffect，最后一个节点为 lastEffect），在 commit 阶段，只需要遍历 effectList，执行所有 effect，执行对应的 DOM 操作就好。</li></ul><div class="highlight"><div class="chroma"><table class="lntable"><tbody><tr><td class="lntd"><pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td><td class="lntd"><pre tabindex="0" class="chroma"><code class="language-markdown" data-lang="markdown"><span class="line"><span class="cl">                      nextEffect        nextEffect        nextEffect
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">rootFiber.firstEffect ----------&gt; fiber ----------&gt; fiber ----------&gt; ...
</span></span></code></pre></td></tr></tbody></table></div></div><p>render 阶段之后 fiberRoot 会被传递给 commitRoot，进入 commit 阶段。</p><h2 id="hooks">hooks</h2><p>在 render 的 begin（递）的阶段，会在 mountIndeterminateComponent 中挂载组件：</p><div class="highlight"><div class="chroma"><table class="lntable"><tbody><tr><td class="lntd"><pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span></code></pre></td><td class="lntd"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">mountIndeterminateComponent</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="nx">_current</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">workInProgress</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">Component</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">renderLanes</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kd">let</span> <span class="nx">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">value</span> <span class="o">=</span> <span class="nx">renderWithHooks</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="kc">null</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">workInProgress</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Component</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">props</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">context</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">renderLanes</span>
</span></span><span class="line"><span class="cl">  <span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nx">workInProgress</span><span class="p">.</span><span class="nx">flags</span> <span class="o">|=</span> <span class="nx">PerformedWork</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="o">!</span><span class="nx">disableModulePatternComponents</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">    <span class="k">typeof</span> <span class="nx">value</span> <span class="o">===</span> <span class="s1">'object'</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">    <span class="nx">value</span> <span class="o">!==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">    <span class="k">typeof</span> <span class="nx">value</span><span class="p">.</span><span class="nx">render</span> <span class="o">===</span> <span class="s1">'function'</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">    <span class="nx">value</span><span class="p">.</span><span class="nx">$$typeof</span> <span class="o">===</span> <span class="kc">undefined</span>
</span></span><span class="line"><span class="cl">  <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 类组件逻辑...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 函数组件逻辑...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">workInProgress</span><span class="p">.</span><span class="nx">tag</span> <span class="o">=</span> <span class="nx">FunctionComponent</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nx">reconcileChildren</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="nx">workInProgress</span><span class="p">,</span> <span class="nx">value</span><span class="p">,</span> <span class="nx">renderLanes</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">workInProgress</span><span class="p">.</span><span class="nx">child</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 函数式组件的入口
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">export</span> <span class="kd">function</span> <span class="nx">renderWithHooks</span><span class="p">&lt;</span><span class="nt">Props</span><span class="err">,</span> <span class="na">SecondArg</span><span class="p">&gt;(</span>
</span></span><span class="line"><span class="cl">  <span class="nx">current</span>: <span class="kt">Fiber</span> <span class="o">|</span> <span class="kc">null</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">workInProgress</span>: <span class="kt">Fiber</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">Component</span><span class="o">:</span> <span class="p">(</span><span class="nx">p</span>: <span class="kt">Props</span><span class="p">,</span> <span class="nx">arg</span>: <span class="kt">SecondArg</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kt">any</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">props</span>: <span class="kt">Props</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">secondArg</span>: <span class="kt">SecondArg</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">nextRenderLanes</span>: <span class="kt">Lanes</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="o">:</span> <span class="kt">any</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">renderLanes</span> <span class="o">=</span> <span class="nx">nextRenderLanes</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">currentlyRenderingFiber</span> <span class="o">=</span> <span class="nx">workInProgress</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">   * 类组件中，memoizedState 存放 state
</span></span></span><span class="line"><span class="cl"><span class="cm">   * 函数组件中，memoizedState 以链表的形式存放 hook
</span></span></span><span class="line"><span class="cl"><span class="cm">   */</span>
</span></span><span class="line"><span class="cl">  <span class="nx">workInProgress</span><span class="p">.</span><span class="nx">memoizedState</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">workInProgress</span><span class="p">.</span><span class="nx">updateQueue</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">workInProgress</span><span class="p">.</span><span class="nx">lanes</span> <span class="o">=</span> <span class="nx">NoLanes</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 只有当一个有状态的 hook 被使用时，才可以通过 memoizedState 来区分是 mount 还是 update
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">ReactCurrentDispatcher</span><span class="p">.</span><span class="nx">current</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">    <span class="nx">current</span> <span class="o">===</span> <span class="kc">null</span> <span class="o">||</span> <span class="nx">current</span><span class="p">.</span><span class="nx">memoizedState</span> <span class="o">===</span> <span class="kc">null</span>
</span></span><span class="line"><span class="cl">      <span class="o">?</span> <span class="nx">HooksDispatcherOnMount</span> <span class="c1">// mount 时用的 hook
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="o">:</span> <span class="nx">HooksDispatcherOnUpdate</span><span class="p">;</span> <span class="c1">// update 时用的 hook
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kd">let</span> <span class="nx">children</span> <span class="o">=</span> <span class="nx">Component</span><span class="p">(</span><span class="nx">props</span><span class="p">,</span> <span class="nx">secondArg</span><span class="p">);</span> <span class="c1">// 调用函数组件，组件内 hook 执行，保存到 WIP 上
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 检测渲染阶段的 update
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="nx">didScheduleRenderPhaseUpdateDuringThisPass</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="nx">ReactCurrentDispatcher</span><span class="p">.</span><span class="nx">current</span> <span class="o">=</span> <span class="nx">ContextOnlyDispatcher</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">didRenderTooFewHooks</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">    <span class="nx">currentHook</span> <span class="o">!==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="nx">currentHook</span><span class="p">.</span><span class="nx">next</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">renderLanes</span> <span class="o">=</span> <span class="nx">NoLanes</span><span class="p">;</span> <span class="c1">// 渲染优先级
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">currentlyRenderingFiber</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span> <span class="c1">// 正在渲染的 fiber 节点 -&gt; WIP
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">currentHook</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span> <span class="c1">// current.memoizedState
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">workInProgressHook</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span> <span class="c1">// workInProgress.memoizedState
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">didScheduleRenderPhaseUpdate</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">children</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></tbody></table></div></div><p>内置的 hooks 都是从 ReactCurrentDispatcher.current 上拿的；组件不同阶段，给 ReactCurrentDispatcher.current 赋不同的值：</p><div class="highlight"><div class="chroma"><table class="lntable"><tbody><tr><td class="lntd"><pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span></code></pre></td><td class="lntd"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">resolveDispatcher() {</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">dispatcher</span> <span class="o">=</span> <span class="nx">ReactCurrentDispatcher</span><span class="p">.</span><span class="nx">current</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">invariant</span><span class="p">(</span><span class="nx">dispatcher</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">,</span> <span class="s1">'Hooks 只能在函数组件里调用'</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">dispatcher</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kr">export</span> <span class="kd">function</span> <span class="nx">useState</span><span class="p">&lt;</span><span class="nt">S</span><span class="p">&gt;(</span>
</span></span><span class="line"><span class="cl">  <span class="nx">initialState</span><span class="o">:</span> <span class="p">(()</span> <span class="o">=&gt;</span> <span class="nx">S</span><span class="p">)</span> <span class="o">|</span> <span class="nx">S</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="o">:</span> <span class="p">[</span><span class="nx">S</span><span class="p">,</span> <span class="nx">Dispatch</span><span class="p">&lt;</span><span class="nt">BasicStateAction</span><span class="err">&lt;</span><span class="na">S</span><span class="p">&gt;</span><span class="o">&gt;</span><span class="p">]</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">dispatcher</span> <span class="o">=</span> <span class="nx">resolveDispatcher</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">dispatcher</span><span class="p">.</span><span class="nx">useState</span><span class="p">(</span><span class="nx">initialState</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kr">export</span> <span class="kd">function</span> <span class="nx">useRef</span><span class="p">&lt;</span><span class="nt">T</span><span class="p">&gt;(</span><span class="nx">initialValue</span>: <span class="kt">T</span><span class="p">)</span><span class="o">:</span> <span class="p">{</span> <span class="nx">current</span>: <span class="kt">T</span> <span class="p">}</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">dispatcher</span> <span class="o">=</span> <span class="nx">resolveDispatcher</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">dispatcher</span><span class="p">.</span><span class="nx">useRef</span><span class="p">(</span><span class="nx">initialValue</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kr">export</span> <span class="kd">function</span> <span class="nx">useEffect</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="nx">create</span><span class="o">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">(()</span> <span class="o">=&gt;</span> <span class="k">void</span><span class="p">)</span> <span class="o">|</span> <span class="k">void</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">deps</span>: <span class="kt">Array</span><span class="p">&lt;</span><span class="nt">mixed</span><span class="p">&gt;</span> <span class="o">|</span> <span class="k">void</span> <span class="o">|</span> <span class="kc">null</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="o">:</span> <span class="k">void</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">dispatcher</span> <span class="o">=</span> <span class="nx">resolveDispatcher</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">dispatcher</span><span class="p">.</span><span class="nx">useEffect</span><span class="p">(</span><span class="nx">create</span><span class="p">,</span> <span class="nx">deps</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kr">export</span> <span class="kd">function</span> <span class="nx">useMemo</span><span class="p">&lt;</span><span class="nt">T</span><span class="p">&gt;(</span>
</span></span><span class="line"><span class="cl">  <span class="nx">create</span><span class="o">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">T</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">deps</span>: <span class="kt">Array</span><span class="p">&lt;</span><span class="nt">mixed</span><span class="p">&gt;</span> <span class="o">|</span> <span class="k">void</span> <span class="o">|</span> <span class="kc">null</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="o">:</span> <span class="nx">T</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">dispatcher</span> <span class="o">=</span> <span class="nx">resolveDispatcher</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">dispatcher</span><span class="p">.</span><span class="nx">useMemo</span><span class="p">(</span><span class="nx">create</span><span class="p">,</span> <span class="nx">deps</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">HooksDispatcherOnMount</span>: <span class="kt">Dispatcher</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">readContext</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">useCallback</span>: <span class="kt">mountCallback</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">useContext</span>: <span class="kt">readContext</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">useEffect</span>: <span class="kt">mountEffect</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">useLayoutEffect</span>: <span class="kt">mountLayoutEffect</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">useMemo</span>: <span class="kt">mountMemo</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">useReducer</span>: <span class="kt">mountReducer</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">useRef</span>: <span class="kt">mountRef</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">useState</span>: <span class="kt">mountState</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">HooksDispatcherOnUpdate</span>: <span class="kt">Dispatcher</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">readContext</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">useCallback</span>: <span class="kt">updateCallback</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">useContext</span>: <span class="kt">readContext</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">useEffect</span>: <span class="kt">updateEffect</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">useLayoutEffect</span>: <span class="kt">updateLayoutEffect</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">useMemo</span>: <span class="kt">updateMemo</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">useReducer</span>: <span class="kt">updateReducer</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">useRef</span>: <span class="kt">updateRef</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">useState</span>: <span class="kt">updateState</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></td></tr></tbody></table></div></div><p>函数组件在挂载阶段，内部的每个 hook 都会产生一个对象绑定在 workInProgress.memoizedState 属性上，并形成循环链表结构；挂载阶段对应的 hooks：</p><div class="highlight"><div class="chroma"><table class="lntable"><tbody><tr><td class="lntd"><pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span><span class="lnt">182
</span></code></pre></td><td class="lntd"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">mountState</span><span class="p">&lt;</span><span class="nt">S</span><span class="p">&gt;(</span>
</span></span><span class="line"><span class="cl">  <span class="nx">initialState</span><span class="o">:</span> <span class="p">(()</span> <span class="o">=&gt;</span> <span class="nx">S</span><span class="p">)</span> <span class="o">|</span> <span class="nx">S</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="o">:</span> <span class="p">[</span><span class="nx">S</span><span class="p">,</span> <span class="nx">Dispatch</span><span class="p">&lt;</span><span class="nt">BasicStateAction</span><span class="err">&lt;</span><span class="na">S</span><span class="p">&gt;</span><span class="o">&gt;</span><span class="p">]</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">hook</span> <span class="o">=</span> <span class="nx">mountWorkInProgressHook</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 如果初始状态是一个函数，函数的返回值作为初始状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">initialState</span> <span class="o">===</span> <span class="s1">'function'</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">initialState</span> <span class="o">=</span> <span class="nx">initialState</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 保存初始状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">hook</span><span class="p">.</span><span class="nx">memoizedState</span> <span class="o">=</span> <span class="nx">hook</span><span class="p">.</span><span class="nx">baseState</span> <span class="o">=</span> <span class="nx">initialState</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">queue</span> <span class="o">=</span> <span class="p">(</span><span class="nx">hook</span><span class="p">.</span><span class="nx">queue</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">pending</span>: <span class="kt">null</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">dispatch</span>: <span class="kt">null</span><span class="p">,</span> <span class="c1">// 提交 action 的函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">lastRenderedReducer</span>: <span class="kt">basicStateReducer</span><span class="p">,</span> <span class="c1">// 用于状态更新的 reducer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">lastRenderedState</span>: <span class="kt">initialState</span> <span class="c1">// 自从上次渲染过后，最新的 state
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">});</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 构建 dispatch
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kr">const</span> <span class="nx">dispatch</span>: <span class="kt">Dispatch</span><span class="p">&lt;</span><span class="nt">BasicStateAction</span><span class="err">&lt;</span><span class="na">S</span><span class="p">&gt;</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">(</span><span class="nx">queue</span><span class="p">.</span><span class="nx">dispatch</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">    <span class="nx">dispatchAction</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="nx">currentlyRenderingFiber</span><span class="p">,</span> <span class="nx">queue</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 返回 [abc, setABC]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">return</span> <span class="p">[</span><span class="nx">hook</span><span class="p">.</span><span class="nx">memoizedState</span><span class="p">,</span> <span class="nx">dispatch</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * useState 是 useReducer 的特例
</span></span></span><span class="line"><span class="cl"><span class="cm"> * dispatch({ count: 1 }); // 1.直接设置
</span></span></span><span class="line"><span class="cl"><span class="cm"> * dispatch((state) =&gt; ({ count: state.count + 1 })); // 2.通过回调函数设置
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">basicStateReducer</span><span class="p">&lt;</span><span class="nt">S</span><span class="p">&gt;(</span><span class="nx">state</span>: <span class="kt">S</span><span class="p">,</span> <span class="nx">action</span>: <span class="kt">BasicStateAction</span><span class="p">&lt;</span><span class="nt">S</span><span class="p">&gt;)</span><span class="o">:</span> <span class="nx">S</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="k">typeof</span> <span class="nx">action</span> <span class="o">===</span> <span class="s1">'function'</span> <span class="o">?</span> <span class="nx">action</span><span class="p">(</span><span class="nx">state</span><span class="p">)</span> <span class="o">:</span> <span class="nx">action</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 组件第一次渲染，hooks 都会调用 mountWorkInProgressHook
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">function</span> <span class="nx">mountWorkInProgressHook</span><span class="p">()</span><span class="o">:</span> <span class="nx">Hook</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">hook</span>: <span class="kt">Hook</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">memoizedState</span>: <span class="kt">null</span><span class="p">,</span> <span class="c1">// 保存 hooks 信息（state、effect、dep、ref 等）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">baseState</span>: <span class="kt">null</span><span class="p">,</span> <span class="c1">// 当前最新 state
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">baseQueue</span>: <span class="kt">null</span><span class="p">,</span> <span class="c1">// 当前最新更新队列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">queue</span>: <span class="kt">null</span><span class="p">,</span> <span class="c1">// 待更新队列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">next</span>: <span class="kt">null</span> <span class="c1">// 链表指针，链表的存在导致 hooks 不能在条件语句中调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">};</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 构建链表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="nx">workInProgressHook</span> <span class="o">===</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">currentlyRenderingFiber</span><span class="p">.</span><span class="nx">memoizedState</span> <span class="o">=</span> <span class="nx">workInProgressHook</span> <span class="o">=</span> <span class="nx">hook</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">workInProgressHook</span> <span class="o">=</span> <span class="nx">workInProgressHook</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">hook</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">workInProgressHook</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// mountState 内的 dispatch
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">function</span> <span class="nx">dispatchAction</span><span class="p">&lt;</span><span class="nt">S</span><span class="err">,</span> <span class="na">A</span><span class="p">&gt;(</span>
</span></span><span class="line"><span class="cl">  <span class="nx">fiber</span>: <span class="kt">Fiber</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">queue</span>: <span class="kt">UpdateQueue</span><span class="p">&lt;</span><span class="nt">S</span><span class="err">,</span> <span class="na">A</span><span class="p">&gt;,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">action</span>: <span class="kt">A</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">eventTime</span> <span class="o">=</span> <span class="nx">requestEventTime</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">lane</span> <span class="o">=</span> <span class="nx">requestUpdateLane</span><span class="p">(</span><span class="nx">fiber</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 创建 update 对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kr">const</span> <span class="nx">update</span>: <span class="kt">Update</span><span class="p">&lt;</span><span class="nt">S</span><span class="err">,</span> <span class="na">A</span><span class="p">&gt;</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">lane</span><span class="p">,</span> <span class="c1">// 更新优先级
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">action</span><span class="p">,</span> <span class="c1">// 新提交的状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">eagerReducer</span>: <span class="kt">null</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">eagerState</span>: <span class="kt">null</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">next</span>: <span class="kt">null</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 将更新添加到 queue.pending
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kr">const</span> <span class="nx">pending</span> <span class="o">=</span> <span class="nx">queue</span><span class="p">.</span><span class="nx">pending</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nx">pending</span> <span class="o">===</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 这是第一个更新，创建循环链表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">update</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">update</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">update</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">pending</span><span class="p">.</span><span class="nx">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nx">pending</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">update</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="nx">queue</span><span class="p">.</span><span class="nx">pending</span> <span class="o">=</span> <span class="nx">update</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">alternate</span> <span class="o">=</span> <span class="nx">fiber</span><span class="p">.</span><span class="nx">alternate</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="nx">fiber</span> <span class="o">===</span> <span class="nx">currentlyRenderingFiber</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="nx">alternate</span> <span class="o">!==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="nx">alternate</span> <span class="o">===</span> <span class="nx">currentlyRenderingFiber</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 发生在渲染阶段的更新
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">didScheduleRenderPhaseUpdateDuringThisPass</span> <span class="o">=</span> <span class="nx">didScheduleRenderPhaseUpdate</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">      <span class="kc">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="nx">fiber</span><span class="p">.</span><span class="nx">lanes</span> <span class="o">===</span> <span class="nx">NoLanes</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">      <span class="p">(</span><span class="nx">alternate</span> <span class="o">===</span> <span class="kc">null</span> <span class="o">||</span> <span class="nx">alternate</span><span class="p">.</span><span class="nx">lanes</span> <span class="o">===</span> <span class="nx">NoLanes</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">       * 队列当前是空的；在进入下一次渲染之前，可以计算下一个状态
</span></span></span><span class="line"><span class="cl"><span class="cm">       * 如果新的状态和当前状态一致，可以跳过更新（两次 useState 值相等就不渲染）
</span></span></span><span class="line"><span class="cl"><span class="cm">       */</span>
</span></span><span class="line"><span class="cl">      <span class="kr">const</span> <span class="nx">lastRenderedReducer</span> <span class="o">=</span> <span class="nx">queue</span><span class="p">.</span><span class="nx">lastRenderedReducer</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="nx">lastRenderedReducer</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kd">let</span> <span class="nx">prevDispatcher</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="kr">const</span> <span class="nx">currentState</span>: <span class="kt">S</span> <span class="o">=</span> <span class="nx">queue</span><span class="p">.</span><span class="nx">lastRenderedState</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">          <span class="kr">const</span> <span class="nx">eagerState</span> <span class="o">=</span> <span class="nx">lastRenderedReducer</span><span class="p">(</span><span class="nx">currentState</span><span class="p">,</span> <span class="nx">action</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">          <span class="nx">update</span><span class="p">.</span><span class="nx">eagerReducer</span> <span class="o">=</span> <span class="nx">lastRenderedReducer</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">          <span class="nx">update</span><span class="p">.</span><span class="nx">eagerState</span> <span class="o">=</span> <span class="nx">eagerState</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">          <span class="k">if</span> <span class="p">(</span><span class="k">is</span><span class="p">(</span><span class="nx">eagerState</span><span class="p">,</span> <span class="nx">currentState</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">          <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">finally</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 调度更新
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">scheduleUpdateOnFiber</span><span class="p">(</span><span class="nx">fiber</span><span class="p">,</span> <span class="nx">lane</span><span class="p">,</span> <span class="nx">eventTime</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">mountEffect</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="nx">create</span><span class="o">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">(()</span> <span class="o">=&gt;</span> <span class="k">void</span><span class="p">)</span> <span class="o">|</span> <span class="k">void</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">deps</span>: <span class="kt">Array</span><span class="p">&lt;</span><span class="nt">mixed</span><span class="p">&gt;</span> <span class="o">|</span> <span class="k">void</span> <span class="o">|</span> <span class="kc">null</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="o">:</span> <span class="k">void</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 内部也会调用 mountWorkInProgressHook
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">return</span> <span class="nx">mountEffectImpl</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="nx">PassiveEffect</span> <span class="o">|</span> <span class="nx">PassiveStaticEffect</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">HookPassive</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">create</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">deps</span>
</span></span><span class="line"><span class="cl">  <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// mountEffect 内的 mountEffectImpl 还是会调用 mountWorkInProgressHook
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">function</span> <span class="nx">mountEffectImpl</span><span class="p">(</span><span class="nx">fiberFlags</span><span class="p">,</span> <span class="nx">hookFlags</span><span class="p">,</span> <span class="nx">create</span><span class="p">,</span> <span class="nx">deps</span><span class="p">)</span><span class="o">:</span> <span class="k">void</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">hook</span> <span class="o">=</span> <span class="nx">mountWorkInProgressHook</span><span class="p">();</span> <span class="c1">// 创建 Hook
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kr">const</span> <span class="nx">nextDeps</span> <span class="o">=</span> <span class="nx">deps</span> <span class="o">===</span> <span class="kc">undefined</span> <span class="o">?</span> <span class="kc">null</span> <span class="o">:</span> <span class="nx">deps</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">currentlyRenderingFiber</span><span class="p">.</span><span class="nx">flags</span> <span class="o">|=</span> <span class="nx">fiberFlags</span><span class="p">;</span> <span class="c1">// 设置 flags
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 添加到 memoizedState 中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">hook</span><span class="p">.</span><span class="nx">memoizedState</span> <span class="o">=</span> <span class="nx">pushEffect</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="nx">HookHasEffect</span> <span class="o">|</span> <span class="nx">hookFlags</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">create</span><span class="p">,</span> <span class="c1">// 副作用函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kc">undefined</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">nextDeps</span> <span class="c1">// Dep 依赖
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// mountEffect 内的 mountEffectImpl 也会调用 pushEffect
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">function</span> <span class="nx">pushEffect</span><span class="p">(</span><span class="nx">tag</span><span class="p">,</span> <span class="nx">create</span><span class="p">,</span> <span class="nx">destroy</span><span class="p">,</span> <span class="nx">deps</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 创建 Effect
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kr">const</span> <span class="nx">effect</span>: <span class="kt">Effect</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">tag</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">create</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">destroy</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">deps</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">next</span>: <span class="kt">null</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">componentUpdateQueue</span>: <span class="kt">null</span> <span class="o">|</span> <span class="nx">FunctionComponentUpdateQueue</span> <span class="o">=</span> <span class="p">(</span><span class="nx">currentlyRenderingFiber.updateQueue</span>: <span class="kt">any</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nx">componentUpdateQueue</span> <span class="o">===</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 第一个 useEffect，创建更新队列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">componentUpdateQueue</span> <span class="o">=</span> <span class="nx">createFunctionComponentUpdateQueue</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="nx">currentlyRenderingFiber</span><span class="p">.</span><span class="nx">updateQueue</span> <span class="o">=</span> <span class="p">(</span><span class="nx">componentUpdateQueue</span>: <span class="kt">any</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nx">componentUpdateQueue</span><span class="p">.</span><span class="nx">lastEffect</span> <span class="o">=</span> <span class="nx">effect</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">effect</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 多个 useEffect
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kr">const</span> <span class="nx">lastEffect</span> <span class="o">=</span> <span class="nx">componentUpdateQueue</span><span class="p">.</span><span class="nx">lastEffect</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nx">lastEffect</span> <span class="o">===</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">componentUpdateQueue</span><span class="p">.</span><span class="nx">lastEffect</span> <span class="o">=</span> <span class="nx">effect</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">effect</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="kr">const</span> <span class="nx">firstEffect</span> <span class="o">=</span> <span class="nx">lastEffect</span><span class="p">.</span><span class="nx">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="nx">lastEffect</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">effect</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="nx">effect</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">firstEffect</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="nx">componentUpdateQueue</span><span class="p">.</span><span class="nx">lastEffect</span> <span class="o">=</span> <span class="nx">effect</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">effect</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">mountMemo</span><span class="p">&lt;</span><span class="nt">T</span><span class="p">&gt;(</span>
</span></span><span class="line"><span class="cl">  <span class="nx">nextCreate</span><span class="o">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">T</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">deps</span>: <span class="kt">Array</span><span class="p">&lt;</span><span class="nt">mixed</span><span class="p">&gt;</span> <span class="o">|</span> <span class="k">void</span> <span class="o">|</span> <span class="kc">null</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="o">:</span> <span class="nx">T</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">hook</span> <span class="o">=</span> <span class="nx">mountWorkInProgressHook</span><span class="p">();</span> <span class="c1">// 创建一个 hook
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kr">const</span> <span class="nx">nextDeps</span> <span class="o">=</span> <span class="nx">deps</span> <span class="o">===</span> <span class="kc">undefined</span> <span class="o">?</span> <span class="kc">null</span> <span class="o">:</span> <span class="nx">deps</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">nextValue</span> <span class="o">=</span> <span class="nx">nextCreate</span><span class="p">();</span> <span class="c1">// 获取传入函数的返回值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">hook</span><span class="p">.</span><span class="nx">memoizedState</span> <span class="o">=</span> <span class="p">[</span><span class="nx">nextValue</span><span class="p">,</span> <span class="nx">nextDeps</span><span class="p">];</span> <span class="c1">// 在 hook 上保存新的值就好
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">return</span> <span class="nx">nextValue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">mountRef</span><span class="p">&lt;</span><span class="nt">T</span><span class="p">&gt;(</span><span class="nx">initialValue</span>: <span class="kt">T</span><span class="p">)</span><span class="o">:</span> <span class="p">{</span> <span class="nx">current</span>: <span class="kt">T</span> <span class="p">}</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">hook</span> <span class="o">=</span> <span class="nx">mountWorkInProgressHook</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 保存初始化的值，反正后续更新，需要手动给 current 赋值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kr">const</span> <span class="nx">ref</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">current</span>: <span class="kt">initialValue</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">  <span class="nx">hook</span><span class="p">.</span><span class="nx">memoizedState</span> <span class="o">=</span> <span class="nx">ref</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">ref</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></tbody></table></div></div><p>更新阶段对应的 hooks：</p><div class="highlight"><div class="chroma"><table class="lntable"><tbody><tr><td class="lntd"><pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span><span class="lnt">182
</span><span class="lnt">183
</span><span class="lnt">184
</span><span class="lnt">185
</span><span class="lnt">186
</span><span class="lnt">187
</span><span class="lnt">188
</span><span class="lnt">189
</span><span class="lnt">190
</span><span class="lnt">191
</span><span class="lnt">192
</span><span class="lnt">193
</span><span class="lnt">194
</span><span class="lnt">195
</span><span class="lnt">196
</span><span class="lnt">197
</span><span class="lnt">198
</span><span class="lnt">199
</span></code></pre></td><td class="lntd"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="c1">// 在更新或者渲染阶段，更新触发的重新渲染都会调用此函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">function</span> <span class="nx">updateWorkInProgressHook</span><span class="p">()</span><span class="o">:</span> <span class="nx">Hook</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 通过 nextCurrentHook 拿到 current 中的 Hook 状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kd">let</span> <span class="nx">nextCurrentHook</span>: <span class="kt">null</span> <span class="o">|</span> <span class="nx">Hook</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nx">currentHook</span> <span class="o">===</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kr">const</span> <span class="nx">current</span> <span class="o">=</span> <span class="nx">currentlyRenderingFiber</span><span class="p">.</span><span class="nx">alternate</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nx">current</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">nextCurrentHook</span> <span class="o">=</span> <span class="nx">current</span><span class="p">.</span><span class="nx">memoizedState</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">nextCurrentHook</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">nextCurrentHook</span> <span class="o">=</span> <span class="nx">currentHook</span><span class="p">.</span><span class="nx">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">nextWorkInProgressHook</span>: <span class="kt">null</span> <span class="o">|</span> <span class="nx">Hook</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nx">workInProgressHook</span> <span class="o">===</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">nextWorkInProgressHook</span> <span class="o">=</span> <span class="nx">currentlyRenderingFiber</span><span class="p">.</span><span class="nx">memoizedState</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">nextWorkInProgressHook</span> <span class="o">=</span> <span class="nx">workInProgressHook</span><span class="p">.</span><span class="nx">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nx">nextWorkInProgressHook</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 复用 Hook，状态不会丢失
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">workInProgressHook</span> <span class="o">=</span> <span class="nx">nextWorkInProgressHook</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nx">nextWorkInProgressHook</span> <span class="o">=</span> <span class="nx">workInProgressHook</span><span class="p">.</span><span class="nx">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nx">currentHook</span> <span class="o">=</span> <span class="nx">nextCurrentHook</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">currentHook</span> <span class="o">=</span> <span class="nx">nextCurrentHook</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kr">const</span> <span class="nx">newHook</span>: <span class="kt">Hook</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">memoizedState</span>: <span class="kt">currentHook.memoizedState</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nx">baseState</span>: <span class="kt">currentHook.baseState</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nx">baseQueue</span>: <span class="kt">currentHook.baseQueue</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nx">queue</span>: <span class="kt">currentHook.queue</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nx">next</span>: <span class="kt">null</span>
</span></span><span class="line"><span class="cl">    <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nx">workInProgressHook</span> <span class="o">===</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">currentlyRenderingFiber</span><span class="p">.</span><span class="nx">memoizedState</span> <span class="o">=</span> <span class="nx">workInProgressHook</span> <span class="o">=</span> <span class="nx">newHook</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">workInProgressHook</span> <span class="o">=</span> <span class="nx">workInProgressHook</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">newHook</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">workInProgressHook</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">updateState</span><span class="p">&lt;</span><span class="nt">S</span><span class="p">&gt;(</span>
</span></span><span class="line"><span class="cl">  <span class="nx">initialState</span><span class="o">:</span> <span class="p">(()</span> <span class="o">=&gt;</span> <span class="nx">S</span><span class="p">)</span> <span class="o">|</span> <span class="nx">S</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="o">:</span> <span class="p">[</span><span class="nx">S</span><span class="p">,</span> <span class="nx">Dispatch</span><span class="p">&lt;</span><span class="nt">BasicStateAction</span><span class="err">&lt;</span><span class="na">S</span><span class="p">&gt;</span><span class="o">&gt;</span><span class="p">]</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 内部也会调用 updateWorkInProgressHook
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">return</span> <span class="nx">updateReducer</span><span class="p">(</span><span class="nx">basicStateReducer</span><span class="p">,</span> <span class="nx">initialState</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">updateReducer</span><span class="p">&lt;</span><span class="nt">S</span><span class="err">,</span> <span class="na">I</span><span class="err">,</span> <span class="na">A</span><span class="p">&gt;(</span>
</span></span><span class="line"><span class="cl">  <span class="nx">reducer</span><span class="o">:</span> <span class="p">(</span><span class="nx">S</span><span class="p">,</span> <span class="nx">A</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">S</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">initialArg</span>: <span class="kt">I</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">init</span><span class="o">?:</span> <span class="p">(</span><span class="nx">I</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">S</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="o">:</span> <span class="p">[</span><span class="nx">S</span><span class="p">,</span> <span class="nx">Dispatch</span><span class="p">&lt;</span><span class="nt">A</span><span class="p">&gt;]</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">hook</span> <span class="o">=</span> <span class="nx">updateWorkInProgressHook</span><span class="p">();</span> <span class="c1">// 获取 WIPHook
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kr">const</span> <span class="nx">queue</span> <span class="o">=</span> <span class="nx">hook</span><span class="p">.</span><span class="nx">queue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">queue</span><span class="p">.</span><span class="nx">lastRenderedReducer</span> <span class="o">=</span> <span class="nx">reducer</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">current</span>: <span class="kt">Hook</span> <span class="o">=</span> <span class="nx">currentHook</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">baseQueue</span> <span class="o">=</span> <span class="nx">current</span><span class="p">.</span><span class="nx">baseQueue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 上次还没处理完的待处理更新
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kr">const</span> <span class="nx">pendingQueue</span> <span class="o">=</span> <span class="nx">queue</span><span class="p">.</span><span class="nx">pending</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nx">pendingQueue</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 还没来得及处理的新的更新，将他们添加到「基」队列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="nx">baseQueue</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 合并待处理队列和「基」队列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="kr">const</span> <span class="nx">baseFirst</span> <span class="o">=</span> <span class="nx">baseQueue</span><span class="p">.</span><span class="nx">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="kr">const</span> <span class="nx">pendingFirst</span> <span class="o">=</span> <span class="nx">pendingQueue</span><span class="p">.</span><span class="nx">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="nx">baseQueue</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">pendingFirst</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="nx">pendingQueue</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">baseFirst</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">current</span><span class="p">.</span><span class="nx">baseQueue</span> <span class="o">=</span> <span class="nx">baseQueue</span> <span class="o">=</span> <span class="nx">pendingQueue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nx">queue</span><span class="p">.</span><span class="nx">pending</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nx">baseQueue</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 状态计算
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kr">const</span> <span class="nx">first</span> <span class="o">=</span> <span class="nx">baseQueue</span><span class="p">.</span><span class="nx">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">let</span> <span class="nx">newState</span> <span class="o">=</span> <span class="nx">current</span><span class="p">.</span><span class="nx">baseState</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">let</span> <span class="nx">newBaseState</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">let</span> <span class="nx">newBaseQueueFirst</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">let</span> <span class="nx">newBaseQueueLast</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">let</span> <span class="nx">update</span> <span class="o">=</span> <span class="nx">first</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">do</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="kr">const</span> <span class="nx">updateLane</span> <span class="o">=</span> <span class="nx">update</span><span class="p">.</span><span class="nx">lane</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">isSubsetOfLanes</span><span class="p">(</span><span class="nx">renderLanes</span><span class="p">,</span> <span class="nx">updateLane</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 优先级不够，跳过更新
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kr">const</span> <span class="nx">clone</span>: <span class="kt">Update</span><span class="p">&lt;</span><span class="nt">S</span><span class="err">,</span> <span class="na">A</span><span class="p">&gt;</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="nx">lane</span>: <span class="kt">updateLane</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">          <span class="nx">action</span>: <span class="kt">update.action</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">          <span class="nx">eagerReducer</span>: <span class="kt">update.eagerReducer</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">          <span class="nx">eagerState</span>: <span class="kt">update.eagerState</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">          <span class="nx">next</span>: <span class="kt">null</span>
</span></span><span class="line"><span class="cl">        <span class="p">};</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="nx">newBaseQueueLast</span> <span class="o">===</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="nx">newBaseQueueFirst</span> <span class="o">=</span> <span class="nx">newBaseQueueLast</span> <span class="o">=</span> <span class="nx">clone</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">          <span class="nx">newBaseState</span> <span class="o">=</span> <span class="nx">newState</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="nx">newBaseQueueLast</span> <span class="o">=</span> <span class="nx">newBaseQueueLast</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">clone</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 更新队列优先级
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">currentlyRenderingFiber</span><span class="p">.</span><span class="nx">lanes</span> <span class="o">=</span> <span class="nx">mergeLanes</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">          <span class="nx">currentlyRenderingFiber</span><span class="p">.</span><span class="nx">lanes</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">          <span class="nx">updateLane</span>
</span></span><span class="line"><span class="cl">        <span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nx">markSkippedUpdateLanes</span><span class="p">(</span><span class="nx">updateLane</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 更新有足够的优先级
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="nx">newBaseQueueLast</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="kr">const</span> <span class="nx">clone</span>: <span class="kt">Update</span><span class="p">&lt;</span><span class="nt">S</span><span class="err">,</span> <span class="na">A</span><span class="p">&gt;</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 更新将被提交
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">lane</span>: <span class="kt">NoLane</span><span class="p">,</span> <span class="c1">// 所有掩码的子集
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">action</span>: <span class="kt">update.action</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="nx">eagerReducer</span>: <span class="kt">update.eagerReducer</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="nx">eagerState</span>: <span class="kt">update.eagerState</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="nx">next</span>: <span class="kt">null</span>
</span></span><span class="line"><span class="cl">          <span class="p">};</span>
</span></span><span class="line"><span class="cl">          <span class="nx">newBaseQueueLast</span> <span class="o">=</span> <span class="nx">newBaseQueueLast</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">clone</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 处理更新
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="nx">update</span><span class="p">.</span><span class="nx">eagerReducer</span> <span class="o">===</span> <span class="nx">reducer</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="nx">newState</span> <span class="o">=</span> <span class="nx">update</span><span class="p">.</span><span class="nx">eagerState</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="kr">const</span> <span class="nx">action</span> <span class="o">=</span> <span class="nx">update</span><span class="p">.</span><span class="nx">action</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">          <span class="nx">newState</span> <span class="o">=</span> <span class="nx">reducer</span><span class="p">(</span><span class="nx">newState</span><span class="p">,</span> <span class="nx">action</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="nx">update</span> <span class="o">=</span> <span class="nx">update</span><span class="p">.</span><span class="nx">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="nx">update</span> <span class="o">!==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="nx">update</span> <span class="o">!==</span> <span class="nx">first</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nx">newBaseQueueLast</span> <span class="o">===</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">newBaseState</span> <span class="o">=</span> <span class="nx">newState</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">newBaseQueueLast</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">newBaseQueueFirst</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="k">is</span><span class="p">(</span><span class="nx">newState</span><span class="p">,</span> <span class="nx">hook</span><span class="p">.</span><span class="nx">memoizedState</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">markWorkInProgressReceivedUpdate</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 更新 WIPHook
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">hook</span><span class="p">.</span><span class="nx">memoizedState</span> <span class="o">=</span> <span class="nx">newState</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nx">hook</span><span class="p">.</span><span class="nx">baseState</span> <span class="o">=</span> <span class="nx">newBaseState</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nx">hook</span><span class="p">.</span><span class="nx">baseQueue</span> <span class="o">=</span> <span class="nx">newBaseQueueLast</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nx">queue</span><span class="p">.</span><span class="nx">lastRenderedState</span> <span class="o">=</span> <span class="nx">newState</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">dispatch</span>: <span class="kt">Dispatch</span><span class="p">&lt;</span><span class="nt">A</span><span class="p">&gt;</span> <span class="o">=</span> <span class="nx">queue</span><span class="p">.</span><span class="nx">dispatch</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="p">[</span><span class="nx">hook</span><span class="p">.</span><span class="nx">memoizedState</span><span class="p">,</span> <span class="nx">dispatch</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">updateEffect</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="nx">create</span><span class="o">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">(()</span> <span class="o">=&gt;</span> <span class="k">void</span><span class="p">)</span> <span class="o">|</span> <span class="k">void</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">deps</span>: <span class="kt">Array</span><span class="p">&lt;</span><span class="nt">mixed</span><span class="p">&gt;</span> <span class="o">|</span> <span class="k">void</span> <span class="o">|</span> <span class="kc">null</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="o">:</span> <span class="k">void</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 内部也会调用 updateWorkInProgressHook
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">return</span> <span class="nx">updateEffectImpl</span><span class="p">(</span><span class="nx">PassiveEffect</span><span class="p">,</span> <span class="nx">HookPassive</span><span class="p">,</span> <span class="nx">create</span><span class="p">,</span> <span class="nx">deps</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">updateEffectImpl</span><span class="p">(</span><span class="nx">fiberFlags</span><span class="p">,</span> <span class="nx">hookFlags</span><span class="p">,</span> <span class="nx">create</span><span class="p">,</span> <span class="nx">deps</span><span class="p">)</span><span class="o">:</span> <span class="k">void</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">hook</span> <span class="o">=</span> <span class="nx">updateWorkInProgressHook</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">nextDeps</span> <span class="o">=</span> <span class="nx">deps</span> <span class="o">===</span> <span class="kc">undefined</span> <span class="o">?</span> <span class="kc">null</span> <span class="o">:</span> <span class="nx">deps</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">destroy</span> <span class="o">=</span> <span class="kc">undefined</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nx">currentHook</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kr">const</span> <span class="nx">prevEffect</span> <span class="o">=</span> <span class="nx">currentHook</span><span class="p">.</span><span class="nx">memoizedState</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nx">destroy</span> <span class="o">=</span> <span class="nx">prevEffect</span><span class="p">.</span><span class="nx">destroy</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nx">nextDeps</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="kr">const</span> <span class="nx">prevDeps</span> <span class="o">=</span> <span class="nx">prevEffect</span><span class="p">.</span><span class="nx">deps</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="nx">areHookInputsEqual</span><span class="p">(</span><span class="nx">nextDeps</span><span class="p">,</span> <span class="nx">prevDeps</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 相等就不更新
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">pushEffect</span><span class="p">(</span><span class="nx">hookFlags</span><span class="p">,</span> <span class="nx">create</span><span class="p">,</span> <span class="nx">destroy</span><span class="p">,</span> <span class="nx">nextDeps</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="nx">currentlyRenderingFiber</span><span class="p">.</span><span class="nx">flags</span> <span class="o">|=</span> <span class="nx">fiberFlags</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">hook</span><span class="p">.</span><span class="nx">memoizedState</span> <span class="o">=</span> <span class="nx">pushEffect</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="nx">HookHasEffect</span> <span class="o">|</span> <span class="nx">hookFlags</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">create</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">destroy</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">nextDeps</span>
</span></span><span class="line"><span class="cl">  <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">updateMemo</span><span class="p">&lt;</span><span class="nt">T</span><span class="p">&gt;(</span>
</span></span><span class="line"><span class="cl">  <span class="nx">nextCreate</span><span class="o">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">T</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">deps</span>: <span class="kt">Array</span><span class="p">&lt;</span><span class="nt">mixed</span><span class="p">&gt;</span> <span class="o">|</span> <span class="k">void</span> <span class="o">|</span> <span class="kc">null</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="o">:</span> <span class="nx">T</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">hook</span> <span class="o">=</span> <span class="nx">updateWorkInProgressHook</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">nextDeps</span> <span class="o">=</span> <span class="nx">deps</span> <span class="o">===</span> <span class="kc">undefined</span> <span class="o">?</span> <span class="kc">null</span> <span class="o">:</span> <span class="nx">deps</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">prevState</span> <span class="o">=</span> <span class="nx">hook</span><span class="p">.</span><span class="nx">memoizedState</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nx">prevState</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nx">nextDeps</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="kr">const</span> <span class="nx">prevDeps</span>: <span class="kt">Array</span><span class="p">&lt;</span><span class="nt">mixed</span><span class="p">&gt;</span> <span class="o">|</span> <span class="kc">null</span> <span class="o">=</span> <span class="nx">prevState</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="nx">areHookInputsEqual</span><span class="p">(</span><span class="nx">nextDeps</span><span class="p">,</span> <span class="nx">prevDeps</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 相等就返回上一个状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="nx">prevState</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 重新计算新值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kr">const</span> <span class="nx">nextValue</span> <span class="o">=</span> <span class="nx">nextCreate</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="nx">hook</span><span class="p">.</span><span class="nx">memoizedState</span> <span class="o">=</span> <span class="p">[</span><span class="nx">nextValue</span><span class="p">,</span> <span class="nx">nextDeps</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">nextValue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">updateRef</span><span class="p">&lt;</span><span class="nt">T</span><span class="p">&gt;(</span><span class="nx">initialValue</span>: <span class="kt">T</span><span class="p">)</span><span class="o">:</span> <span class="p">{</span> <span class="nx">current</span>: <span class="kt">T</span> <span class="p">}</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">hook</span> <span class="o">=</span> <span class="nx">updateWorkInProgressHook</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">hook</span><span class="p">.</span><span class="nx">memoizedState</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></tbody></table></div></div><h2 id="组件类型">组件类型</h2><div class="highlight"><div class="chroma"><table class="lntable"><tbody><tr><td class="lntd"><pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td><td class="lntd"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="c1">// 有状态组件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">export</span> <span class="kr">const</span> <span class="nx">ClassComponent</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">export</span> <span class="kr">const</span> <span class="nx">ContextConsumer</span> <span class="o">=</span> <span class="mi">9</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">export</span> <span class="kr">const</span> <span class="nx">ContextProvider</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 无状态组件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">export</span> <span class="kr">const</span> <span class="nx">FunctionComponent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">export</span> <span class="kr">const</span> <span class="nx">IndeterminateComponent</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// 不确定（是函数还是类）组件（一个函数返回了一个带 render 方法与其他生命周期的对象）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">export</span> <span class="kr">const</span> <span class="nx">ForwardRef</span> <span class="o">=</span> <span class="mi">11</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">export</span> <span class="kr">const</span> <span class="nx">MemoComponent</span> <span class="o">=</span> <span class="mi">14</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">export</span> <span class="kr">const</span> <span class="nx">SimpleMemoComponent</span> <span class="o">=</span> <span class="mi">15</span><span class="p">;</span> <span class="c1">// MemoComponent 退化过来的，指没有自定义比较方法的 MemoComponent
</span></span></span><span class="line"><span class="cl"><span class="c1">// 原生组件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">export</span> <span class="kr">const</span> <span class="nx">HostRoot</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="c1">// 渲染起点，可以嵌套在别的节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">export</span> <span class="kr">const</span> <span class="nx">HostPortal</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> <span class="c1">// 切换渲染起点，可以将子节点渲染到到父节点之外的 DOM 节点上
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">export</span> <span class="kr">const</span> <span class="nx">HostComponent</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span> <span class="c1">// 元素节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">export</span> <span class="kr">const</span> <span class="nx">HostText</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span> <span class="c1">// 文本节点
</span></span></span><span class="line"><span class="cl"><span class="c1">// 虚拟组件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">export</span> <span class="kr">const</span> <span class="nx">Fragment</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span> <span class="c1">// 数组的语法糖，React 可以直接渲染数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">export</span> <span class="kr">const</span> <span class="nx">Mode</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span> <span class="c1">// 对应的 fiber 都通过 createFiberFromMode 生成的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">export</span> <span class="kr">const</span> <span class="nx">Profiler</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span> <span class="c1">// 性能检测，配合 ReactDevTools 工作
</span></span></span><span class="line"><span class="cl"><span class="c1">// 懒加载组件，有点像之前用的 ReactLoadable 的官方版
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">export</span> <span class="kr">const</span> <span class="nx">SuspenseComponent</span> <span class="o">=</span> <span class="mi">13</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">export</span> <span class="kr">const</span> <span class="nx">LazyComponent</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span> <span class="c1">// 返回 Promise
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">export</span> <span class="kr">const</span> <span class="nx">SuspenseListComponent</span> <span class="o">=</span> <span class="mi">19</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 其他组件，我还没搞清楚
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">export</span> <span class="kr">const</span> <span class="nx">IncompleteClassComponent</span> <span class="o">=</span> <span class="mi">17</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">export</span> <span class="kr">const</span> <span class="nx">DehydratedFragment</span> <span class="o">=</span> <span class="mi">18</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">export</span> <span class="kr">const</span> <span class="nx">FundamentalComponent</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">export</span> <span class="kr">const</span> <span class="nx">ScopeComponent</span> <span class="o">=</span> <span class="mi">21</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">export</span> <span class="kr">const</span> <span class="nx">Block</span> <span class="o">=</span> <span class="mi">22</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">export</span> <span class="kr">const</span> <span class="nx">OffscreenComponent</span> <span class="o">=</span> <span class="mi">23</span><span class="p">;</span> <span class="c1">// React 版本的 keep-alive，保存失活组件状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">export</span> <span class="kr">const</span> <span class="nx">LegacyHiddenComponent</span> <span class="o">=</span> <span class="mi">24</span><span class="p">;</span>
</span></span></code></pre></td></tr></tbody></table></div></div><h2 id="状态更新">状态更新</h2><img src="set-state.webp" style="margin:0 auto;display:block" alt="" loading="lazy" decoding="async" width="449" height="717" jampack-sized="true"><div class="highlight"><div class="chroma"><table class="lntable"><tbody><tr><td class="lntd"><pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span><span class="lnt">182
</span><span class="lnt">183
</span><span class="lnt">184
</span><span class="lnt">185
</span><span class="lnt">186
</span><span class="lnt">187
</span><span class="lnt">188
</span><span class="lnt">189
</span><span class="lnt">190
</span><span class="lnt">191
</span><span class="lnt">192
</span><span class="lnt">193
</span><span class="lnt">194
</span><span class="lnt">195
</span><span class="lnt">196
</span><span class="lnt">197
</span><span class="lnt">198
</span><span class="lnt">199
</span><span class="lnt">200
</span><span class="lnt">201
</span><span class="lnt">202
</span><span class="lnt">203
</span><span class="lnt">204
</span><span class="lnt">205
</span><span class="lnt">206
</span><span class="lnt">207
</span><span class="lnt">208
</span><span class="lnt">209
</span><span class="lnt">210
</span><span class="lnt">211
</span><span class="lnt">212
</span><span class="lnt">213
</span><span class="lnt">214
</span><span class="lnt">215
</span><span class="lnt">216
</span><span class="lnt">217
</span><span class="lnt">218
</span><span class="lnt">219
</span><span class="lnt">220
</span><span class="lnt">221
</span><span class="lnt">222
</span><span class="lnt">223
</span><span class="lnt">224
</span><span class="lnt">225
</span><span class="lnt">226
</span><span class="lnt">227
</span><span class="lnt">228
</span><span class="lnt">229
</span><span class="lnt">230
</span><span class="lnt">231
</span><span class="lnt">232
</span><span class="lnt">233
</span><span class="lnt">234
</span><span class="lnt">235
</span><span class="lnt">236
</span><span class="lnt">237
</span><span class="lnt">238
</span><span class="lnt">239
</span><span class="lnt">240
</span><span class="lnt">241
</span><span class="lnt">242
</span><span class="lnt">243
</span><span class="lnt">244
</span><span class="lnt">245
</span><span class="lnt">246
</span><span class="lnt">247
</span><span class="lnt">248
</span><span class="lnt">249
</span><span class="lnt">250
</span><span class="lnt">251
</span><span class="lnt">252
</span><span class="lnt">253
</span><span class="lnt">254
</span><span class="lnt">255
</span><span class="lnt">256
</span><span class="lnt">257
</span><span class="lnt">258
</span><span class="lnt">259
</span><span class="lnt">260
</span><span class="lnt">261
</span><span class="lnt">262
</span><span class="lnt">263
</span><span class="lnt">264
</span><span class="lnt">265
</span><span class="lnt">266
</span><span class="lnt">267
</span><span class="lnt">268
</span><span class="lnt">269
</span><span class="lnt">270
</span><span class="lnt">271
</span><span class="lnt">272
</span><span class="lnt">273
</span><span class="lnt">274
</span><span class="lnt">275
</span><span class="lnt">276
</span><span class="lnt">277
</span><span class="lnt">278
</span><span class="lnt">279
</span><span class="lnt">280
</span><span class="lnt">281
</span><span class="lnt">282
</span><span class="lnt">283
</span><span class="lnt">284
</span><span class="lnt">285
</span><span class="lnt">286
</span><span class="lnt">287
</span><span class="lnt">288
</span><span class="lnt">289
</span><span class="lnt">290
</span><span class="lnt">291
</span><span class="lnt">292
</span><span class="lnt">293
</span><span class="lnt">294
</span><span class="lnt">295
</span><span class="lnt">296
</span><span class="lnt">297
</span><span class="lnt">298
</span><span class="lnt">299
</span><span class="lnt">300
</span><span class="lnt">301
</span><span class="lnt">302
</span><span class="lnt">303
</span><span class="lnt">304
</span><span class="lnt">305
</span><span class="lnt">306
</span><span class="lnt">307
</span><span class="lnt">308
</span><span class="lnt">309
</span><span class="lnt">310
</span><span class="lnt">311
</span><span class="lnt">312
</span><span class="lnt">313
</span><span class="lnt">314
</span><span class="lnt">315
</span><span class="lnt">316
</span><span class="lnt">317
</span><span class="lnt">318
</span><span class="lnt">319
</span><span class="lnt">320
</span><span class="lnt">321
</span><span class="lnt">322
</span><span class="lnt">323
</span><span class="lnt">324
</span><span class="lnt">325
</span><span class="lnt">326
</span><span class="lnt">327
</span><span class="lnt">328
</span><span class="lnt">329
</span><span class="lnt">330
</span><span class="lnt">331
</span><span class="lnt">332
</span><span class="lnt">333
</span><span class="lnt">334
</span><span class="lnt">335
</span><span class="lnt">336
</span><span class="lnt">337
</span><span class="lnt">338
</span><span class="lnt">339
</span><span class="lnt">340
</span><span class="lnt">341
</span><span class="lnt">342
</span><span class="lnt">343
</span><span class="lnt">344
</span><span class="lnt">345
</span><span class="lnt">346
</span><span class="lnt">347
</span><span class="lnt">348
</span><span class="lnt">349
</span><span class="lnt">350
</span><span class="lnt">351
</span><span class="lnt">352
</span><span class="lnt">353
</span><span class="lnt">354
</span><span class="lnt">355
</span><span class="lnt">356
</span><span class="lnt">357
</span><span class="lnt">358
</span><span class="lnt">359
</span><span class="lnt">360
</span><span class="lnt">361
</span><span class="lnt">362
</span><span class="lnt">363
</span><span class="lnt">364
</span><span class="lnt">365
</span><span class="lnt">366
</span><span class="lnt">367
</span><span class="lnt">368
</span><span class="lnt">369
</span><span class="lnt">370
</span><span class="lnt">371
</span><span class="lnt">372
</span><span class="lnt">373
</span><span class="lnt">374
</span><span class="lnt">375
</span><span class="lnt">376
</span></code></pre></td><td class="lntd"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="c1">// 初始化更新队列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">export</span> <span class="kd">function</span> <span class="nx">initializeUpdateQueue</span><span class="p">&lt;</span><span class="nt">State</span><span class="p">&gt;(</span><span class="nx">fiber</span>: <span class="kt">Fiber</span><span class="p">)</span><span class="o">:</span> <span class="k">void</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">   * 假设 fiber 刚完成 commit 阶段
</span></span></span><span class="line"><span class="cl"><span class="cm">   * 有两个优先级很低的 update（u1、u2）在 render 阶段没有处理
</span></span></span><span class="line"><span class="cl"><span class="cm">   * u1、u2 就成为了下次更新的 baseUpdate
</span></span></span><span class="line"><span class="cl"><span class="cm">   * u1.next = u2，fiber.updateQueue.baseUpdate = u1 -&gt; u2
</span></span></span><span class="line"><span class="cl"><span class="cm">   */</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">queue</span>: <span class="kt">UpdateQueue</span><span class="p">&lt;</span><span class="nt">State</span><span class="p">&gt;</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">baseState</span>: <span class="kt">fiber.memoizedState</span><span class="p">,</span> <span class="c1">// 更新前该 fiber 节点的 state
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 更新前该 fiber 节点已保存的 update（链表）
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 更新前就存在 update 是因为上次 render 阶段
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 可能有优先级较低的 update 被跳过
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="nx">firstBaseUpdate</span>: <span class="kt">u1</span><span class="p">,</span> <span class="c1">// 链表头，指向第一个 update 对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">lastBaseUpdate</span>: <span class="kt">u2</span><span class="p">,</span> <span class="c1">// 链表尾，指向最后一个 update 对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">shared</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">       * 触发更新时，产生的 update 保存在 shared.pending 中，形成单项环状链表
</span></span></span><span class="line"><span class="cl"><span class="cm">       * 在计算 state 时，链表被剪开，拼接在 lastBaseUpdate 后面
</span></span></span><span class="line"><span class="cl"><span class="cm">       * 假设触发了两次更新，u3、u4（u3 比 u4 先插入）
</span></span></span><span class="line"><span class="cl"><span class="cm">       * fiber.updateQueue.shared.pending === u4;
</span></span></span><span class="line"><span class="cl"><span class="cm">       * u4.next === u3;
</span></span></span><span class="line"><span class="cl"><span class="cm">       * u3.next === u4;
</span></span></span><span class="line"><span class="cl"><span class="cm">       * u3、u4 组成了一个环形链表
</span></span></span><span class="line"><span class="cl"><span class="cm">       * 在计算 state 时，shared.pending 被剪开并拼在 lastBaseUpdate 之后
</span></span></span><span class="line"><span class="cl"><span class="cm">       * 实际上 shared.pending 会被同时连接在（current/workInProgress）updateQueue.lastBaseUpdate 之后
</span></span></span><span class="line"><span class="cl"><span class="cm">       * u1 -&gt; u2 -&gt; u3 -&gt; u4（可能会跳过优先级较低的 update），计算出本次更新的 state（memoizedState）
</span></span></span><span class="line"><span class="cl"><span class="cm">       */</span>
</span></span><span class="line"><span class="cl">      <span class="nx">pending</span>: <span class="kt">null</span> <span class="c1">// 始终指向最后触发的更新 u4
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">},</span>
</span></span><span class="line"><span class="cl">    <span class="nx">effects</span>: <span class="kt">null</span> <span class="c1">// 保存 update.callback !== null 的 update
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">};</span>
</span></span><span class="line"><span class="cl">  <span class="nx">fiber</span><span class="p">.</span><span class="nx">updateQueue</span> <span class="o">=</span> <span class="nx">queue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// setState 会调用 enqueueSetState 生成一个 update 并调度
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">Component</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">setState</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">partialState</span><span class="p">,</span> <span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">partialState</span> <span class="o">===</span> <span class="s1">'object'</span> <span class="o">||</span> <span class="k">typeof</span> <span class="nx">partialState</span> <span class="o">===</span> <span class="s1">'function'</span> <span class="o">||</span> <span class="nx">partialState</span> <span class="o">==</span> <span class="kc">null</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">this</span><span class="p">.</span><span class="nx">updater</span><span class="p">.</span><span class="nx">enqueueSetState</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">partialState</span><span class="p">,</span> <span class="nx">callback</span><span class="p">,</span> <span class="s1">'setState'</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 触发更新优先级
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">enqueueSetState</span><span class="p">(</span><span class="nx">inst</span><span class="p">,</span> <span class="nx">payload</span><span class="p">,</span> <span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 通过组件实例获取对应 fiber
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kr">const</span> <span class="nx">fiber</span> <span class="o">=</span> <span class="nx">getInstance</span><span class="p">(</span><span class="nx">inst</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">eventTime</span> <span class="o">=</span> <span class="nx">requestEventTime</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">suspenseConfig</span> <span class="o">=</span> <span class="nx">requestCurrentSuspenseConfig</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 获取优先级（根据事件的优先级来决定 update 优先级）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kr">const</span> <span class="nx">lane</span> <span class="o">=</span> <span class="nx">requestUpdateLane</span><span class="p">(</span><span class="nx">fiber</span><span class="p">,</span> <span class="nx">suspenseConfig</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 创建 update 对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kr">const</span> <span class="nx">update</span> <span class="o">=</span> <span class="nx">createUpdate</span><span class="p">(</span><span class="nx">eventTime</span><span class="p">,</span> <span class="nx">lane</span><span class="p">,</span> <span class="nx">suspenseConfig</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nx">update</span><span class="p">.</span><span class="nx">payload</span> <span class="o">=</span> <span class="nx">payload</span><span class="p">;</span> <span class="c1">// 部分 state
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 确认回调函数，状态确定之后会调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="nx">callback</span> <span class="o">!==</span> <span class="kc">undefined</span> <span class="o">&amp;&amp;</span> <span class="nx">callback</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">update</span><span class="p">.</span><span class="nx">callback</span> <span class="o">=</span> <span class="nx">callback</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 将 setSate 产生的 update 插入 updateQueue
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">enqueueUpdate</span><span class="p">(</span><span class="nx">fiber</span><span class="p">,</span> <span class="nx">update</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 根据 lane 调度 update
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">scheduleUpdateOnFiber</span><span class="p">(</span><span class="nx">fiber</span><span class="p">,</span> <span class="nx">lane</span><span class="p">,</span> <span class="nx">eventTime</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// forceUpdate 会调用 enqueueForceUpdate 生成 update 并调度
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">Component</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">forceUpdate</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">this</span><span class="p">.</span><span class="nx">updater</span><span class="p">.</span><span class="nx">enqueueForceUpdate</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">callback</span><span class="p">,</span> <span class="s1">'forceUpdate'</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nx">enqueueForceUpdate</span><span class="p">(</span><span class="nx">inst</span><span class="p">,</span> <span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">fiber</span> <span class="o">=</span> <span class="nx">getInstance</span><span class="p">(</span><span class="nx">inst</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">eventTime</span> <span class="o">=</span> <span class="nx">requestEventTime</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">lane</span> <span class="o">=</span> <span class="nx">requestUpdateLane</span><span class="p">(</span><span class="nx">fiber</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">update</span> <span class="o">=</span> <span class="nx">createUpdate</span><span class="p">(</span><span class="nx">eventTime</span><span class="p">,</span> <span class="nx">lane</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nx">update</span><span class="p">.</span><span class="nx">tag</span> <span class="o">=</span> <span class="nx">ForceUpdate</span><span class="p">;</span> <span class="c1">// 2，forceUpdate 没有 payload
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="nx">callback</span> <span class="o">!==</span> <span class="kc">undefined</span> <span class="o">&amp;&amp;</span> <span class="nx">callback</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">update</span><span class="p">.</span><span class="nx">callback</span> <span class="o">=</span> <span class="nx">callback</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="nx">enqueueUpdate</span><span class="p">(</span><span class="nx">fiber</span><span class="p">,</span> <span class="nx">update</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nx">scheduleUpdateOnFiber</span><span class="p">(</span><span class="nx">fiber</span><span class="p">,</span> <span class="nx">lane</span><span class="p">,</span> <span class="nx">eventTime</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="c1">// update 结构（ClassComponent/HostRoot）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">export</span> <span class="kd">function</span> <span class="nx">createUpdate</span><span class="p">(</span><span class="nx">eventTime</span><span class="p">,</span> <span class="nx">lane</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 表示一个需要进行变更的动作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kr">const</span> <span class="nx">update</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 若优先级不够导致 update 一直没执行；React 会在任务超时后，调度 update
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">eventTime</span><span class="p">,</span> <span class="c1">// 任务时间（update 生成时间）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">lane</span><span class="p">,</span> <span class="c1">// update 优先级
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">tag</span>: <span class="kt">UpdateState</span><span class="p">,</span> <span class="c1">// UpdateState、ReplaceState、ForceUpdate、CaptureUpdate
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">payload</span>: <span class="kt">null</span><span class="p">,</span> <span class="c1">// 更新挂载的数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 更新后的回调函数，如果这个回调有返回值
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 就会在 updateQueue 的副作用链表中挂在当前 update
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 具体逻辑在 processUpdateQueue 函数中
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="nx">callback</span>: <span class="kt">null</span><span class="p">,</span> <span class="c1">// update 回调，setState 的第二个参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 多次 setState 会有多个 update，他们之间通过 next 链接
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">next</span>: <span class="kt">null</span> <span class="c1">// 指向下一个 update，所有 update 链接形成链表保存在 fiber.updateQueue
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">};</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">update</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 将 update 添加到 fiber 的 update 链表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">export</span> <span class="kd">function</span> <span class="nx">enqueueUpdate</span><span class="p">&lt;</span><span class="nt">State</span><span class="p">&gt;(</span><span class="nx">fiber</span>: <span class="kt">Fiber</span><span class="p">,</span> <span class="nx">update</span>: <span class="kt">Update</span><span class="p">&lt;</span><span class="nt">State</span><span class="p">&gt;)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">updateQueue</span> <span class="o">=</span> <span class="nx">fiber</span><span class="p">.</span><span class="nx">updateQueue</span><span class="p">;</span> <span class="c1">// 获取 fiber 节点的 update 队列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="nx">updateQueue</span> <span class="o">===</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 当节点被卸载之后才会出现这种情况
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">sharedQueue</span>: <span class="kt">SharedQueue</span><span class="p">&lt;</span><span class="nt">State</span><span class="p">&gt;</span> <span class="o">=</span> <span class="p">(</span><span class="nx">updateQueue</span>: <span class="kt">any</span><span class="p">).</span><span class="nx">shared</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">pending</span> <span class="o">=</span> <span class="nx">sharedQueue</span><span class="p">.</span><span class="nx">pending</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nx">pending</span> <span class="o">===</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 链表是空的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">update</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">update</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">update</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">pending</span><span class="p">.</span><span class="nx">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nx">pending</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">update</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="nx">sharedQueue</span><span class="p">.</span><span class="nx">pending</span> <span class="o">=</span> <span class="nx">update</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kr">export</span> <span class="kd">function</span> <span class="nx">scheduleUpdateOnFiber</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="nx">fiber</span>: <span class="kt">Fiber</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">lane</span>: <span class="kt">Lane</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">eventTime</span>: <span class="kt">number</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">checkForNestedUpdates</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 从 fiber 遍历到 root
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kr">const</span> <span class="nx">root</span> <span class="o">=</span> <span class="nx">markUpdateLaneFromFiberToRoot</span><span class="p">(</span><span class="nx">fiber</span><span class="p">,</span> <span class="nx">lane</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nx">root</span> <span class="o">===</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 标记 root 有一个正在进行的更新
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">markRootUpdated</span><span class="p">(</span><span class="nx">root</span><span class="p">,</span> <span class="nx">lane</span><span class="p">,</span> <span class="nx">eventTime</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nx">root</span> <span class="o">===</span> <span class="nx">workInProgressRoot</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 如果渲染中间，收到了对树的更新
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 那就是说，对于树，有交错更新的任务
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 除非「推迟渲染阶段更新到下一个批处理」是 off，并且是渲染阶段的更新
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 在这种情况下，出于向后兼容的原因
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 不会将渲染阶段的更新视为要交错进行的任务
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="nx">deferRenderPhaseUpdateToNextBatch</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">      <span class="p">(</span><span class="nx">executionContext</span> <span class="o">&amp;</span> <span class="nx">RenderContext</span><span class="p">)</span> <span class="o">===</span> <span class="nx">NoContext</span>
</span></span><span class="line"><span class="cl">    <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">workInProgressRootUpdatedLanes</span> <span class="o">=</span> <span class="nx">mergeLanes</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="nx">workInProgressRootUpdatedLanes</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nx">lane</span>
</span></span><span class="line"><span class="cl">      <span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nx">workInProgressRootExitStatus</span> <span class="o">===</span> <span class="nx">RootSuspendedWithDelay</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">       * root 已经挂起，渲染肯定没有结束
</span></span></span><span class="line"><span class="cl"><span class="cm">       * 既然有一个更新，在被标记为新的更新之前，那就先标记为「挂起」
</span></span></span><span class="line"><span class="cl"><span class="cm">       * 这会中断当前渲染并切换到新的更新
</span></span></span><span class="line"><span class="cl"><span class="cm">       */</span>
</span></span><span class="line"><span class="cl">      <span class="nx">markRootSuspended</span><span class="p">(</span><span class="nx">root</span><span class="p">,</span> <span class="nx">workInProgressRootRenderLanes</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">priorityLevel</span> <span class="o">=</span> <span class="nx">getCurrentPriorityLevel</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nx">lane</span> <span class="o">===</span> <span class="nx">SyncLane</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 检查是否在「unbatchedUpdates」
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="p">(</span><span class="nx">executionContext</span> <span class="o">&amp;</span> <span class="nx">LegacyUnbatchedContext</span><span class="p">)</span> <span class="o">!==</span> <span class="nx">NoContext</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 检查是否已经在渲染
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="p">(</span><span class="nx">executionContext</span> <span class="o">&amp;</span> <span class="p">(</span><span class="nx">RenderContext</span> <span class="o">|</span> <span class="nx">CommitContext</span><span class="p">))</span> <span class="o">===</span> <span class="nx">NoContext</span>
</span></span><span class="line"><span class="cl">    <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// root 的初始化渲染应该是同步的，布局更新应该推迟到批处理结束
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="nx">schedulePendingInteractions</span><span class="p">(</span><span class="nx">root</span><span class="p">,</span> <span class="nx">lane</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="nx">performSyncWorkOnRoot</span><span class="p">(</span><span class="nx">root</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">ensureRootIsScheduled</span><span class="p">(</span><span class="nx">root</span><span class="p">,</span> <span class="nx">eventTime</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="nx">schedulePendingInteractions</span><span class="p">(</span><span class="nx">root</span><span class="p">,</span> <span class="nx">lane</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="nx">executionContext</span> <span class="o">===</span> <span class="nx">NoContext</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">         * 刷新同步工作，除非正在进行刷新或在批处理内
</span></span></span><span class="line"><span class="cl"><span class="cm">         * 这在「scheduleUpdateOnFiber」而不是在 scheduleCallbackForFiber 是故意的
</span></span></span><span class="line"><span class="cl"><span class="cm">         * 这会保留调度但不刷新回调的能力
</span></span></span><span class="line"><span class="cl"><span class="cm">         * 仅对用户发起的更新执行此操作，以保留传统模式的历史行为
</span></span></span><span class="line"><span class="cl"><span class="cm">         */</span>
</span></span><span class="line"><span class="cl">        <span class="nx">resetRenderTimer</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="nx">flushSyncCallbackQueue</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 非同步的情况下，调度离散更新
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="p">(</span><span class="nx">executionContext</span> <span class="o">&amp;</span> <span class="nx">DiscreteEventContext</span><span class="p">)</span> <span class="o">!==</span> <span class="nx">NoContext</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">      <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">       * 只有用户阻塞或更高优先级的更新才被视为离散的
</span></span></span><span class="line"><span class="cl"><span class="cm">       * 即使在离散事件中也是如此
</span></span></span><span class="line"><span class="cl"><span class="cm">       */</span>
</span></span><span class="line"><span class="cl">      <span class="p">(</span><span class="nx">priorityLevel</span> <span class="o">===</span> <span class="nx">UserBlockingSchedulerPriority</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">        <span class="nx">priorityLevel</span> <span class="o">===</span> <span class="nx">ImmediateSchedulerPriority</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 追踪最低优先级的离散更新
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">if</span> <span class="p">(</span><span class="nx">rootsWithPendingDiscreteUpdates</span> <span class="o">===</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">rootsWithPendingDiscreteUpdates</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Set</span><span class="p">([</span><span class="nx">root</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">rootsWithPendingDiscreteUpdates</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">root</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">ensureRootIsScheduled</span><span class="p">(</span><span class="nx">root</span><span class="p">,</span> <span class="nx">eventTime</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nx">schedulePendingInteractions</span><span class="p">(</span><span class="nx">root</span><span class="p">,</span> <span class="nx">lane</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="nx">mostRecentlyUpdatedRoot</span> <span class="o">=</span> <span class="nx">root</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kr">export</span> <span class="kd">function</span> <span class="nx">processUpdateQueue</span><span class="p">&lt;</span><span class="nt">State</span><span class="p">&gt;(</span>
</span></span><span class="line"><span class="cl">  <span class="nx">workInProgress</span>: <span class="kt">Fiber</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">props</span>: <span class="kt">any</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">instance</span>: <span class="kt">any</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">renderLanes</span>: <span class="kt">Lanes</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="o">:</span> <span class="k">void</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">queue</span>: <span class="kt">UpdateQueue</span><span class="p">&lt;</span><span class="nt">State</span><span class="p">&gt;</span> <span class="o">=</span> <span class="nx">workInProgress</span><span class="p">.</span><span class="nx">updateQueue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">hasForceUpdate</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">firstBaseUpdate</span> <span class="o">=</span> <span class="nx">queue</span><span class="p">.</span><span class="nx">firstBaseUpdate</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">lastBaseUpdate</span> <span class="o">=</span> <span class="nx">queue</span><span class="p">.</span><span class="nx">lastBaseUpdate</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">pendingQueue</span> <span class="o">=</span> <span class="nx">queue</span><span class="p">.</span><span class="nx">shared</span><span class="p">.</span><span class="nx">pending</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nx">pendingQueue</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">queue</span><span class="p">.</span><span class="nx">shared</span><span class="p">.</span><span class="nx">pending</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 剪开 pendingQueue 环状链表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kr">const</span> <span class="nx">lastPendingUpdate</span> <span class="o">=</span> <span class="nx">pendingQueue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kr">const</span> <span class="nx">firstPendingUpdate</span> <span class="o">=</span> <span class="nx">lastPendingUpdate</span><span class="p">.</span><span class="nx">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nx">lastPendingUpdate</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 将 pendingUpdate 添加到 baseQueue
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="nx">lastBaseUpdate</span> <span class="o">===</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">firstBaseUpdate</span> <span class="o">=</span> <span class="nx">firstPendingUpdate</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">lastBaseUpdate</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">firstPendingUpdate</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">lastBaseUpdate</span> <span class="o">=</span> <span class="nx">lastPendingUpdate</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kr">const</span> <span class="nx">current</span> <span class="o">=</span> <span class="nx">workInProgress</span><span class="p">.</span><span class="nx">alternate</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nx">current</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="kr">const</span> <span class="nx">currentQueue</span>: <span class="kt">UpdateQueue</span><span class="p">&lt;</span><span class="nt">State</span><span class="p">&gt;</span> <span class="o">=</span> <span class="nx">current</span><span class="p">.</span><span class="nx">updateQueue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="kr">const</span> <span class="nx">currentLastBaseUpdate</span> <span class="o">=</span> <span class="nx">currentQueue</span><span class="p">.</span><span class="nx">lastBaseUpdate</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="nx">currentLastBaseUpdate</span> <span class="o">!==</span> <span class="nx">lastBaseUpdate</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="nx">currentLastBaseUpdate</span> <span class="o">===</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="nx">currentQueue</span><span class="p">.</span><span class="nx">firstBaseUpdate</span> <span class="o">=</span> <span class="nx">firstPendingUpdate</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="nx">currentLastBaseUpdate</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">firstPendingUpdate</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nx">currentQueue</span><span class="p">.</span><span class="nx">lastBaseUpdate</span> <span class="o">=</span> <span class="nx">lastPendingUpdate</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nx">firstBaseUpdate</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 迭代更新列表以计算结果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">let</span> <span class="nx">newState</span> <span class="o">=</span> <span class="nx">queue</span><span class="p">.</span><span class="nx">baseState</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">let</span> <span class="nx">newLanes</span> <span class="o">=</span> <span class="nx">NoLanes</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">let</span> <span class="nx">newBaseState</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">let</span> <span class="nx">newFirstBaseUpdate</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">let</span> <span class="nx">newLastBaseUpdate</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">let</span> <span class="nx">update</span> <span class="o">=</span> <span class="nx">firstBaseUpdate</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">do</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="kr">const</span> <span class="nx">updateLane</span> <span class="o">=</span> <span class="nx">update</span><span class="p">.</span><span class="nx">lane</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="kr">const</span> <span class="nx">updateEventTime</span> <span class="o">=</span> <span class="nx">update</span><span class="p">.</span><span class="nx">eventTime</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">isSubsetOfLanes</span><span class="p">(</span><span class="nx">renderLanes</span><span class="p">,</span> <span class="nx">updateLane</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 优先级不够，跳过更新，跳过的更新的前一个状态就是新的「基态」
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kr">const</span> <span class="nx">clone</span>: <span class="kt">Update</span><span class="p">&lt;</span><span class="nt">State</span><span class="p">&gt;</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="nx">eventTime</span>: <span class="kt">updateEventTime</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">          <span class="nx">lane</span>: <span class="kt">updateLane</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">          <span class="nx">tag</span>: <span class="kt">update.tag</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">          <span class="nx">payload</span>: <span class="kt">update.payload</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">          <span class="nx">callback</span>: <span class="kt">update.callback</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">          <span class="nx">next</span>: <span class="kt">null</span>
</span></span><span class="line"><span class="cl">        <span class="p">};</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="nx">newLastBaseUpdate</span> <span class="o">===</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="nx">newFirstBaseUpdate</span> <span class="o">=</span> <span class="nx">newLastBaseUpdate</span> <span class="o">=</span> <span class="nx">clone</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">          <span class="nx">newBaseState</span> <span class="o">=</span> <span class="nx">newState</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="nx">newLastBaseUpdate</span> <span class="o">=</span> <span class="nx">newLastBaseUpdate</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">clone</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nx">newLanes</span> <span class="o">=</span> <span class="nx">mergeLanes</span><span class="p">(</span><span class="nx">newLanes</span><span class="p">,</span> <span class="nx">updateLane</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 优先级足够
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="nx">newLastBaseUpdate</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="c1">// 即将被提交的 update
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="kr">const</span> <span class="nx">clone</span>: <span class="kt">Update</span><span class="p">&lt;</span><span class="nt">State</span><span class="p">&gt;</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">eventTime</span>: <span class="kt">updateEventTime</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="nx">lane</span>: <span class="kt">NoLane</span><span class="p">,</span> <span class="c1">// 0 是所有位掩码的子集
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">tag</span>: <span class="kt">update.tag</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="nx">payload</span>: <span class="kt">update.payload</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="nx">callback</span>: <span class="kt">update.callback</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="nx">next</span>: <span class="kt">null</span>
</span></span><span class="line"><span class="cl">          <span class="p">};</span>
</span></span><span class="line"><span class="cl">          <span class="nx">newLastBaseUpdate</span> <span class="o">=</span> <span class="nx">newLastBaseUpdate</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">clone</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 处理 update，计算新的 state
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">newState</span> <span class="o">=</span> <span class="nx">getStateFromUpdate</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">          <span class="nx">workInProgress</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">          <span class="nx">queue</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">          <span class="nx">update</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">          <span class="nx">newState</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">          <span class="nx">props</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">          <span class="nx">instance</span>
</span></span><span class="line"><span class="cl">        <span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="kr">const</span> <span class="nx">callback</span> <span class="o">=</span> <span class="nx">update</span><span class="p">.</span><span class="nx">callback</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="nx">callback</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="nx">workInProgress</span><span class="p">.</span><span class="nx">flags</span> <span class="o">|=</span> <span class="nx">Callback</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">          <span class="kr">const</span> <span class="nx">effects</span> <span class="o">=</span> <span class="nx">queue</span><span class="p">.</span><span class="nx">effects</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">          <span class="k">if</span> <span class="p">(</span><span class="nx">effects</span> <span class="o">===</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">queue</span><span class="p">.</span><span class="nx">effects</span> <span class="o">=</span> <span class="p">[</span><span class="nx">update</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">          <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">effects</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">update</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">          <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="nx">update</span> <span class="o">=</span> <span class="nx">update</span><span class="p">.</span><span class="nx">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="nx">update</span> <span class="o">===</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">pendingQueue</span> <span class="o">=</span> <span class="nx">queue</span><span class="p">.</span><span class="nx">shared</span><span class="p">.</span><span class="nx">pending</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="nx">pendingQueue</span> <span class="o">===</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="kr">const</span> <span class="nx">lastPendingUpdate</span> <span class="o">=</span> <span class="nx">pendingQueue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">          <span class="kr">const</span> <span class="nx">firstPendingUpdate</span> <span class="o">=</span> <span class="nx">lastPendingUpdate</span><span class="p">.</span><span class="nx">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">          <span class="nx">lastPendingUpdate</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">          <span class="nx">update</span> <span class="o">=</span> <span class="nx">firstPendingUpdate</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">          <span class="nx">queue</span><span class="p">.</span><span class="nx">lastBaseUpdate</span> <span class="o">=</span> <span class="nx">lastPendingUpdate</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">          <span class="nx">queue</span><span class="p">.</span><span class="nx">shared</span><span class="p">.</span><span class="nx">pending</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="kc">true</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nx">newLastBaseUpdate</span> <span class="o">===</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">newBaseState</span> <span class="o">=</span> <span class="nx">newState</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">queue</span><span class="p">.</span><span class="nx">baseState</span> <span class="o">=</span> <span class="nx">newBaseState</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nx">queue</span><span class="p">.</span><span class="nx">firstBaseUpdate</span> <span class="o">=</span> <span class="nx">newFirstBaseUpdate</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nx">queue</span><span class="p">.</span><span class="nx">lastBaseUpdate</span> <span class="o">=</span> <span class="nx">newLastBaseUpdate</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 将剩余过期时间设置为队列中剩余的时间
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 影响过期时间的另外两个因素就是 props 和 context
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="nx">markSkippedUpdateLanes</span><span class="p">(</span><span class="nx">newLanes</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nx">workInProgress</span><span class="p">.</span><span class="nx">lanes</span> <span class="o">=</span> <span class="nx">newLanes</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nx">workInProgress</span><span class="p">.</span><span class="nx">memoizedState</span> <span class="o">=</span> <span class="nx">newState</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 最终由 getStateFromUpdate 计算出 state
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">function</span> <span class="nx">getStateFromUpdate</span><span class="p">&lt;</span><span class="nt">State</span><span class="p">&gt;(</span>
</span></span><span class="line"><span class="cl">  <span class="nx">workInProgress</span>: <span class="kt">Fiber</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">queue</span>: <span class="kt">UpdateQueue</span><span class="p">&lt;</span><span class="nt">State</span><span class="p">&gt;,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">update</span>: <span class="kt">Update</span><span class="p">&lt;</span><span class="nt">State</span><span class="p">&gt;,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">prevState</span>: <span class="kt">State</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">nextProps</span>: <span class="kt">any</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">instance</span>: <span class="kt">any</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="o">:</span> <span class="kt">any</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">switch</span> <span class="p">(</span><span class="nx">update</span><span class="p">.</span><span class="nx">tag</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nx">ReplaceState</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="kr">const</span> <span class="nx">payload</span> <span class="o">=</span> <span class="nx">update</span><span class="p">.</span><span class="nx">payload</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">payload</span> <span class="o">===</span> <span class="s1">'function'</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kr">const</span> <span class="nx">nextState</span> <span class="o">=</span> <span class="nx">payload</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">instance</span><span class="p">,</span> <span class="nx">prevState</span><span class="p">,</span> <span class="nx">nextProps</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">nextState</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="nx">payload</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nx">CaptureUpdate</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">workInProgress</span><span class="p">.</span><span class="nx">flags</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">        <span class="p">(</span><span class="nx">workInProgress</span><span class="p">.</span><span class="nx">flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="nx">ShouldCapture</span><span class="p">)</span> <span class="o">|</span> <span class="nx">DidCapture</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nx">UpdateState</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="kr">const</span> <span class="nx">payload</span> <span class="o">=</span> <span class="nx">update</span><span class="p">.</span><span class="nx">payload</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="kd">let</span> <span class="nx">partialState</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">payload</span> <span class="o">===</span> <span class="s1">'function'</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">partialState</span> <span class="o">=</span> <span class="nx">payload</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">instance</span><span class="p">,</span> <span class="nx">prevState</span><span class="p">,</span> <span class="nx">nextProps</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">partialState</span> <span class="o">=</span> <span class="nx">payload</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="nx">partialState</span> <span class="o">===</span> <span class="kc">null</span> <span class="o">||</span> <span class="nx">partialState</span> <span class="o">===</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">prevState</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">({},</span> <span class="nx">prevState</span><span class="p">,</span> <span class="nx">partialState</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nx">ForceUpdate</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">hasForceUpdate</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="nx">prevState</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">prevState</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></tbody></table></div></div><ul><li><p>legacy 模式：</p><div class="highlight"><div class="chroma"><table class="lntable"><tbody><tr><td class="lntd"><pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td><td class="lntd"><pre tabindex="0" class="chroma"><code class="language-jsx" data-lang="jsx"><span class="line"><span class="cl"><span class="nx">ReactDOM</span><span class="p">.</span><span class="nx">render</span><span class="p">(&lt;</span><span class="nt">App</span> <span class="p">/&gt;,</span> <span class="nx">rootNode</span><span class="p">);</span>
</span></span></code></pre></td></tr></tbody></table></div></div><ul><li>在同步操作中，setState 是异步的；</li><li>在异步操作中，setState 是同步的；</li><li>创建的任务/更新均为同样的优先级。</li></ul></li><li><p>concurrent 模式：</p><div class="highlight"><div class="chroma"><table class="lntable"><tbody><tr><td class="lntd"><pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td><td class="lntd"><pre tabindex="0" class="chroma"><code class="language-jsx" data-lang="jsx"><span class="line"><span class="cl"><span class="nx">ReactDOM</span><span class="p">.</span><span class="nx">createRoot</span><span class="p">(</span><span class="nx">rootNode</span><span class="p">).</span><span class="nx">render</span><span class="p">(&lt;</span><span class="nt">App</span> <span class="p">/&gt;);</span>
</span></span></code></pre></td></tr></tbody></table></div></div><ul><li>更急迫的更新可以<strong>中断</strong>已经开始的渲染；</li><li>创建的任务/更新有不同的优先级；</li><li>渲染过程可以被打断；</li><li>setState 是异步。</li></ul></li></ul><h2 id="生命周期">生命周期</h2><p>reconciler 阶段（render 阶段）；生成新的 fiber 树并收集本次<strong>要更新</strong>的点；对应的钩子为：</p><ul><li>constructor</li><li>static getDerivedStateFromProps</li><li>static getDerivedStateFromError（发生错误的组件不会触发自身的钩子）</li><li>shouldComponentUpdate</li><li>render</li></ul><p>commit 阶段（renderer 阶段）；将<strong>要更新</strong>的点 patch 到 DOM 上并切换 fiber 树；对应的钩子为：</p><ul><li>getSnapshotBeforeUpdate</li><li>componentDidMount</li><li>componentDidUpdate</li><li>componentDidCatch（发生错误的组件不会触发自身的钩子）</li><li>componentWillUnmount</li></ul><p><img src="/p/react-%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%8B/lifecycle.webp" width="1956" height="1068" srcset="/p/react-%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%8B/lifecycle_hu8681281966214428320.png 480w, /p/react-%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%8B/lifecycle_hu10771034196176327004.png 1024w" class="gallery-image" data-flex-grow="183" data-flex-basis="439px" loading="lazy" alt="" decoding="async"></p><p><a class="link" href="https://zhuanlan.zhihu.com/p/37095662#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e5%af%b9%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f%e9%92%a9%e5%ad%90%e5%a4%a7%e6%8d%a2%e8%a1%80" target="_blank" rel="noopener">为什么要对生命周期钩子大换血？</a></p><p>组件在挂载过程中会调三次钩子（constructor、componentWillMount、render），组件在更新过程中会调四次钩子（componentWillReceiveProps、shouldComponentUpdate、componentWillUpdate、render）；总不能每个方法都用 try…catch 包起来，这样会性能很差；而 constructor、render 是不可避免的，于是对三个 willXXX 动刀了。</p><p>在早期版本中，componentWillMount 与 componentWillReceiveProps 会做内部优化，执行多次 setState 都会延后到 render 时进行合并处理；因此用户就肆意 setState 了。这些 willXXX 还可以让用户任意操作 DOM；操作 DOM 会可能 reflow，这是官方不愿意看到的。于是官方推出了 getDerivedStateFromProps，让你在 render 设置新 state，你主要返回一个新对象，它就主动帮你 setState。由于这是一个静态方法，你不能操作 instance，这就阻止了你多次操作 setState。由于没有 instance，也就没有 instance.refs.xxx，你也没有机会操作 DOM 了。这样一来，getDerivedStateFromProps 的逻辑应该会很简单，这样就不会出错，就不会打断 DFS 过程。</p><p>getDerivedStateFromProps 取代了原来的 componentWillMount 与 componentWillReceiveProps 方法，而 componentWillUpdate 本来就是可有可无，以前完全是为了对称好看。在即使到来的异步更新中，render 阶段可能执行多次，才执行一次 commit；这样也会导致 willXXX 钩子执行多次，违反它们的语义，它们的废弃是不可逆转的。在进入 commit 阶段时，组件多了一个新钩子叫 getSnapshotBeforeUpdate，它与 commit 阶段的钩子一样只执行一次。如果出错呢，在 componentDidMount/Update 后，我们可以使用 componentDidCatch 方法。</p><p>render 阶段的钩子都不应该操作 DOM，最好也不要 setState，我们称之为<strong>轻量钩子</strong>；commit 阶段的钩子则对应称之为<strong>重量钩子</strong>。</p><ul><li>constructor</li></ul><div class="highlight"><div class="chroma"><table class="lntable"><tbody><tr><td class="lntd"><pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span></code></pre></td><td class="lntd"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 以下情况会调用 constructClassInstance（构建类组件实例）：
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 1. updateClassComponent（如果 instance 为 null）
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 2. mountIncompleteClassComponent
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">constructClassInstance</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="nx">workInProgress</span>: <span class="kt">Fiber</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">ctor</span>: <span class="kt">any</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">props</span>: <span class="kt">any</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="o">:</span> <span class="kt">any</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 处理上下文
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kr">const</span> <span class="nx">contextType</span> <span class="o">=</span> <span class="nx">ctor</span><span class="p">.</span><span class="nx">contextType</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">isLegacyContextConsumer</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">unmaskedContext</span> <span class="o">=</span> <span class="nx">emptyContextObject</span><span class="p">;</span> <span class="c1">// {}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kd">let</span> <span class="nx">context</span> <span class="o">=</span> <span class="nx">emptyContextObject</span><span class="p">;</span> <span class="c1">// {}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">contextType</span> <span class="o">===</span> <span class="s1">'object'</span> <span class="o">&amp;&amp;</span> <span class="nx">contextType</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">context</span> <span class="o">=</span> <span class="nx">readContext</span><span class="p">(</span><span class="nx">contextType</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">disableLegacyContext</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">unmaskedContext</span> <span class="o">=</span> <span class="nx">getUnmaskedContext</span><span class="p">(</span><span class="nx">workInProgress</span><span class="p">,</span> <span class="nx">ctor</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kr">const</span> <span class="nx">contextTypes</span> <span class="o">=</span> <span class="nx">ctor</span><span class="p">.</span><span class="nx">contextTypes</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nx">isLegacyContextConsumer</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">      <span class="nx">contextTypes</span> <span class="o">!==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="nx">contextTypes</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nx">context</span> <span class="o">=</span> <span class="nx">isLegacyContextConsumer</span>
</span></span><span class="line"><span class="cl">      <span class="o">?</span> <span class="nx">getMaskedContext</span><span class="p">(</span><span class="nx">workInProgress</span><span class="p">,</span> <span class="nx">unmaskedContext</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="o">:</span> <span class="nx">emptyContextObject</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 创建组件实例
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kr">const</span> <span class="nx">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ctor</span><span class="p">(</span><span class="nx">props</span><span class="p">,</span> <span class="nx">context</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">state</span> <span class="o">=</span> <span class="p">(</span><span class="nx">workInProgress</span><span class="p">.</span><span class="nx">memoizedState</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">    <span class="nx">instance</span><span class="p">.</span><span class="nx">state</span> <span class="o">!==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="nx">instance</span><span class="p">.</span><span class="nx">state</span> <span class="o">!==</span> <span class="kc">undefined</span>
</span></span><span class="line"><span class="cl">      <span class="o">?</span> <span class="nx">instance.state</span>
</span></span><span class="line"><span class="cl">      : <span class="kt">null</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">   * 实例需要访问到 fiber，以便可以安排更新
</span></span></span><span class="line"><span class="cl"><span class="cm">   * instance.updater = classComponentUpdater
</span></span></span><span class="line"><span class="cl"><span class="cm">   * workInProgress.stateNode = instance
</span></span></span><span class="line"><span class="cl"><span class="cm">   * instance._reactInternals = workInProgress
</span></span></span><span class="line"><span class="cl"><span class="cm">   */</span>
</span></span><span class="line"><span class="cl">  <span class="nx">adoptClassInstance</span><span class="p">(</span><span class="nx">workInProgress</span><span class="p">,</span> <span class="nx">instance</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">   * 缓存 unmasked context，可以避免在不必要的情况下重新创建 masked context
</span></span></span><span class="line"><span class="cl"><span class="cm">   * ReactFiberContext 通常更新此缓存，但不能更新新创建的实例
</span></span></span><span class="line"><span class="cl"><span class="cm">   */</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nx">isLegacyContextConsumer</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">cacheContext</span><span class="p">(</span><span class="nx">workInProgress</span><span class="p">,</span> <span class="nx">unmaskedContext</span><span class="p">,</span> <span class="nx">context</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">instance</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></tbody></table></div></div><ul><li>getDerivedStateFromProps</li></ul><div class="highlight"><div class="chroma"><table class="lntable"><tbody><tr><td class="lntd"><pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td><td class="lntd"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 以下情况会调用 applyDerivedStateFromProps：
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 1. mountClassInstance：挂载组件实例
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 2. resumeMountClassInstance：复用组件实例
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 3. updateClassInstance：更新组件实例
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 可以通过 props 派生出一个 state，constructor 也可以执行这个逻辑
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 但是 constructor 只会在初始化时执行
</span></span></span><span class="line"><span class="cl"><span class="cm"> * getDerivedStateFromProps 会在每次 render 函数调用前执行
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kr">export</span> <span class="kd">function</span> <span class="nx">applyDerivedStateFromProps</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="nx">workInProgress</span>: <span class="kt">Fiber</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">ctor</span>: <span class="kt">any</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">getDerivedStateFromProps</span><span class="o">:</span> <span class="p">(</span><span class="nx">props</span>: <span class="kt">any</span><span class="p">,</span> <span class="nx">state</span>: <span class="kt">any</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kt">any</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">nextProps</span>: <span class="kt">any</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 更新前/初始状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kr">const</span> <span class="nx">prevState</span> <span class="o">=</span> <span class="nx">workInProgress</span><span class="p">.</span><span class="nx">memoizedState</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// getDerivedStateFromProps 接受新的 props 和旧的 state，返回变化的 state
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kr">const</span> <span class="nx">partialState</span> <span class="o">=</span> <span class="nx">getDerivedStateFromProps</span><span class="p">(</span><span class="nx">nextProps</span><span class="p">,</span> <span class="nx">prevState</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 合并为更新后的/挂载后的状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kr">const</span> <span class="nx">memoizedState</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">    <span class="nx">partialState</span> <span class="o">===</span> <span class="kc">null</span> <span class="o">||</span> <span class="nx">partialState</span> <span class="o">===</span> <span class="kc">undefined</span>
</span></span><span class="line"><span class="cl">      <span class="o">?</span> <span class="nx">prevState</span>
</span></span><span class="line"><span class="cl">      : <span class="kt">Object.assign</span><span class="p">({},</span> <span class="nx">prevState</span><span class="p">,</span> <span class="nx">partialState</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 保存在 workInProgress 中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">workInProgress</span><span class="p">.</span><span class="nx">memoizedState</span> <span class="o">=</span> <span class="nx">memoizedState</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 更新队列空了之后，将新的状态持久化到基本状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="nx">workInProgress</span><span class="p">.</span><span class="nx">lanes</span> <span class="o">===</span> <span class="nx">NoLanes</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 对于类，队列始终为非 null
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kr">const</span> <span class="nx">updateQueue</span>: <span class="kt">UpdateQueue</span><span class="p">&lt;</span><span class="nt">any</span><span class="p">&gt;</span> <span class="o">=</span> <span class="p">(</span><span class="nx">workInProgress.updateQueue</span>: <span class="kt">any</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nx">updateQueue</span><span class="p">.</span><span class="nx">baseState</span> <span class="o">=</span> <span class="nx">memoizedState</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></tbody></table></div></div><ul><li>shouldComponentUpdate</li></ul><div class="highlight"><div class="chroma"><table class="lntable"><tbody><tr><td class="lntd"><pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span></code></pre></td><td class="lntd"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * shouldUpdate 会在以下情况求值，来确定是否更新：
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 1. resumeMountClassInstance
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 2. updateClassInstance
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">shouldUpdate</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// this.forceUpdate 会将 hasForceUpdate 置为 true，所以组件一定会更新
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">checkHasForceUpdateAfterProcessing</span><span class="p">()</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">  <span class="nx">checkShouldComponentUpdate</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="nx">workInProgress</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">ctor</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">oldProps</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">newProps</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">oldState</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">newState</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">nextContext</span>
</span></span><span class="line"><span class="cl">  <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">checkShouldComponentUpdate</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="nx">workInProgress</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">ctor</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">oldProps</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">newProps</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">oldState</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">newState</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">nextContext</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">instance</span> <span class="o">=</span> <span class="nx">workInProgress</span><span class="p">.</span><span class="nx">stateNode</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">instance</span><span class="p">.</span><span class="nx">shouldComponentUpdate</span> <span class="o">===</span> <span class="s1">'function'</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果用户引入了 shouldComponentUpdate，计算组件是否应该更新
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kr">const</span> <span class="nx">shouldUpdate</span> <span class="o">=</span> <span class="nx">instance</span><span class="p">.</span><span class="nx">shouldComponentUpdate</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="nx">newProps</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nx">newState</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nx">nextContext</span>
</span></span><span class="line"><span class="cl">    <span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">shouldUpdate</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nx">ctor</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">&amp;&amp;</span> <span class="nx">ctor</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">isPureReactComponent</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果继承了 PureComponent，对 props 和 state 做浅比较
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="o">!</span><span class="nx">shallowEqual</span><span class="p">(</span><span class="nx">oldProps</span><span class="p">,</span> <span class="nx">newProps</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="nx">shallowEqual</span><span class="p">(</span><span class="nx">oldState</span><span class="p">,</span> <span class="nx">newState</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></tbody></table></div></div><ul><li>render</li></ul><div class="highlight"><div class="chroma"><table class="lntable"><tbody><tr><td class="lntd"><pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span></code></pre></td><td class="lntd"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 以下情况会调用 updateClassComponent：
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 1. mountIncompleteClassComponent
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 2. mountIndeterminateComponent
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">finishClassComponent</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="nx">current</span>: <span class="kt">Fiber</span> <span class="o">|</span> <span class="kc">null</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">workInProgress</span>: <span class="kt">Fiber</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">Component</span>: <span class="kt">any</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">shouldUpdate</span>: <span class="kt">boolean</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">hasContext</span>: <span class="kt">boolean</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">renderLanes</span>: <span class="kt">Lanes</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 即使 shouldComponentUpdate 返回的是 false，refs 也得更新
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">markRef</span><span class="p">(</span><span class="nx">current</span><span class="p">,</span> <span class="nx">workInProgress</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">didCaptureError</span> <span class="o">=</span> <span class="p">(</span><span class="nx">workInProgress</span><span class="p">.</span><span class="nx">flags</span> <span class="o">&amp;</span> <span class="nx">DidCapture</span><span class="p">)</span> <span class="o">!==</span> <span class="nx">NoFlags</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">shouldUpdate</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">didCaptureError</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nx">hasContext</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">invalidateContextProvider</span><span class="p">(</span><span class="nx">workInProgress</span><span class="p">,</span> <span class="nx">Component</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">bailoutOnAlreadyFinishedWork</span><span class="p">(</span><span class="nx">current</span><span class="p">,</span> <span class="nx">workInProgress</span><span class="p">,</span> <span class="nx">renderLanes</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">instance</span> <span class="o">=</span> <span class="nx">workInProgress</span><span class="p">.</span><span class="nx">stateNode</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">ReactCurrentOwner</span><span class="p">.</span><span class="nx">current</span> <span class="o">=</span> <span class="nx">workInProgress</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">nextChildren</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="nx">didCaptureError</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">    <span class="k">typeof</span> <span class="nx">Component</span><span class="p">.</span><span class="nx">getDerivedStateFromError</span> <span class="o">!==</span> <span class="s1">'function'</span>
</span></span><span class="line"><span class="cl">  <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 如果捕获到错误，但是没有 getDerivedStateFromError 钩子，卸载所有子组件
</span></span></span><span class="line"><span class="cl"><span class="cm">     * componentDidCatch 将安排更新来重新渲染 fallback
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="nx">nextChildren</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">nextChildren</span> <span class="o">=</span> <span class="nx">instance</span><span class="p">.</span><span class="nx">render</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="nx">workInProgress</span><span class="p">.</span><span class="nx">flags</span> <span class="o">|=</span> <span class="nx">PerformedWork</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nx">current</span> <span class="o">!==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="nx">didCaptureError</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 如果我们正在从错误中恢复，请在不重用任何现有子节点的情况下进行协调
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 从概念上讲，正常的子节点和因错而显示的子节点是两个不同的集合
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 即使它们的身份匹配，我们也不应该重用正常的子节点
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="nx">forceUnmountCurrentAndReconcile</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="nx">current</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nx">workInProgress</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nx">nextChildren</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nx">renderLanes</span>
</span></span><span class="line"><span class="cl">    <span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">reconcileChildren</span><span class="p">(</span><span class="nx">current</span><span class="p">,</span> <span class="nx">workInProgress</span><span class="p">,</span> <span class="nx">nextChildren</span><span class="p">,</span> <span class="nx">renderLanes</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 保存刚刚用来渲染的状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">workInProgress</span><span class="p">.</span><span class="nx">memoizedState</span> <span class="o">=</span> <span class="nx">instance</span><span class="p">.</span><span class="nx">state</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 重新计算可能发生改变的 context 传过来的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="nx">hasContext</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">invalidateContextProvider</span><span class="p">(</span><span class="nx">workInProgress</span><span class="p">,</span> <span class="nx">Component</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">workInProgress</span><span class="p">.</span><span class="nx">child</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></tbody></table></div></div><ul><li>getSnapshotBeforeUpdate</li></ul><div class="highlight"><div class="chroma"><table class="lntable"><tbody><tr><td class="lntd"><pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span></code></pre></td><td class="lntd"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 会在 commitBeforeMutationLifeCycles 里调用（就是在最终 commit 之前被调用）
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 之后便会 commitMutationEffects 执行 commitWork
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">commitBeforeMutationLifeCycles</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="nx">current</span>: <span class="kt">Fiber</span> <span class="o">|</span> <span class="kc">null</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">finishedWork</span>: <span class="kt">Fiber</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="o">:</span> <span class="k">void</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">switch</span> <span class="p">(</span><span class="nx">finishedWork</span><span class="p">.</span><span class="nx">tag</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nx">FunctionComponent</span>:
</span></span><span class="line"><span class="cl">    <span class="kt">case</span> <span class="nx">ForwardRef</span>:
</span></span><span class="line"><span class="cl">    <span class="kt">case</span> <span class="nx">SimpleMemoComponent</span>:
</span></span><span class="line"><span class="cl">    <span class="kt">case</span> <span class="nx">Block</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nx">ClassComponent</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="nx">finishedWork</span><span class="p">.</span><span class="nx">flags</span> <span class="o">&amp;</span> <span class="nx">Snapshot</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="nx">current</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="kr">const</span> <span class="nx">prevProps</span> <span class="o">=</span> <span class="nx">current</span><span class="p">.</span><span class="nx">memoizedProps</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">          <span class="kr">const</span> <span class="nx">prevState</span> <span class="o">=</span> <span class="nx">current</span><span class="p">.</span><span class="nx">memoizedState</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">          <span class="kr">const</span> <span class="nx">instance</span> <span class="o">=</span> <span class="nx">finishedWork</span><span class="p">.</span><span class="nx">stateNode</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">          <span class="c1">// snapshot 会作为 componentDidUpdate 的第三个参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="kr">const</span> <span class="nx">snapshot</span> <span class="o">=</span> <span class="nx">instance</span><span class="p">.</span><span class="nx">getSnapshotBeforeUpdate</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="nx">finishedWork</span><span class="p">.</span><span class="nx">elementType</span> <span class="o">===</span> <span class="nx">finishedWork</span><span class="p">.</span><span class="kr">type</span>
</span></span><span class="line"><span class="cl">              <span class="o">?</span> <span class="nx">prevProps</span>
</span></span><span class="line"><span class="cl">              : <span class="kt">resolveDefaultProps</span><span class="p">(</span><span class="nx">finishedWork</span><span class="p">.</span><span class="kr">type</span><span class="p">,</span> <span class="nx">prevProps</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">            <span class="nx">prevState</span>
</span></span><span class="line"><span class="cl">          <span class="p">);</span>
</span></span><span class="line"><span class="cl">          <span class="nx">instance</span><span class="p">.</span><span class="nx">__reactInternalSnapshotBeforeUpdate</span> <span class="o">=</span> <span class="nx">snapshot</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nx">HostRoot</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="nx">supportsMutation</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="nx">finishedWork</span><span class="p">.</span><span class="nx">flags</span> <span class="o">&amp;</span> <span class="nx">Snapshot</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="kr">const</span> <span class="nx">root</span> <span class="o">=</span> <span class="nx">finishedWork</span><span class="p">.</span><span class="nx">stateNode</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">          <span class="nx">clearContainer</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">containerInfo</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nx">HostComponent</span>:
</span></span><span class="line"><span class="cl">    <span class="kt">case</span> <span class="nx">HostText</span>:
</span></span><span class="line"><span class="cl">    <span class="kt">case</span> <span class="nx">HostPortal</span>:
</span></span><span class="line"><span class="cl">    <span class="kt">case</span> <span class="nx">IncompleteClassComponent</span>:
</span></span><span class="line"><span class="cl">      <span class="kt">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></tbody></table></div></div><ul><li>componentDidMount/componentDidUpdate</li></ul><div class="highlight"><div class="chroma"><table class="lntable"><tbody><tr><td class="lntd"><pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span></code></pre></td><td class="lntd"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 在 commitRoot 里循环调用 commitLayoutEffects 直到 nextEffect 为 null
</span></span></span><span class="line"><span class="cl"><span class="cm"> * commitLifeCycles 会在 commitLayoutEffects 里被调用
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">commitLifeCycles</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="nx">finishedRoot</span>: <span class="kt">FiberRoot</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">current</span>: <span class="kt">Fiber</span> <span class="o">|</span> <span class="kc">null</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">finishedWork</span>: <span class="kt">Fiber</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">committedLanes</span>: <span class="kt">Lanes</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="p">)</span><span class="o">:</span> <span class="k">void</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">switch</span> <span class="p">(</span><span class="nx">finishedWork</span><span class="p">.</span><span class="nx">tag</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">case</span> <span class="nx">ClassComponent</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kr">const</span> <span class="nx">instance</span> <span class="o">=</span> <span class="nx">finishedWork</span><span class="p">.</span><span class="nx">stateNode</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="nx">finishedWork</span><span class="p">.</span><span class="nx">flags</span> <span class="o">&amp;</span> <span class="nx">Update</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="c1">// 根据是否是初次渲染，选择调用 componentDidMount 还是 componentDidUpdate
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="k">if</span> <span class="p">(</span><span class="nx">current</span> <span class="o">===</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">              <span class="nx">instance</span><span class="p">.</span><span class="nx">componentDidMount</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">          <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="kr">const</span> <span class="nx">prevProps</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">              <span class="nx">finishedWork</span><span class="p">.</span><span class="nx">elementType</span> <span class="o">===</span> <span class="nx">finishedWork</span><span class="p">.</span><span class="kr">type</span>
</span></span><span class="line"><span class="cl">                <span class="o">?</span> <span class="nx">current.memoizedProps</span>
</span></span><span class="line"><span class="cl">                : <span class="kt">resolveDefaultProps</span><span class="p">(</span><span class="nx">finishedWork</span><span class="p">.</span><span class="kr">type</span><span class="p">,</span> <span class="nx">current</span><span class="p">.</span><span class="nx">memoizedProps</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="kr">const</span> <span class="nx">prevState</span> <span class="o">=</span> <span class="nx">current</span><span class="p">.</span><span class="nx">memoizedState</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">              <span class="nx">instance</span><span class="p">.</span><span class="nx">componentDidUpdate</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">                <span class="nx">prevProps</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                <span class="nx">prevState</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                <span class="nx">instance</span><span class="p">.</span><span class="nx">__reactInternalSnapshotBeforeUpdate</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">              <span class="p">);</span>
</span></span><span class="line"><span class="cl">          <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="kr">const</span> <span class="nx">updateQueue</span> <span class="o">=</span> <span class="p">(</span><span class="nx">finishedWork.updateQueue</span>: <span class="kt">any</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="nx">updateQueue</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="nx">commitUpdateQueue</span><span class="p">(</span><span class="nx">finishedWork</span><span class="p">,</span> <span class="nx">updateQueue</span><span class="p">,</span> <span class="nx">instance</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span></code></pre></td></tr></tbody></table></div></div><ul><li>componentWillUnmount</li></ul><div class="highlight"><div class="chroma"><table class="lntable"><tbody><tr><td class="lntd"><pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td><td class="lntd"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 组件卸载时会调用 commitUnmount，其中包含了不同类型的组件的卸载方式
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 对于 ClassComponent 会先解绑 ref（safelyDetachRef）再调用 safelyCallComponentWillUnmount
</span></span></span><span class="line"><span class="cl"><span class="cm"> * safelyCallComponentWillUnmount 会在 try...catch 里调用 callComponentWillUnmountWithTimer
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">callComponentWillUnmountWithTimer</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">current</span><span class="p">,</span> <span class="nx">instance</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">instance</span><span class="p">.</span><span class="nx">props</span> <span class="o">=</span> <span class="nx">current</span><span class="p">.</span><span class="nx">memoizedProps</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">instance</span><span class="p">.</span><span class="nx">state</span> <span class="o">=</span> <span class="nx">current</span><span class="p">.</span><span class="nx">memoizedState</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">instance</span><span class="p">.</span><span class="nx">componentWillUnmount</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></tbody></table></div></div><ul><li>getDerivedStateFromError/componentDidCatch</li></ul><div class="highlight"><div class="chroma"><table class="lntable"><tbody><tr><td class="lntd"><pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span></code></pre></td><td class="lntd"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 在 renderRootSync 的过程中，如果 workLoopSync/workLoopConcurrent 执行出错，会执行 handleError
</span></span></span><span class="line"><span class="cl"><span class="cm"> * throwException 会将 createClassErrorUpdate 的返回值通过 enqueueCapturedUpdate 加入更新队列
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">createClassErrorUpdate</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="nx">fiber</span>: <span class="kt">Fiber</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">errorInfo</span>: <span class="kt">CapturedValue</span><span class="p">&lt;</span><span class="nt">mixed</span><span class="p">&gt;,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">lane</span>: <span class="kt">Lane</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="o">:</span> <span class="nx">Update</span><span class="p">&lt;</span><span class="nt">mixed</span><span class="p">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">update</span> <span class="o">=</span> <span class="nx">createUpdate</span><span class="p">(</span><span class="nx">NoTimestamp</span><span class="p">,</span> <span class="nx">lane</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nx">update</span><span class="p">.</span><span class="nx">tag</span> <span class="o">=</span> <span class="nx">CaptureUpdate</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">getDerivedStateFromError</span> <span class="o">=</span> <span class="nx">fiber</span><span class="p">.</span><span class="kr">type</span><span class="p">.</span><span class="nx">getDerivedStateFromError</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">getDerivedStateFromError</span> <span class="o">===</span> <span class="s1">'function'</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kr">const</span> <span class="nx">error</span> <span class="o">=</span> <span class="nx">errorInfo</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nx">update</span><span class="p">.</span><span class="nx">payload</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">logCapturedError</span><span class="p">(</span><span class="nx">fiber</span><span class="p">,</span> <span class="nx">errorInfo</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="nx">getDerivedStateFromError</span><span class="p">(</span><span class="nx">error</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">};</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">inst</span> <span class="o">=</span> <span class="nx">fiber</span><span class="p">.</span><span class="nx">stateNode</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nx">inst</span> <span class="o">!==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="k">typeof</span> <span class="nx">inst</span><span class="p">.</span><span class="nx">componentDidCatch</span> <span class="o">===</span> <span class="s1">'function'</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">update</span><span class="p">.</span><span class="nx">callback</span> <span class="o">=</span> <span class="kd">function</span> <span class="nx">callback() {</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">getDerivedStateFromError</span> <span class="o">!==</span> <span class="s1">'function'</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">         * 为了保留错误边界的先前存在的重试行为
</span></span></span><span class="line"><span class="cl"><span class="cm">         * 我们跟踪在这一批中哪些已经失败
</span></span></span><span class="line"><span class="cl"><span class="cm">         * 在我们返回到浏览器之前，它会被重置
</span></span></span><span class="line"><span class="cl"><span class="cm">         */</span>
</span></span><span class="line"><span class="cl">        <span class="nx">markLegacyErrorBoundaryAsFailed</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// log 一下，如果 componentDidCatch 是唯一被定义的错误边界方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">logCapturedError</span><span class="p">(</span><span class="nx">fiber</span><span class="p">,</span> <span class="nx">errorInfo</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="kr">const</span> <span class="nx">error</span> <span class="o">=</span> <span class="nx">errorInfo</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="kr">const</span> <span class="nx">stack</span> <span class="o">=</span> <span class="nx">errorInfo</span><span class="p">.</span><span class="nx">stack</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">this</span><span class="p">.</span><span class="nx">componentDidCatch</span><span class="p">(</span><span class="nx">error</span><span class="p">,</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">componentStack</span>: <span class="kt">stack</span> <span class="o">!==</span> <span class="kc">null</span> <span class="o">?</span> <span class="nx">stack</span> <span class="o">:</span> <span class="s1">''</span>
</span></span><span class="line"><span class="cl">      <span class="p">});</span>
</span></span><span class="line"><span class="cl">    <span class="p">};</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">update</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kr">export</span> <span class="kd">function</span> <span class="nx">captureCommitPhaseError</span><span class="p">(</span><span class="nx">sourceFiber</span>: <span class="kt">Fiber</span><span class="p">,</span> <span class="nx">error</span>: <span class="kt">mixed</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nx">sourceFiber</span><span class="p">.</span><span class="nx">tag</span> <span class="o">===</span> <span class="nx">HostRoot</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 错误在根组件被抛出，没有父级，需要根组件捕获
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">captureCommitPhaseErrorOnRoot</span><span class="p">(</span><span class="nx">sourceFiber</span><span class="p">,</span> <span class="nx">sourceFiber</span><span class="p">,</span> <span class="nx">error</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">fiber</span> <span class="o">=</span> <span class="nx">sourceFiber</span><span class="p">.</span><span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="nx">fiber</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 向上查找
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="nx">fiber</span><span class="p">.</span><span class="nx">tag</span> <span class="o">===</span> <span class="nx">HostRoot</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">captureCommitPhaseErrorOnRoot</span><span class="p">(</span><span class="nx">fiber</span><span class="p">,</span> <span class="nx">sourceFiber</span><span class="p">,</span> <span class="nx">error</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">fiber</span><span class="p">.</span><span class="nx">tag</span> <span class="o">===</span> <span class="nx">ClassComponent</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="kr">const</span> <span class="nx">ctor</span> <span class="o">=</span> <span class="nx">fiber</span><span class="p">.</span><span class="kr">type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="kr">const</span> <span class="nx">instance</span> <span class="o">=</span> <span class="nx">fiber</span><span class="p">.</span><span class="nx">stateNode</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="k">typeof</span> <span class="nx">ctor</span><span class="p">.</span><span class="nx">getDerivedStateFromError</span> <span class="o">===</span> <span class="s1">'function'</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">        <span class="p">(</span><span class="k">typeof</span> <span class="nx">instance</span><span class="p">.</span><span class="nx">componentDidCatch</span> <span class="o">===</span> <span class="s1">'function'</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">          <span class="o">!</span><span class="nx">isAlreadyFailedLegacyErrorBoundary</span><span class="p">(</span><span class="nx">instance</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">      <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kr">const</span> <span class="nx">errorInfo</span> <span class="o">=</span> <span class="nx">createCapturedValue</span><span class="p">(</span><span class="nx">error</span><span class="p">,</span> <span class="nx">sourceFiber</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="kr">const</span> <span class="nx">update</span> <span class="o">=</span> <span class="nx">createClassErrorUpdate</span><span class="p">(</span><span class="nx">fiber</span><span class="p">,</span> <span class="nx">errorInfo</span><span class="p">,</span> <span class="nx">SyncLane</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nx">enqueueUpdate</span><span class="p">(</span><span class="nx">fiber</span><span class="p">,</span> <span class="nx">update</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="kr">const</span> <span class="nx">eventTime</span> <span class="o">=</span> <span class="nx">requestEventTime</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="kr">const</span> <span class="nx">root</span> <span class="o">=</span> <span class="nx">markUpdateLaneFromFiberToRoot</span><span class="p">(</span><span class="nx">fiber</span><span class="p">,</span> <span class="nx">SyncLane</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="nx">root</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="nx">markRootUpdated</span><span class="p">(</span><span class="nx">root</span><span class="p">,</span> <span class="nx">SyncLane</span><span class="p">,</span> <span class="nx">eventTime</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">          <span class="nx">ensureRootIsScheduled</span><span class="p">(</span><span class="nx">root</span><span class="p">,</span> <span class="nx">eventTime</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">          <span class="nx">schedulePendingInteractions</span><span class="p">(</span><span class="nx">root</span><span class="p">,</span> <span class="nx">SyncLane</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="c1">// 组件已经被卸载，为了错误不被吞掉，可以调用 log 边界
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="k">if</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="k">typeof</span> <span class="nx">instance</span><span class="p">.</span><span class="nx">componentDidCatch</span> <span class="o">===</span> <span class="s1">'function'</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">            <span class="o">!</span><span class="nx">isAlreadyFailedLegacyErrorBoundary</span><span class="p">(</span><span class="nx">instance</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">          <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">              <span class="nx">instance</span><span class="p">.</span><span class="nx">componentDidCatch</span><span class="p">(</span><span class="nx">error</span><span class="p">,</span> <span class="nx">errorInfo</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">errorToIgnore</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">              <span class="c1">// 边缘情况
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="p">}</span>
</span></span><span class="line"><span class="cl">          <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">fiber</span> <span class="o">=</span> <span class="nx">fiber</span><span class="p">.</span><span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></tbody></table></div></div><h2 id="参考">参考</h2><ul><li><a class="link" href="https://zhuanlan.zhihu.com/p/55000793" target="_blank" rel="noopener">React 的组件类型</a></li><li><a class="link" href="https://zhuanlan.zhihu.com/p/37095662" target="_blank" rel="noopener">React Fiber 架构</a></li><li><a class="link" href="https://react.iamkasong.com" target="_blank" rel="noopener">React 技术揭秘</a></li></ul></section><footer class="article-footer"><section class="article-not-by-ai-badge"><a href="https://notbyai.fyi/cn/" target="_blank" title="Not By AI"><svg width="131" height="42" viewBox="0 0 131 42" fill="none"><path d="M.5.5H116c8.008.0 14.5 6.49187 14.5 14.5V41.5H15C6.99187 41.5.5 35.0081.5 27V.5z" fill="#fff" stroke="#000"></path><path d="M17.9605 24.1575c3.4661 2.8068 8.4231 2.8068 11.8892.0l-1.3402-1.6549c-2.6847 2.174-6.5241 2.174-9.2088.0l-1.3402 1.6549z" fill="#000"></path><path d="M19.404 20.5134V17.6365h2.1296v2.8769H19.404z" fill="#000"></path><path d="M26.012 17.6365v2.8769h2.1295V17.6365H26.012z" fill="#000"></path><path fill-rule="evenodd" clip-rule="evenodd" d="M35 21.5C35 27.8513 29.8513 33 23.5 33S12 27.8513 12 21.5C12 15.1487 17.1487 10 23.5 10S35 15.1487 35 21.5zm-2.1295.0c0 5.1752-4.1953 9.3705-9.3705 9.3705S14.1295 26.6752 14.1295 21.5s4.1953-9.3705 9.3705-9.3705 9.3705 4.1953 9.3705 9.3705z" fill="#000"></path><path d="M61.844 12.1721l.1995.711L62.2294 12.8197C62.5169 12.7216 62.8276 12.6155 63.1503 12.5052v2.55C63.1503 15.1818 63.1005 15.2208 62.9709 15.2208 62.8612 15.2208 62.4922 15.2208 62.0634 15.211 62.1631 15.4156 62.2628 15.7273 62.2928 15.9123 62.901 15.9123 63.28 15.8929 63.5293 15.776 63.7686 15.6591 63.8583 15.4545 63.8583 15.0455V12.2629C64.2106 12.1421 64.5673 12.0195 64.9154 11.8994L64.8057 11.2273C64.4898 11.3348 64.1706 11.4415 63.8583 11.5441V9.63961H64.8057V8.95779H63.8583V7H63.1503V8.95779H61.9936v.68182h1.1567V11.7732C62.6577 11.9301 62.2064 12.0683 61.844 12.1721z" fill="#000"></path><path fill-rule="evenodd" clip-rule="evenodd" d="M66.0322 10.7695C65.3142 10.7695 65.1347 10.5162 65.1347 9.8052V7.39935h2.6127V9.32792H65.763V9.81494C65.763 10.1169 65.8128 10.2045 66.0322 10.2045H67.2986C67.4781 10.2045 67.7474 10.1948 67.9069 10.1656 67.9134 10.2165 67.92 10.2777 67.9268 10.3422 67.941 10.4754 67.9566 10.6224 67.9767 10.7208 67.8371 10.7597 67.5779 10.7695 67.3086 10.7695H66.0322zM65.763 7.90584H67.1391V8.82143H65.763V7.90584z" fill="#000"></path><path fill-rule="evenodd" clip-rule="evenodd" d="M69.0736 10.7208C68.3656 10.7208 68.1861 10.4773 68.1861 9.76623V7.39935H70.8087V9.2987H68.8144V9.77597C68.8144 10.0682 68.8642 10.1656 69.0936 10.1656h1.3262C70.5993 10.1656 70.8985 10.1461 71.058 10.1071 71.068 10.2825 71.0979 10.5357 71.1179 10.6721 70.9783 10.7208 70.709 10.7208 70.4298 10.7208H69.0736zM68.8144 7.90584h1.396v.88637h-1.396V7.90584z" fill="#000"></path><path d="M66.83 14.1299C66.2715 14.6753 65.3142 15.1818 64.4567 15.5032 64.6262 15.6201 64.9054 15.8539 65.035 15.9805 65.8727 15.6104 66.8898 14.9968 67.5081 14.3831L66.83 14.1299z" fill="#000"></path><path d="M68.4554 14.4513C69.2132 14.9091 70.1905 15.5812 70.6791 16L71.2974 15.6104C70.7788 15.1818 69.7916 14.539 69.0437 14.1007L68.4554 14.4513z" fill="#000"></path><path d="M50.4761 15.9318C49.798 15.5617 48.6612 15.0942 47.5344 14.7338L48.0031 14.2468C49.1299 14.5974 50.3564 15.0552 51.0844 15.4253L50.4761 15.9318z" fill="#000"></path><path d="M42 15.4156C43.067 15.1623 44.4032 14.6656 45.0713 14.2468L45.7594 14.6753C44.9218 15.1721 43.5855 15.6786 42.5185 15.9513 42.4088 15.8052 42.1596 15.5519 42 15.4156z" fill="#000"></path><path d="M56.1556 7.21693C56.1571 7.15007 56.1585 7.0868 56.1601 7.02922H56.9877L56.9868 7.0714C56.9788 7.4194 56.968 7.88942 56.9233 8.43665 57.0639 9.58208 57.6711 13.7136 61.2258 15.2597 61.0064 15.4253 60.787 15.6786 60.6773 15.8831c-2.5071-1.144-3.5872-3.5484-4.0775-5.3684C56.13 12.4644 55.0681 14.6445 52.63 15.9221 52.5004 15.7273 52.2511 15.5032 52.0217 15.3474c3.9976-1.9757 4.0968-6.45452 4.1339-8.13047z" fill="#000"></path><path d="M75.0586 9.43506C75.1376 9.06022 75.2116 8.69288 75.2761 8.3539L74.5283 8.27597C74.3089 9.50325 73.9299 11.1688 73.6408 12.1623L74.3986 12.2305C74.4264 12.1301 74.4552 12.0226 74.4848 11.9091H78.3699C78.3296 12.3408 78.2883 12.7224 78.2455 13.0584H72.0851V13.7403h6.0611C78.0034 14.5883 77.8408 15.0239 77.6395 15.1916 77.5198 15.289 77.4002 15.2987 77.1708 15.2987 76.9215 15.2987 76.2334 15.2987 75.5454 15.2305 75.675 15.4253 75.7747 15.7175 75.7947 15.9221 76.4429 15.961 77.091 15.9708 77.4201 15.9513 77.799 15.9318 78.0284 15.8636 78.2677 15.6396 78.532 15.3814 78.7263 14.8409 78.8969 13.7403H81V13.0584H78.991C79.0434 12.6344 79.0943 12.1472 79.1452 11.5877 79.1552 11.4805 79.1751 11.2565 79.1751 11.2565H74.6483C74.7379 10.8862 74.8303 10.4846 74.92 10.0779H79.2948V9.43506H75.0586z" fill="#000"></path><path fill-rule="evenodd" clip-rule="evenodd" d="M65.1746 11.6266V12.25H66.5109v1.1299H64.7558v.6233H71.1079v-.6233H69.5523V12.25h1.3262v-.6234H69.5523v-.6623H68.8642v.6623H67.189V10.9838H66.5109V11.6266H65.1746zm2.0144 1.7533V12.25h1.6752v1.1299H67.189z" fill="#000"></path><path fill-rule="evenodd" clip-rule="evenodd" d="M42.1895 14.0909v-.6234h1.4359V9.06494h2.5129V8.4513H42.4687V7.81818h3.6696V7.00974H46.8762v.80844H50.7852V8.4513H46.8762v.61364h2.7623V13.4675h1.406v.6234h-8.855zm2.1539-.6234h4.5472V12.7857H44.3434V13.4675zm0-1.1493h4.5472V11.7338H44.3434V12.3182zm0-1.0617h4.5472v-.5747H44.3434v.5747zm0-1.0325h4.5472V9.58117H44.3434V10.224z" fill="#000"></path><path d="M72.3245 9.65909V7.52597h8.4362V9.65909H79.9829V8.20779H73.0624v1.4513H72.3245z" fill="#000"></path><path fill-rule="evenodd" clip-rule="evenodd" d="M105.32 26.2505C105.32 25.9898 105.336 25.4196 105.336 25.4196H101.424V23.8717H105.573C105.764 26.2238 106.11 28.471 106.651 30.2984c-.875.9892-1.892 1.8173-3.039 2.4531C104.107 33.2077 104.953 34.2016 105.288 34.7067 106.138 34.1597 106.93 33.5082 107.658 32.7639 108.338 33.9391 109.193 34.6415 110.254 34.6415 111.898 34.6415 112.649 33.9572 113 30.78 112.377 30.5356 111.563 29.9817 111.036 29.4277 110.956 31.4155 110.765 32.2301 110.445 32.2301 110.06 32.2301 109.67 31.686 109.312 30.7655 110.465 29.1244 111.389 27.1985 112.058 25.0611L109.711 24.4908C109.396 25.6095 108.983 26.659 108.478 27.6243 108.264 26.4884 108.09 25.2105 107.974 23.8717h4.866V21.5418H111.142L111.946 20.6945C111.387 20.1568 110.27 19.4399 109.455 19l-1.405 1.4175C108.553 20.7329 109.148 21.1437 109.647 21.5418H107.835C107.811 20.7923 107.808 20.0385 107.827 19.2933h-2.443C105.387 20.0364 105.403 20.7892 105.433 21.5418H98.9812v4.8879C98.9812 28.5642 98.9014 31.4481 97.7199 33.3707 98.2468 33.6477 99.3006 34.5275 99.6997 35 100.514 33.7498 100.957 32.0088 101.189 30.2753 101.506 30.8638 101.745 31.7506 101.775 32.4257 102.51 32.4257 103.18 32.4094 103.612 32.3279 104.091 32.2301 104.458 32.0672 104.809 31.5947 105.192 31.0733 105.272 29.5743 105.32 26.2505zM101.197 30.2141C101.316 29.3052 101.378 28.4 101.406 27.5703h1.652C103.023 29.1922 102.963 29.8644 102.829 30.0631 102.701 30.2261 102.558 30.2749 102.35 30.2749 102.102 30.2749 101.674 30.2596 101.197 30.2141z" fill="#000"></path><path d="M86.8673 22.112C87.1314 21.4187 87.3672 20.705 87.565 19.9939L85.1541 19.4399C84.6112 21.6395 83.5893 23.8717 82.3599 25.2077 82.9507 25.5336 83.9885 26.2342 84.4515 26.6415 84.9297 26.0332 85.4007 25.2744 85.839 24.4257h3.0672v2.4928H84.7709v2.2811h4.1353V32.002H82.8708v2.3137H97.4005V32.002H91.3332V29.1996H95.9156V26.9185H91.3332V24.4257H96.5543V22.112H91.3332V19.277H88.9062v2.835H86.8673z" fill="#000"></path><path d="M47.3436 28.4645C47.4377 28.0285 47.4856 27.6141 47.4988 27.2444H43.8462V25.11h3.6564V23.4807h-3.816V21.2811h3.816V19.3585h2.2992V27c0 2.8513-.862200000000001 6.0611-4.774 7.9837C44.6446 34.4134 43.9261 33.6802 43.3672 33.224 44.7784 32.6761 45.7414 31.786 46.3804 30.8057 45.6568 30.9237 44.9507 31.0375 44.2921 31.1436L43.4151 31.2851 43 28.9226C44.1273 28.8236 45.7056 28.6496 47.3436 28.4645z" fill="#000"></path><path fill-rule="evenodd" clip-rule="evenodd" d="M72.6755 34.3305 67.632 19.7976H64.2697L59.1875 34.3305h3.1111L63.2841 31.3431H68.5306l.9178 2.9874H72.6755zM65.9218 23.1202l1.7778 5.7186H64.0861l1.8357-5.7186z" fill="#000"></path><path d="M53.7456 19.3585v1.9226h4.1833v2.1996H53.7456V25.11H57.5457v2.1344H53.7456v1.6619H58.2163v2.1996H53.7456v3.6497H51.4144V19.3585h2.3312z" fill="#000"></path><path d="M75.2125 22.2696v9.5922H73.4582v2.4721H79.719V31.8618h-1.55V22.2696h1.55v-2.472H73.4582v2.472h1.7543z" fill="#000"></path></svg></a></section></footer></article><aside class="related-content--wrapper"><h2 class="section-title">相关文章</h2><div class="related-content"><div class="flex article-list--tile"><article class="has-image"><a href="/p/ai-js-sdk-%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93%E4%BA%8C/"><div class="article-image"><img src="/img/cover/react.webp" loading="lazy" data-key="" data-hash="/img/cover/react.png" alt="" decoding="async" width="1200" height="720" jampack-sized="true"></div><div class="article-details"><h2 class="article-title">AI JS-SDK 项目总结（二）</h2></div></a></article><article class="has-image"><a href="/p/ai-js-sdk-%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93%E4%B8%80/"><div class="article-image"><img src="/img/cover/react.webp" loading="lazy" data-key="" data-hash="/img/cover/react.png" alt="" decoding="async" width="1200" height="720" jampack-sized="true"></div><div class="article-details"><h2 class="article-title">AI JS-SDK 项目总结（一）</h2></div></a></article><article class="has-image"><a href="/p/%E8%BD%AC%E6%88%91%E5%9C%A8%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E4%B8%AD%E5%8F%AF%E4%BB%A5%E9%9A%8F%E4%BE%BF%E5%86%99%E6%9C%80%E9%80%9A%E4%BF%97%E5%BC%82%E6%AD%A5%E7%BB%84%E4%BB%B6%E5%8E%9F%E7%90%86/"><div class="article-image"><img src="/img/cover/react.webp" loading="lazy" data-key="" data-hash="/img/cover/react.png" alt="" decoding="async" width="1200" height="720" jampack-sized="true"></div><div class="article-details"><h2 class="article-title">「转」我在函数组件中可以随便写，最通俗异步组件原理</h2></div></a></article><article class="has-image"><a href="/p/react-%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD/"><div class="article-image"><img src="/img/cover/react.webp" loading="lazy" data-key="" data-hash="/img/cover/react.png" alt="" decoding="async" width="1200" height="720" jampack-sized="true"></div><div class="article-details"><h2 class="article-title">React 复习笔记（中）</h2></div></a></article><article class="has-image"><a href="/p/react-%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%8A/"><div class="article-image"><img src="/img/cover/react.webp" loading="lazy" data-key="" data-hash="/img/cover/react.png" alt="" decoding="async" width="1200" height="720" jampack-sized="true"></div><div class="article-details"><h2 class="article-title">React 复习笔记（上）</h2></div></a></article></div></div></aside><footer class="site-footer"><section class="copyright" style="display:flex;justify-content:flex-start;align-items:center">©
2017 -
2025
<a href="https://github.com/ElementRef" target="_blank">馬腊咯稽
</a><a href="https://ipw.cn/ipv6webcheck/?site=elementref.github.io" target="_blank" title="本站支持 IPv6 访问"><img style="display:inline-block;vertical-align:middle" src="https://static.ipw.cn/icon/ipv6-certified-lite-s1.svg" alt="本站支持 IPv6 访问" loading="lazy" decoding="async"></a></section><section class="powerby">Built with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a>, Deploy by Actions<br>主题 <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.13.0">Stack</a></b> 由 <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a> 设计</section></footer><div class="pswp" tabindex="-1" role="dialog" aria-hidden="true"><div class="pswp__bg"></div><div class="pswp__scroll-wrap"><div class="pswp__container"><div class="pswp__item"></div><div class="pswp__item"></div><div class="pswp__item"></div></div><div class="pswp__ui pswp__ui--hidden"><div class="pswp__top-bar"><div class="pswp__counter"></div><button class="pswp__button pswp__button--close" title="关闭"></button>
<button class="pswp__button pswp__button--fs" title="全屏"></button>
<button class="pswp__button pswp__button--zoom" title="缩放"></button><div class="pswp__preloader"><div class="pswp__preloader__icn"><div class="pswp__preloader__cut"><div class="pswp__preloader__donut"></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class="pswp__share-tooltip"></div></div><button class="pswp__button pswp__button--arrow--left" title="上一张"></button>
<button class="pswp__button pswp__button--arrow--right" title="下一张"></button><div class="pswp__caption"><div class="pswp__caption__center"></div></div></div></div></div><script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js" integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin="anonymous" defer=""></script><script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js" integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin="anonymous" defer=""></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css" crossorigin="anonymous"></main><aside class="sidebar sticky right-sidebar"><section class="archives widget"><div class="widget-icon"><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"></path><line x1="5" y1="9" x2="19" y2="9"></line><line x1="5" y1="15" x2="19" y2="15"></line><line x1="11" y1="4" x2="7" y2="20"></line><line x1="17" y1="4" x2="13" y2="20"></line></svg></div><h2 class="section-title widget-title">目录</h2><div class="widget--toc"><nav id="TableOfContents"><ol><li><a href="#调用-reactdomrender-发生了什么">调用 ReactDOM.render 发生了什么？</a></li><li><a href="#调用-scheduleupdateonfiber-发生了什么">调用 scheduleUpdateOnFiber 发生了什么？</a></li><li><a href="#scheduler任务调度高优先级的任务先进行-render">scheduler（任务调度，高优先级的任务先进行 render）</a></li><li><a href="#reconcilerrender-阶段构建-workinprogress收集要更新的节点">reconciler（render 阶段，构建 workInProgress，收集要更新的节点）</a></li><li><a href="#renderercommit-阶段更新页面">renderer（commit 阶段，更新页面）</a></li><li><a href="#diff">diff</a></li><li><a href="#fiber">fiber</a></li><li><a href="#hooks">hooks</a></li><li><a href="#组件类型">组件类型</a></li><li><a href="#状态更新">状态更新</a></li><li><a href="#生命周期">生命周期</a></li><li><a href="#参考">参考</a></li></ol></nav></div></section></aside></div><script src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js" integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin="anonymous"></script><script type="text/javascript" src="/ts/main.js" defer=""></script><script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script><script>NProgress.configure({showSpinner:!1}),NProgress.start(),document.addEventListener("readystatechange",()=>{document.readyState==="interactive"&&NProgress.inc(.8),document.readyState==="complete"&&NProgress.done()})</script></body></html>